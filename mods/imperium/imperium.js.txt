
    this.importTech("antimass-deflectors", {
      name        	:       "Antimass Deflectors" ,
      color       	:       "blue" ,
      prereqs             :       [],
      text		: 	"You may move through asteroid fields and gain -1 when receiving PDS fire",
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].antimass_deflectors == undefined) {
          imperium_self.game.players_info[player-1].antimass_deflectors = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "antimass-deflectors") {
          imperium_self.game.players_info[gainer-1].antimass_deflectors = 1;
          imperium_self.game.players_info[gainer-1].fly_through_asteroids = 1;
        }
      },
    });


    this.importTech("gravity-drive", {
      name                :       "Gravity Drive" ,
      color               :       "blue" ,
      prereqs             :       ["blue"],
      text		: 	"One ship may gain +1 movement when you activate a system" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].gravity_drive == undefined) {
          imperium_self.game.players_info[player-1].gravity_drive = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "gravity-drive") {
          imperium_self.game.players_info[gainer-1].gravity_drive = 1;
          imperium_self.game.players_info[gainer-1].ship_move_bonus = 1;
        }
      },
    });




    this.importTech("fleet-logistics", {
      name        	: 	"Fleet Logistics" ,
      color       	: 	"blue" ,
      prereqs     	:       ['blue','blue'],
      text		: 	"You may perform two actions in any turn" ,
      onNewRound : function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "fleet-logistics")) {
          imperium_self.game.players_info[player-1].fleet_logistics_turn = 0;
        }
      },
      onNewTurn : function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "fleet-logistics")) {
          imperium_self.game.players_info[player-1].fleet_logistics_turn++;
	}
      },
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].fleet_logistics == undefined) {
          imperium_self.game.players_info[player-1].fleet_logistics = 0;
          imperium_self.game.players_info[player-1].fleet_logistics_exhausted = 0;
          imperium_self.game.players_info[player-1].fleet_logistics_turn = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "fleet-logistics") {
          imperium_self.game.players_info[gainer-1].fleet_logistics = 1;
          imperium_self.game.players_info[gainer-1].fleet_logistics_exhausted = 0;
          imperium_self.game.players_info[gainer-1].perform_two_actions = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        if (menu == "main") {
          if (imperium_self.doesPlayerHaveTech(player, "fleet-logistics")) {
            return { event : 'fleetlogistics', html : '<li class="option" id="fleetlogistics">use fleet logistics</li>' };
	  }
        }
        return {};
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
        if (menu == "main") {
          if (imperium_self.doesPlayerHaveTech(player, "fleet-logistics")) {
	  if (imperium_self.game.players_info[player-1].fleet_logistics_exhausted == 0) {
	    if (imperium_self.game.players_info[player-1].fleet_logistics_turn < 2) {
	      if (imperium_self.game.players_info[player-1].fleet_logistics == 1) {
                return 1;
	      }
	    }
	  }
	  }
        }
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {
	if (menu == "main") {
  	  imperium_self.game.players_info[player-1].fleet_logistics_exhausted = 1;
          imperium_self.updateLog(imperium_self.returnFaction(player) + " exhausts Fleet Logistics");
          imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"fleet_logistics_exhausted"+"\t"+"int"+"\t"+"1");
	  imperium_self.addMove("play\t"+player);
	  imperium_self.addMove("play\t"+player);
          imperium_self.addMove("NOTIFY\t"+player+" activates fleet logistics");
	  imperium_self.endTurn();
	  imperium_self.updateStatus("Activating Fleet Logistics");
        }
        return 0;
      }

    });


    this.importTech("lightwave-deflector", {
      name        	:       "Light/Wave Deflector" ,
      color       	:       "blue" ,
      prereqs     	:       ['blue','blue','blue'],
      text		:	"Your fleet may move through sectors with opponent ships" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].lightwave_deflector == undefined) {
          imperium_self.game.players_info[player-1].lightwave_deflector = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "lightwave-deflector") {
          imperium_self.game.players_info[gainer-1].lightwave_deflector = 1;
          imperium_self.game.players_info[gainer-1].move_through_sectors_with_opponent_ships = 1;
        }
      },
    });



    this.importTech("neural-motivator", {
      name        	:       "Neural Motivator" ,
      color       	:       "green" ,
      prereqs             :       [],
      text		:	"Gain an extra action card each turn" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].neural_motivator == undefined) {
          imperium_self.game.players_info[player-1].neural_motivator = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "neural-motivator") {
          imperium_self.game.players_info[gainer-1].neural_motivator = 1;
          imperium_self.game.players_info[gainer-1].action_cards_bonus_when_issued = 1;
        }
      },
    });


    this.importTech("dacxive-animators", {
      name                :       "Dacxive Animators" ,
      color               :       "green" ,
      prereqs             :       ["green"],
      text		:	"Place an extra infantry on any planet after winning a defensive ground combat tbere" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].dacxive_animators == undefined) {
          imperium_self.game.players_info[player-1].dacxive_animators = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "dacxive-animators") {
          imperium_self.game.players_info[gainer-1].dacxive_animators = 1;
        }
      },
      groundCombatRoundEnd : function(imperium_self, attacker, defender, sector, planet_idx) {
        let attacker_forces = imperium_self.returnNumberOfGroundForcesOnPlanet(attacker, sector, planet_idx);
        let defender_forces = imperium_self.returnNumberOfGroundForcesOnPlanet(defender, sector, planet_idx);
	//if (imperium_self.doesPlayerHaveTech(attacker, "dacxive-animators")) {
	//  if (attacker_forces > defender_forces && defender_forces == 0) {
	//    imperium_self.addPlanetaryUnit(attacker, sector, planet_idx, "infantry");
	//    imperium_self.updateLog(imperium_self.returnFaction(attacker) + " reinforces infantry with Dacxive Animators");
	//  }
	//}
	if (imperium_self.doesPlayerHaveTech(defender, "dacxive-animators")) {
	  if (attacker_forces < defender_forces && attacker_forces == 0) {
	    imperium_self.addPlanetaryUnit(defender, sector, planet_idx, "infantry");
	    imperium_self.updateLog(imperium_self.returnFaction(defender) + " reinforces infantry with Dacxive Animators");
	  }
	}
      },
    });


    this.importTech("hyper-metabolism", {
      name        	: 	"Hyper Metabolism" ,
      color       	: 	"green" ,
      prereqs     	:       ['green','green'],
      text		:	"Gain an extra command token each round" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].hyper_metabolism == undefined) {
          imperium_self.game.players_info[player-1].hyper_metabolism = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "hyper-metabolism") {
          imperium_self.game.players_info[gainer-1].hyper_metabolism = 1;
          imperium_self.game.players_info[gainer-1].new_tokens_bonus_when_issued = 1;
        }
      },
    });




    this.importTech("x89-bacterial-weapon", {
      name        	:       "X-89 Bacterial Weapon" ,
      color       	:       "green" ,
      prereqs     	:       ['green','green','green'],
      text		:	"Bombardment destroys all infantry on planet" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].x89_bacterial_weapon == undefined) {
          imperium_self.game.players_info[player-1].x89_bacterial_weapon = 0;
          imperium_self.game.players_info[player-1].x89_bacterial_weapon_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "x89-bacterial-weapon") {
          imperium_self.game.players_info[gainer-1].x89_bacterial_weapon = 1;
          imperium_self.game.players_info[gainer-1].x89_bacterial_weapon_exhausted = 0;
        }
      },
      onNewRound : function(imperium_self, player) {
        imperium_self.game.players_info[player-1].x89_bacterial_weapon_exhausted = 0;
        return 1;
      },
      bombardmentTriggers : function(imperium_self, player, bombarding_player, sector) { 
	if (imperium_self.game.players_info[bombarding_player-1].x89_bacterial_weapon == 1 && imperium_self.game.players_info[bombarding_player-1].x89_bacterial_weapon_exhausted == 0) {
	  if (imperium_self.doesSectorContainPlayerUnit(bombarding_player, sector, "warsun") || imperium_self.doesSectorContainPlayerUnit(bombarding_player, sector, "dreadnaught")) { 
	    return 1;
 	  }
	}
	return 0;
      },
      bombardmentEvent : function(imperium_self, player, bombarding_player, sector, planet_idx) {

	if (imperium_self.game.player != bombarding_player) { return 0; }

        let sys = imperium_self.returnSectorAndPlanets(sector);
        let planet = sys.p[planet_idx];
	let html = '';

        html = '<p>Do you wish to use Bacterial Weapons during Bombardment?</p><ul>';
        html += '<li class="option textchoice" id="attack">use bacterial weapons?</li>';
        html += '<li class="option textchoice" id="skip">skip</li>';
        html += '</ul>';

	imperium_self.updateStatus(html);

        $('.textchoice').off();
        $('.textchoice').on('click', function() {

          let action2 = $(this).attr("id");

	  if (action2 == "attack") {

	    // destroy 100 == destroy them all :)
	    imperium_self.addMove("destroy_infantry_on_planet\t"+player+"\t"+sector+"\t"+planet_idx+"\t"+"100");
            imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"x89_bacterial_weapon_exhausted"+"\t"+"int"+"\t"+"1");
	    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " uses Bacterial Weapons");
	    imperium_self.endTurn();
	  }
	  if (action2 == "skip") {
	    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " refrains from using Bacterial Weapons");
	    imperium_self.endTurn();
	  }
        });
	return 0;
      },
    });



    this.importTech("plasma-scoring", {
      name        	:       "Plasma Scoring" ,
      color       	:       "red" ,
      prereqs             :       [],
      text		:	"All PDS and bombardment fire gets +1 bonus shot" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].plasma_scoring == undefined) {
          imperium_self.game.players_info[player-1].plasma_scoring = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "graviton-laser-system") {
          imperium_self.game.players_info[gainer-1].plasma_scoring = 1;
	  imperium_self.game.players_info[gainer-1].pds_combat_roll_bonus_shots++;
        }
      },
      pdsSpaceDefenseTriggers : function(imperium_self, attacker, player, sector) {
	if (imperium_self.doesPlayerHaveTech(player, "plasma-scoring")) {
 	  if (imperium_self.doesPlayerHavePDSUnitsWithinRange(attacker, player, sector) == 1 && attacker != player) {
	    imperium_self.updateLog(imperium_self.returnFaction(player) + " gets +1 shot from Plasma Scoring");
	  }
	}
	//
	// we don't need the event, just the notification on trigger
	//
	return 0;
      },
    });




    this.importTech("magen-defense-grid", {
      name                :       "Magen Defense Grid" ,
      color               :       "red" ,
      text		:	"When ground combat begins on a planet with PDS or Space Dock, destroy one opponent infantry" ,
      prereqs             :       ["red"],

      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].magen_defense_grid == undefined) {
          imperium_self.game.players_info[player-1].magen_defense_grid = 0;
        }
      },
      onNewRound : function(imperium_self, player) {
        if (player == imperium_self.game.player) {
          imperium_self.game.players_info[player-1].magen_defense_grid = 1;
        }
        return 1;
      },
      groundCombatTriggers : function(imperium_self, player, sector, planet_idx) { 
	if (imperium_self.doesPlayerHaveTech(player, "magen-defense-grid")) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  let planet = sys.p[planet_idx];

          if (player == planet.owner) {
	    let non_infantry_units_on_planet = 0;
	    for (let i = 0; i < planet.units[player-1].length; i++) {
	      if (planet.units[player-1][i].type == "spacedock" || planet.units[player-1][i].type == "pds") {
		imperium_self.updateLog("Magan Defense Grid triggers on " + planet.name);
	        return 1;
	      }
	    }
	  }
	}
        return 0;
      },
      groundCombatEvent : function(imperium_self, player, sector, planet_idx) {

	let sys = imperium_self.returnSectorAndPlanets(sector);
	let planet = sys.p[planet_idx];

	for (let i = 0; i < planet.units.length; i++) {
	  if (planet.units[i] != (player-1)) {
	    for (let ii = 0; i < planet.units[i].length; ii++) {

	      let attacker_unit = planet.units[i][ii];
	      let attacker = (i+1);
	      let defender = player;

	      if (attacker_unit.type == "infantry") {
		imperium_self.assignHitsToGroundForces(attacker, defender, sector, planet_idx, 1);
                imperium_self.eliminateDestroyedUnitsInSector(attacker, sector);
                imperium_self.updateSectorGraphics(sector);
		imperium_self.updateLog(imperium_self.returnFaction(attacker) + " loses 1 infantry to Magan Defense Grid");
		ii = planet.units[i].length+3;
		i = planet.units.length+3;
	      }
	    }
	  }
	}
	return 1;
      }
    });




    this.importTech("duranium-armor", {
      name        	: 	"Duranium Armor" ,
      color       	: 	"red" ,
      prereqs     	:       ['red','red'],
      text		:	"Each round, you may repair any ship which has not taken damage this round" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].duranium_armor == undefined) {
          imperium_self.game.players_info[player-1].duranium_armor = 0;
          imperium_self.game.players_info[player-1].duranium_armor = 0;
        }
      },
      onNewRound : function(imperium_self, player, mycallback) {
        if (player == imperium_self.game.player) {
          imperium_self.game.players_info[player-1].duranium_armor = 1;
          imperium_self.game.players_info[player-1].may_repair_damaged_ships_after_space_combat = 1;
        }
        return 1;
      },
      spaceCombatRoundOver : function(imperium_self, attacker, defender, sector) {

	let sys = imperium_self.returnSectorAndPlanets(sector);

	if (imperium_self.doesPlayerHaveTech(attacker, "duranium-armor")) {
	  for (let i = 0; i < sys.s.units[attacker-1].length; i++) {
	    let this_unit = sys.s.units[attacker-1][i];
	    if (this_unit.last_round_damaged < imperium_self.game.state.space_combat_round) {
	      this_unit.strength = this_unit.max_strength;
	      imperium_self.updateLog(imperium_self.returnFaction(attacker) + " repairs ships with Duranium Armor");
	    }
	  }
        }

	if (imperium_self.doesPlayerHaveTech(defender, "duranium-armor")) {
	  for (let i = 0; i < sys.s.units[defender-1].length; i++) {
	    let this_unit = sys.s.units[defender-1][i];
	    if (this_unit.last_round_damaged < imperium_self.game.state.space_combat_round) {
	      this_unit.strength = this_unit.max_strength;
	      imperium_self.updateLog(imperium_self.returnFaction(defender) + " repairs ships with Duranium Armor");
	    }
	  }
        }

      },
    });




    this.importTech("assault-cannon", {
      name        	:       "Assault Cannon" ,
      color       	:       "red" ,
      prereqs     	:       ['red','red','red'],
      text		:	"If you have three or more capital ships in a sector, destroy one opponent capital ship" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].assault_cannont == undefined) {
          imperium_self.game.players_info[player-1].assault_cannont = 0;
        }
      },
      onNewRound : function(imperium_self, player, mycallback) {
        if (player == imperium_self.game.player) {
          imperium_self.game.players_info[player-1].assault_cannont = 1;
          imperium_self.game.players_info[player-1].may_assign_first_round_combat_shot = 1;
        }
        return 1;
      },
      spaceCombatTriggers :function(imperium_self, player, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);

	for (let i = 0; i < sys.s.units.length; i++) {
	  if ((i+1) != player) {
	    if (imperium_self.doesPlayerHaveTech((i+1), "assault-cannon")) {
	      let capital_ships = 0;
	      for (let ii = 0; ii < sys.s.units[i].length; ii++) {
		let thisunit = sys.s.units[i][ii];
		if (thisunit.type == "destroyer") { capital_ships++; }
		if (thisunit.type == "carrier") { capital_ships++; }
		if (thisunit.type == "cruiser") { capital_ships++; }
		if (thisunit.type == "dreadnaught") { capital_ships++; }
		if (thisunit.type == "flagship") { capital_ships++; }
		if (thisunit.type == "warsun") { capital_ships++; }
	      }
	      if (capital_ships >= 3) {

		//
		// if I have an eligible ship
		//
	        for (let z = 0; z < sys.s.units[player-1].length; z++) {
		  let thisunit = sys.s.units[player-1][z];
		  if (thisunit.type == "destroyer") { return 1; }
		  if (thisunit.type == "carrier") { return 1; }
		  if (thisunit.type == "cruiser") { return 1; }
		  if (thisunit.type == "dreadnaught") { return 1; }
		  if (thisunit.type == "flagship") { return 1; }
		  if (thisunit.type == "warsun") { return 1; }
	        }
	        return 1;
	      }
	    }
	  }
	}

      },
      spaceCombatEvent : function(imperium_self, player, sector) {
	imperium_self.game.players_info[player-1].target_units = ['carrier','destroyer','cruiser','dreadnaught','flagship','warsun'];
	imperium_self.game.queue.push("destroy_ships\t"+player+"\t"+"1"+"\t"+imperium_self.game.state.activated_sector);
	return 1;
      },
    });





    this.importTech("spacedock-ii", {
      name        :       "SpaceDock II" ,
      unit        :       1 ,
      prereqs     :       ["yellow","yellow"],
      text        :       "May produce 4 more units than its planet resource value" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].spacedock_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].spacedock_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "spacedock-ii") {
          imperium_self.game.players_info[gainer-1].spacedock_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type === "spacedock" && imperium_self.doesPlayerHaveTech(player, "spacedock-ii")) {
          return imperium_self.returnUnit("spacedock-ii", player, 0);
        }
        return unit;
      },

    });



    this.importTech("pds-ii", {
      name        :       "PDS II" ,
      unit        :       1 ,
      prereqs     :       ["red","yellow"],
      text        :       "Hits on 5, able to fire into adjacent sectors" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].pds_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].pds_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "pds-ii") {
          imperium_self.game.players_info[gainer-1].pds_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type === "pds" && imperium_self.doesPlayerHaveTech(player, "pds-ii")) {
          return imperium_self.returnUnit("pds-ii", player, 0);
        }
        return unit;
      },

    });


    this.importTech("carrier-ii", {
      name        :       "Carrier II" ,
      unit        :       1 ,
      prereqs     :       ["blue","blue"],
      text        :       "Moves 2 hexes and carries 6 infantry or fighters" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].carrier_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].carrier_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "carrier-ii") {
          imperium_self.game.players_info[gainer-1].carrier_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type === "carrier" && imperium_self.doesPlayerHaveTech(player, "carrier-ii")) {
console.log("returning upgraded carrier...");
          return imperium_self.returnUnit("carrier-ii", player, 0);
        }
        return unit;
      },

    });


    this.importTech("infantry-ii", {
      name        :       "Infantry II" ,
      unit        :       1 ,
      prereqs     :       ["green","green"],
      text        :       "Chance of medical rescue and return to homeworld after unit is destroyed",
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].infantry_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].infantry_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "infantry-ii") {
          imperium_self.game.players_info[gainer-1].infantry_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "infantry" && imperium_self.doesPlayerHaveTech(player, "infantry-ii")) {
          return imperium_self.returnUnit("infantry-ii", player, 0);
        }
        return unit;
      },

    });

    this.importTech("destroyer-ii", {
      name        :       "Destroyer II" ,
      unit        :       1 ,
      prereqs     :       ["red","red"],
      text	  : 	 "Hits on 8 and has stronger anti-fighter barrage (6x3)" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].destroyer_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].destroyer_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "destroyer-ii") {
          imperium_self.game.players_info[gainer-1].destroyer_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "destroyer" && imperium_self.doesPlayerHaveTech(player, "destroyer-ii")) {
          return imperium_self.returnUnit("destroyer-ii", player, 0);
        }
        return unit;
      },

    });

    this.importTech("fighter-ii", {
      name        :       "Fighter II" ,
      unit        :       1 ,
      prereqs     :       ["green","blue"],
      text	  : 	 "Hits on 8 and moves 2 hexes. May survive without carriers or support",
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].fighter_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].fighter_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "fighter-ii") {
          imperium_self.game.players_info[gainer-1].fighter_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "fighter" && imperium_self.doesPlayerHaveTech(player, "fighter-ii")) {
          return imperium_self.returnUnit("fighter-ii", player, 0);
        }
        return unit;
      },

    });

    this.importTech("cruiser-ii", {
      name        :       "Cruiser II" ,
      unit        :       1 ,
      prereqs     :       ["green","yellow","red"],
      text	  : 	 "Hits on 6, moves 3 sectors and can carry 1 fighter or infantry" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].cruiser_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].cruiser_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "cruiser-ii") {
          imperium_self.game.players_info[gainer-1].cruiser_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "cruiser" && imperium_self.doesPlayerHaveTech(player, "cruiser-ii")) {
          return imperium_self.returnUnit("cruiser-ii", player, 0);
        }
        return unit;
      },

    });

    this.importTech("dreadnaught-ii", {
      name        :       "Dreadnaught II" ,
      unit        :       1 ,
      prereqs     :       ["blue","blue","yellow"],
      text	  : 	 "Hits on 5, moves 2 sectors and can carry 1 unit. 2 hits to destroy" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].dreadnaught_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].dreadnaught_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "dreadnaught-ii") {
          imperium_self.game.players_info[gainer-1].dreadnaught_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "dreadnaught" && imperium_self.doesPlayerHaveTech(player, "dreadnaught-ii")) {
          return imperium_self.returnUnit("dreadnaught-ii", player, 0);
        }
        return unit;
      },

    });



    this.importTech("warsun", {
      name        :       "Warsun" ,
      unit        :       1 ,
      prereqs     :       ["red","red","red","yellow"],
      text	  : 	 "The Death Star: terrifying in combat, but fragile without supporting fleet" ,
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].may_produce_warsuns == undefined) {
          imperium_self.game.players_info[player-1].may_produce_warsuns = 0;
        }
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        if (tech == "warsun") {
          imperium_self.game.players_info[gainer-1].may_produce_warsuns = 1;
        }
      },
    });



    this.importTech("sarween-tools", {
      name        	: 	"Sarween Tools" ,
      color       	: 	"yellow" ,
      text		:	"Reduce cost of units produced by -1 when using production",
      prereqs     	:       [],
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].sarween_tools == undefined) {
          imperium_self.game.players_info[player-1].sarween_tools = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "sarween-tools") {
          imperium_self.game.players_info[gainer-1].sarween_tools = 1;
          imperium_self.game.players_info[gainer-1].production_bonus = 1;
        }
      },
    });




    this.importTech("graviton-laser-system", {
      name        	:       "Graviton Laser System" ,
      color       	:       "yellow" ,
      text		:	"Exhaust card once per round to target capital ships with PDS fire" ,
      prereqs             :       ["yellow"],
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].graviton_laser_system == undefined) {
          imperium_self.game.players_info[player-1].graviton_laser_system = 0;
          imperium_self.game.players_info[player-1].graviton_laser_system_exhausted = 0;
          imperium_self.game.players_info[player-1].graviton_laser_system_active = 0;
        }
      },
      onNewRound : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].graviton_laser_system == 1) {
          imperium_self.game.players_info[player-1].graviton_laser_system_exhausted = 0;
          imperium_self.game.players_info[player-1].graviton_laser_system_active = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "graviton-laser-system") {
          imperium_self.game.players_info[gainer-1].graviton_laser_system = 1;
          imperium_self.game.players_info[gainer-1].graviton_laser_system_exhausted = 0;
        }
      },
      modifyTargets(imperium_self, attacker, defender, player, combat_type="", targets=[]) {
        if (combat_type == "pds") {
	  //
	  // defenders in PDS are the ones with this enabled
	  //
          if (imperium_self.game.players_info[defender-1].graviton_laser_system_active == 1) {
	    if (!targets.includes("warsun")) { targets.push("warsun"); }
	    if (!targets.includes("flagship")) { targets.push("flagship"); }
	    if (!targets.includes("dreadnaught")) { targets.push("dreadnaught"); }
	    if (!targets.includes("cruiser")) { targets.push("cruiser"); }
	    if (!targets.includes("carrier")) { targets.push("carrier"); }
	    if (!targets.includes("destroyer")) { targets.push("destroyer"); }
          }
        }
	return targets;
      },
      menuOption  :       function(imperium_self, menu, player) {
	if (menu == "pds") {
          return { event : 'graviton', html : '<li class="option" id="graviton">use graviton laser targetting</li>' };
        }
        return {};
      },
      menuOptionTriggers:  function(imperium_self, menu, player) { 
	if (menu == "pds" && imperium_self.game.players_info[player-1].graviton_laser_system_exhausted == 0 && imperium_self.game.players_info[player-1].graviton_laser_system == 1) {
	  return 1;
	}
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {
        if (menu == "pds") {
	  imperium_self.updateLog(imperium_self.returnFaction(player) + " exhausts Graviton Laser System");
          imperium_self.game.players_info[player-1].graviton_laser_system_exhausted = 1;
          imperium_self.game.players_info[player-1].graviton_laser_system_active = 1;
          imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"graviton_laser_system_exhausted"+"\t"+"int"+"\t"+"1");
          imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"graviton_laser_system_active"+"\t"+"int"+"\t"+"1");
          imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(player)+" activates Graviton Laser System");
	}
	return 0;
      }
    });






    this.importTech("transit-diodes", {
      name                :       "Transit Diodes" ,
      color               :       "yellow" ,
      prereqs             :       ["yellow", "yellow"],
      text		:	"Exhaust to reallocate 4 infantry between planets your control" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].transit_diodes == undefined) {
          imperium_self.game.players_info[player-1].transit_diodes = 0;
          imperium_self.game.players_info[player-1].transit_diodes_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "transit-diodes") {
          imperium_self.game.players_info[gainer-1].transit_diodes = 1;
          imperium_self.game.players_info[gainer-1].transit_diodes_exhausted = 0;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
	if (menu == "main") {
          return { event : 'transitdiodes', html : '<li class="option" id="transitdiodes">use transit diodes</li>' };
        }
        return {};
      },
      menuOptionTriggers:  function(imperium_self, menu, player) { 
	if (menu == "main" && imperium_self.doesPlayerHaveTech(player, "transit-diodes")) {
	  return 1;
	}
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {
        if (menu == "main") {
	  imperium_self.playerRemoveInfantryFromPlanets(player, 4, function(num_to_add) {
	    imperium_self.playerAddInfantryToPlanets(player, num_to_add, function() {
              imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"transit_diodes_exhausted"+"\t"+"int"+"\t"+"1");
              imperium_self.addMove("NOTIFY\t"+player+" activates transit diodes");
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(player) + " has moved infantry");
	      imperium_self.endTurn();
	    });	    
	  });
	}
	return 0;
      }
    });




    this.importTech("integrated-economy", {
      name        	:       "Integrated Economy" ,
      color       	:       "yellow" ,
      prereqs     	:       ['yellow','yellow','yellow'],
      text		:	"You may produce on a planet after capturing it, up to cost (resource) limit of planet." ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].integrated_economy == undefined) {
          imperium_self.game.players_info[player-1].integrated_economy = 0;
          imperium_self.game.players_info[player-1].integrated_economy_planet_invaded = 0;
          imperium_self.game.players_info[player-1].integrated_economy_planet_invaded_resources = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "integrated-economy") {
          imperium_self.game.players_info[gainer-1].integrated_economy = 1;
          imperium_self.game.players_info[gainer-1].integrated_economy_planet_invaded = 0;
          imperium_self.game.players_info[gainer-1].integrated_economy_planet_invaded_resources = 0;
        }
      },
      gainPlanet : function(imperium_self, gainer, planet) {
        if (imperium_self.doesPlayerHaveTech(gainer, "integrated-economy")) {
          imperium_self.game.players_info[gainer-1].may_player_produce_without_spacedock = 1;
          imperium_self.game.players_info[gainer-1].may_player_produce_without_spacedock_production_limit = 0;
console.log("P: " + planet);
          imperium_self.game.players_info[gainer-1].may_player_produce_without_spacedock_cost_limit += imperium_self.game.planets[planet].resources;
        }
      },
    });




    this.importUnit("infantry", {
      name     		:       "Infantry",
      type     		:       "infantry",
      cost 		:	0.5,
      combat 		:	8,
      strength 		:	1,
      space		:	0,
      ground		:	1,
      can_be_stored	:	1,
      capacity_required :	1,
      description	:	"Infantry invade planets, but cannot move between sectors without being carried on carriers or other ships with capacity.",
    });

    this.importUnit("fighter", {
      name     		:       "Fighter",
      type     		:       "fighter",
      cost 		:	0.5,
      move 		:	1,
      combat 		:	9,
      strength 		:	1,
      can_be_stored	:	1,
      capacity_required :	1,
      description	:	"Fighters are disposable ships deployed to protect capital ships. They must be transported on carriers or other ships with capacity.",
    });


    this.importUnit("pds", {
      name     		:       "PDS",
      type     		:       "pds",
      range 		:	0,
      cost 		:	5,
      combat 		:	6,
      description	:	"PDS units fire on other ships that invade their sectors. They can also fire on foreign infantry that invade a planet.",
    });

    this.importUnit("spacedock", {
      name     		:       "Spacedock",
      type     		:       "spacedock",
      capacity 		:	3,
      production 	:	4,
      combat      	: 	0,
      range       	: 	0,
      description	:	"Spacedocks are used to produce infantry and other ships. They cannot produce ships in space if an opponent fighter is in the sector",
    });

    this.importUnit("carrier", {
      name     		:       "Carrier",
      type     		:       "carrier",
      cost 		:	3,
      move 		:	1,
      combat 		:	9,
      capacity 		:	4,
      strength 		:	1,
      description	:	"The Carrier is a troop and fighter transport ship. Load it with infantry and fighters and use it to conquer other sectors.",
    });

    this.importUnit("destroyer", {
      name     		:       "Destroyer",
      type     		:       "destroyer",
      cost 		:	1,
      move 		:	2,
      combat 		:	9,
      strength 		:	1,
      anti_fighter_barrage :	2,
      anti_fighter_barrage_combat :	9,
      description	:	"The Destroyer is an inexpensive but mobile ship designed to counter fighter swarms - its ANTI-FIGHTER BARRAGE (2 rolls hitting on 9 or higher) happens at the very start of space-combat",
    });

    this.importUnit("cruiser", {
      name     		:       "Cruiser",
      type     		:       "cruiser",
      cost 		:	2,
      move 		:	2,
      combat 		:	7,
      strength 		:	1,
      description	:	"The Cruiser is a more powerful ship with a reasonable chance of landing hits in battle.",
    });

    this.importUnit("dreadnaught", {
      name     		:       "Dreadnaught",
      type     		:       "dreadnaught",
      cost 		:	4,
      move 		:	1,
      capacity 		:	1,
      combat 		:	6,
      strength 		:	2,
      bombardment_rolls	:	1,
      bombardment_combat:	5,
      description	:	"The Dreadnaught is a powerful combat ship able to SUSTAIN DAMAGE once before being destroyed in combat",
    });

    this.importUnit("flagship", {
      name     		:       "Flagship",
      type     		:       "flagship",
      cost 		:	8,
      move 		:	1,
      capacity 		:	1,
      combat 		:	7,
      strength 		:	2,
      description	:	"The Flagship is the pride of the fleet -- each faction's flagship confers specific abilities. See your factino sheet for more details",
    });

    this.importUnit("warsun", {
      name     		:       "War Sun",
      type     		:       "warsun",
      cost 		:	12,
      move 		:	1,
      capacity 		:	6,
      combat 		:	3,
      strength 		:	2,
      bombardment_rolls	:	3,
      bombardment_combat:	3,
      description	:	"The War Sun is death packaged in a mass of planet-destroying turbinium. Rumours of their lethality abound, as few have fought one and lived to tell the tale." ,
    });

  
    this.importUnit("infantry-ii", {
      name     		:       "Infantry II",
      type     		:       "infantry",
      cost 		:	0.5,
      combat 		:	7,
      strength 		:	1,
      space		:	0,
      ground		:	1,
      can_be_stored	:	1,
      capacity_required :	1,
      extension 	: 	1,
      description	:	"Infantry II are stronger and more resilient but cannot typically be moved between sectors without moving on carriers or other ships with capacity.",
    });

    this.importUnit("fighter-ii", {
      name     		:       "Fighter II",
      type     		:       "fighter",
      cost 		:	0.5,
      move 		:	2,
      combat 		:	8,
      strength 		:	1,
      can_be_stored	:	1,
      capacity_required :	1,
      extension 	: 	1,
      description	:	"Fighter II can move without being transported by other ships. Any ships inexcess of your carrying capacity could against your fleet supply.",
      
    });

    this.importUnit("spacedock-ii", {
      name     		:       "Spacedock II",
      type     		:       "spacedock",
      capacity 		:	3,
      production 	:	4,
      extension 	: 	1,
      description	:	"Spacedock II can produce more units whenever they produce.",
    });

    this.importUnit("pds-ii", {
      name     		:       "PDS II",
      type     		:       "pds",
      cost 		:	5,
      combat 		:	5,
      range		:	1,
      extension 	: 	1,
      description	:	"PDS II has a slightly more accurate targeting mechanism and can fire into adjacent sectors.",
    });

    this.importUnit("carrier-ii", {
      name     		:       "Carrier II",
      type     		:       "carrier",
      cost 		:	3,
      move 		:	2,
      combat 		:	9,
      capacity 		:	6,
      strength 		:	1,
      extension 	: 	1,
      description	:	"Carrier II has upgraded ship capacity and is slightly more robust in combat",
    });

    this.importUnit("destroyer-ii", {
      name     		:       "Destroyer II",
      type     		:       "destroyer",
      cost 		:	1,
      move 		:	2,
      combat 		:	8,
      strength 		:	1,
      extension 	: 	1,
      anti_fighter_barrage :	3,
      anti_fighter_barrage_combat :	6,
      description	:	"Destroyer II has improved ANTI-FIGHTER-BARRAGE (3x6) and is slightly more effective in general combat",
    });

    this.importUnit("cruiser-ii", {
      name     		:       "Cruiser II",
      type     		:       "cruiser",
      cost 		:	2,
      move 		:	2,
      combat 		:	7,
      strength 		:	1,
      extension 	: 	1,
      description	:	"Cruiser II has extended range and the ability to support a small phalanx of ground troops",
    });

    this.importUnit("dreadnaught-ii", {
      name     		:       "Dreadnaught II",
      type     		:       "dreadnaught",
      cost 		:	4,
      move 		:	2,
      capacity 		:	1,
      combat 		:	5,
      strength 		:	2,
      extension 	: 	1,
      description	:	"Dreadnaught II has improved movement, can support a small ground team and is slightly more effective in space combat",
    });




 

    this.importPromissary("ceasefire", {
      name        :       "Ceasefire Promissary" ,
      faction	  :	  -1,
      text	  :	  "When the owner activates a sector that contains one of your units, you may trigger this to prevent them moving in units." ,
      //
      // we use 
      //
      activateSystemTriggers	:	function(imperium_self, attacker, player, sector) {
	let promissary_name = imperium_self.game.players_info[attacker-1].faction + "-" + "ceasefire";
	if (imperium_self.doesPlayerHavePromissary(player, promissary_name)) { 
	  if (attacker != player) {
	    if (imperium_self.doesPlayerHaveUnitsInSector(player, sector)) {
	      return 1; 
	    }
	  }
	}
	return 0;
      },
      activateSystemEvent	:	function(imperium_self, attacker, player, sector) {

	if (imperium_self.game.player != player) {
	  imperium_self.updateStatus(imperium_self.returnFaction(player) + " is deciding whether to use Ceasefire");
	  return 0; 
	}

        let html = '<div clss="sf-readable">Permit '+imperium_self.returnFaction(attacker) + ' to activate sector or use ceasefire? </div><ul>';
        html += '<li class="option" id="activate">use ceasefire</li>';
        html += '<li class="option" id="nothing">do nothing</li>';
        html += '</ul>';

        imperium_self.updateStatus(html);

        $('.option').off();
        $('.option').on('click', function () {

          let opt = $(this).attr("id");

	  if (opt === "nothing") {
	    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " does not use Ceasefire");
	    imperium_self.endTurn();
	    return 0;
	  }

	  if (opt === "activate") {
	    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " uses Ceasefire to end " + imperium_self.returnFaction(attacker) + " turn");
	    imperium_self.addMove("ceasefire\t"+attacker+"\t"+player);
            imperium_self.endTurn();
            return 0;
	  }

          return 0;
        });
      },
      handleGameLoop : function(imperium_self, qe, mv) {

        if (mv[0] == "ceasefire") {

          let attacker = parseInt(mv[1]);
          let sector = mv[2];
          imperium_self.game.queue.splice(qe, 1);

	  let terminated_play = 0;
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("play") != 0 && terminated_play == 0) {
	      imperium_self.game.queue.splice(i, 1);
	    } else {
	      if (terminated_play == 0) {
	        terminated_play = 1;
        	imperium_self.game.queue.push("resolve\tplay");
        	imperium_self.game.queue.push("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        	imperium_self.game.queue.push("player_end_turn\t" + attacker);
	      }
	    }
	  }

          return 1;
        }
        return 1;
      }
    });



    this.importPromissary("trade", {
      name        :       "Trade Promissary" ,
      faction	  :	  -1,
      text	  :	  "When the owner replenishes commodities, this promissary triggers and you gain their commodities as trade goods" ,
      gainCommodities	:	function(imperium_self, player, amount) {
	let promissary_name = imperium_self.game.players_info[player-1].faction + "-" + "trade";
	let pprom = imperium_self.returnPromissaryPlayer(promissary_name);
	for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	  if ((i+1) != player) {
	    if (imperium_self.doesPlayerHavePromissary((i+1), promissary_name)) {
	      imperium_self.game.players_info[i].goods += amount;
	      imperium_self.givePromissary(player, (i+1), promissary_name);
	      imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " redeems their Trade Promissary from " + imperium_self.returnFaction(pprom));
	      return 0;
	    }
	  }
	}
	return amount;
      },
    });



    this.importPromissary("political", {
      name        :       "Political Promissary" ,
      faction	  :	  -1,
      text	  :	  "The owner of this card cannot participate in resolving this agenda" ,
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
        if (menu == "pre_agenda") {
          x.event = 'political-promissary';
          x.html = '<li class="option" id="political-promissary">Political Promissary</li>';
        }
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
	if (menu != "pre_agenda") { return 0; }
        let playable_promissaries = imperium_self.returnPlayablePromissaryArray(player, "political");
        for (let i = 0; i < playable_promissaries.length; i++) {
	  if (imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes.includes(playable_promissaries[i])) { return 1; }
	}
        return 0;
      },
      //
      // choose faction politicla promissary, and add a useless rider
      //
      menuOptionActivated:  function(imperium_self, menu, player) {
        if (imperium_self.game.player == player) {

          let html = '<div class="sf-readable">Select a Specific Promissary: </div><ul>';
          let playable_promissaries = imperium_self.returnPlayablePromissaryArray(player, "political");
	  for (let i = 0; i < playable_promissaries.length; i++) {
	    let tmpar = playable_promissaries[i].split("-");
	    let pprom = imperium_self.returnPromissaryPlayer(playable_promissaries[i]);
            html += `<li class="option" id="${i}">${imperium_self.returnFactionName(pprom)} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
          html += '</ul>';

          imperium_self.updateStatus(html);

          $('.option').off();
          $('.option').on('click', function() {

            let i = $(this).attr("id");
	    let prom = playable_promissaries[parseInt(i)]
	    let pprom = imperium_self.returnPromissaryPlayer(playable_promissaries[parseInt(i)]);

	    imperium_self.addMove("rider\t"+pprom+"\tpolitical-promissary\t-1");
	    imperium_self.addMove("give\t"+imperium_self.game.player+"\t"+prom+"\t"+"promissary"+"\t"+prom);
	    imperium_self.endTurn();

            return 0;
          });
	}
	return 0;
      }
    });

    this.importPromissary("throne", {
      name        :       "Support for the Throne" ,
      faction	  :	  -1,
      text	  :	  "Gain 1 VP when you receive this card. Lose this card and 1 VP if the owner of this card is eliminated or you activate a system containing any of their units." ,
      gainPromissary	:    function(imperium_self, gainer, promissary) {
	if (promissary.indexOf("throne") > -1) {
	  let pprom = imperium_self.returnPromissaryPlayer(promissary);
	  if (pprom != gainer) {
	    imperium_self.game.players_info[gainer-1][promissary] = 1;
	    imperium_self.game.players_info[gainer-1].vp++;
	    imperium_self.updateLog(imperium_self.returnFaction(gainer) + " gains 1 VP from Support for the Throne");
	    imperium_self.updateLeaderboard();
	  }
	}
      },
      losePromissary	:    function(imperium_self, loser, promissary) {
	if (promissary.indexOf("throne") > -1) {
	  let pprom = imperium_self.returnPromissaryPlayer(promissary);
	  if (pprom != loser) {
	    imperium_self.game.players_info[loser-1][promissary] = 1;
	    imperium_self.game.players_info[loser-1].vp--;
	    imperium_self.updateLog(imperium_self.returnFaction(loser) + " loses 1 VP from Support for the Throne");
	    imperium_self.updateLeaderboard();
	  }
	}
      },
      // run code on trigger, no need for event separately since asynchronous
      activateSystemTriggers : function(imperium_self, activating_player, player, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);
	for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	  if ((i+1) != activating_player) {
	    if (imperium_self.doesPlayerHaveUnitsInSector((i+1), sector)) {
	      let faction_promissary = imperium_self.game.players_info[player-1].id + "-" + "throne";
	      if (imperium_self.doesPlayerHavePromissary(activating_player, faction_promissary)) {
	        imperium_self.game.players_info[activating_player-1][faction_promissary] = 0;
	        imperium_self.updateLog(imperium_self.returnFaction(activating_player) + " loses 1 VP from Support for the Throne");
	        imperium_self.game.players_info[activating_player-1].vp--;
	     	imperium_self.givePromissary(activating_player, (i+1), details);
	      }
	    }
	  }
	}
	return 0;
      }
    });



    this.importFaction('faction2', {
      id		:	"faction2" ,
      name		: 	"Universities of Jol Nar",
      nickname		: 	"Jol Nar",
      homeworld		: 	"sector50",
      space_units	: 	["carrier","carrier","dreadnaught","fighter"],
      ground_units	: 	["infantry","infantry","pds","spacedock"],
      tech		: 	["sarween-tools", "neural-motivator", "plasma-scoring", "antimass-deflectors", "faction2-analytic", "faction2-brilliant", "faction2-fragile", "faction2-flagship"],
      background	: 	'faction2.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro		:	`<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Universities of Jol Nar, a physically weak faction which excells at science and technology. Survive long enough to amass enough protective technology and you can be a contender for the Imperial Throne. Good luck!</div>`
    });


    this.importTech("faction2-flagship", {
      name        	:       "XXCha Flagship" ,
      faction     	:       "faction2",
      type      	:       "ability" ,
      text		:	"Extra hit on every roll of 9 or 10 before modifications" ,
      modifyUnitHits 	: function(imperium_self, player, defender, attacker, combat_type, rerolling_unit, roll, total_hits) {
        if (!imperium_self.doesPlayerHaveTech(attacker, "faction2-flagship")) { return total_hits; }
	if (rerolling_unit.owner == attacker) {
	  if (rerolling_unit.type == "flagship") {
	    if (roll > 8) { 
	      imperium_self.updateLog("Jol Nar flagship scores an additional hit through flagshup ability");
	      total_hits++; 
	      return total_hits;
	    }
	  }
	}
	return total_hits;
      } ,
    });




    this.importTech('faction2-analytic', {

      name        :       "Analytic" ,
      faction     :       "faction2",
      type        :       "ability" ,
      text	  :	"Ignore 1 tech prerequisite on non-unit upgrades",
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction2-analytic")) {
          imperium_self.game.players_info[player-1].permanent_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 1;
        }
      },

    });


    this.importTech('faction2-fragile', {

      name        :       "Fragile" ,
      faction     :       "faction2",
      type        :       "ability" ,
      text	  :	  "-1 on all combat rolls" ,
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction2-fragile")) {
          imperium_self.game.players_info[player-1].permanent_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 1;
        }
      },
      modifyCombatRoll :	  function(imperium_self, attacker, defender, player, combat_type, roll) {
	if (combat_type == "space" || combat_type == "ground") {
          if (imperium_self.doesPlayerHaveTech(attacker, "faction2-fragile")) {
  	    imperium_self.updateLog("Jol Nar combat rolls -1 due to fragility");
	    roll -= 1;
	    if (roll < 1) { roll = 1; }
	  }
        }

	return roll;
      },
    });
    this.importTech('faction2-brilliant', {
      name        :       "Brilliant" ,
      faction     :       "faction2",
      type        :       "ability" ,
      text	  :	  "Tech primary is played when token spent to execute secondary" ,
      initialize     :    function(imperium_self, player) {
	if (imperium_self.faction2_brilliant_swapped == undefined) {
	  imperium_self.faction2_brilliant_swapped = 1;

	  imperium_self.brilliant_original_event = imperium_self.strategy_cards['technology'].strategySecondaryEvent;
	  imperium_self.strategy_cards["technology"].strategySecondaryEvent = function(imperium_self, player, strategy_card_player) {

	    if (imperium_self.doesPlayerHaveTech(player, "faction2-brilliant") && player != strategy_card_player && imperium_self.game.player == player) {

	      imperium_self.game.players_info[player-1].cost_of_technology_secondary = 6;

              imperium_self.playerAcknowledgeNotice("The Tech strategy card has been played. You may expend a strategy token to research a technology. You can then purchase a second for 6 resources:", function() {

                let html = '<p>Technology has been played. Do you wish to spend a strategy token to research a technology? </p><ul>';
                    html += '<li class="option" id="yes">Yes</li>';
                    html += '<li class="option" id="no">No</li>';
                    html += '</ul>';

                imperium_self.updateStatus(html);
                imperium_self.lockInterface();

                $('.option').off();
                $('.option').on('click', function() {

	          if (!imperium_self.mayUnlockInterface()) {
	            salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
	            return;
	          }
	          imperium_self.unlockInterface();

	          let id = $(this).attr("id");

		  if (id === "no") {
                    imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
                    imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
		    imperium_self.endTurn();
		    return 0;
		  }

                  imperium_self.playerResearchTechnology(function(tech) {

                    imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
                    imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
                    imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);


		    //
		    // avoid double research of same tech by manually inserting
		    //
                    imperium_self.game.players_info[imperium_self.game.player-1].tech.push(tech);


	  	    let resources_to_spend = 6;
                    let html = '<p>Do you wish to spend 6 resources to research a second technology? </p><ul>';

  	            if (
        	      imperium_self.game.players_info[player-1].permanent_research_technology_card_must_not_spend_resources == 1 ||
        	      imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 1
        	    ) {
        	      html = '<p>Do you wish to research a second technology for free?';
        	      resources_to_spend = 0;
        	    }

	            let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
	            if (available_resources >= resources_to_spend) {
	              html += '<li class="option" id="yes">Yes</li>';
	            }
	            html += '<li class="option" id="no">No</li>';
	            html += '</ul>';
 
	            imperium_self.updateStatus(html);
	            imperium_self.lockInterface();

	            $('.option').off();
	            $('.option').on('click', function() {

	              if (!imperium_self.mayUnlockInterface()) {
	                salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
	                return;
	              }
	              imperium_self.unlockInterface();
 
	              let id = $(this).attr("id");

	              if (id === "yes") {
	                imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources = 0;
	                imperium_self.playerSelectResources(resources_to_spend, function(success) {
	                  if (success == 1) {
	                    imperium_self.playerResearchTechnology(function(tech) {
	                      imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);
	                      imperium_self.endTurn();
	                    });
	                  } else {
	                    imperium_self.endTurn();
		    	    return 0;
	                  }
	                });
	              }
	              if (id === "no") {
	                imperium_self.endTurn();
	                return 0;
	              }
	            });
		  });
                });
              });
	    } else {
	      imperium_self.brilliant_original_event(imperium_self, player, strategy_card_player);
	    }
	  }
	}
      }
    });



    this.importTech('faction2-eres-siphons', {
      name        :       "E-Res Siphons" ,
      faction     :       "faction2",
      type        :       "special" ,
      color       	: 	"yellow" ,
      prereqs	:	["yellow","yellow"],
      text	:	"Gain 4 trade goods whenever a system is activated containing your ships" ,
      initialize  :	  function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].eres_siphons == null) {
          imperium_self.game.players_info[player-1].eres_siphons = 0;
	}
      },
      gainTechnology : function(imperium_self, gainer, tech) {
	if (tech == "faction2-eres-siphons") {
          imperium_self.game.players_info[gainer-1].eres_siphons = 1;
        }
      },
      activateSystemTriggers :    function(imperium_self, activating_player, player, sector) {
	if (imperium_self.game.players_info[player-1].eres_siphons == 1 && activating_player != player) {
          if (imperium_self.doesSectorContainPlayerShips(player, sector) == 1) { return 1; }
	}
        return 0;
      },
      postSystemActivation :   function(imperium_self, activating_player, player, sector) {
        imperium_self.game.players_info[player-1].goods += 4;
      }
    });



    this.importTech('faction2-deep-space-conduits', {
      name        :       "Deep Space Conduits" ,
      faction     :       "faction2",
      type        :       "special" ,
      color       	: 	"blue" ,
      prereqs	:	["blue","blue"],
      text	:	"Activate card to make activated system 1 hop away from all other systems with Jol Nar ships" ,
      initialize  :	  function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].deep_space_conduits == null) {
          imperium_self.game.players_info[player-1].deep_space_conduits = 0;
          imperium_self.game.players_info[player-1].deep_space_conduits_exhausted = 0;
	}
      },
      onNewRound : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].deep_space_conduits == 1) {
          imperium_self.game.players_info[player-1].deep_space_conduits_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
	if (tech == "faction2-deep-space-conduits") {
          imperium_self.game.players_info[gainer-1].deep_space_conduits = 1;
          imperium_self.game.players_info[gainer-1].deep_space_conduits_exhausted = 0;
        }
      },
      activateSystemTriggers : function(imperium_self, activating_player, player, sector) { 
	if (player == imperium_self.game.player && activating_player == player) {
	  if (imperium_self.game.players_info[activating_player-1].deep_space_conduits == 1 && imperium_self.game.players_info[activating_player-1].deep_space_conduits_exhausted == 0) {
	    if (imperium_self.doesSectorContainPlayerUnits(activating_player, sector)) {
	      return 1;
	    }
	  }
	}
	return 0;
      },
      activateSystemEvent : function(imperium_self, activating_player, player, sector) { 

	let html = 'Do you wish to activate Deep Space Conduits: <ul>';
	html    += '<li class="textchoice" id="yes">activate</li>';
	html    += '<li class="textchoice" id="no">skip</li>';
	html    += '</ul>';

	imperium_self.updateStatus(html);

	$('.textchoice').off();
	$('.textchoice').on('click', function() {

	  let action = $(this).attr("id");

	  if (action == "yes") {
	    let sectors = imperium_self.returnSectorsWithPlayerUnits(activating_player);
	    imperium_self.game.players_info[activating_player-1].deep_space_conduits_exhausted = 1;
            imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"deep_space_conduits_exhausted"+"\t"+"int"+"\t"+"1");
	    for (let i = 0; i < sectors.length; i++) {
	      imperium_self.addMove("adjacency\ttemporary\t"+sectors[i]+"\t"+sector);
	    }
	    imperium_self.endTurn();
	  }

	  if (action == "no") {
	    imperium_self.updateStatus();
	    imperium_self.endTurn();
	  }

	});
      }
    });





    this.importFaction('faction7', {
      id		:	"faction7" ,
      name		: 	"Embers of Muaat",
      nickname		: 	"Muaat",
      homeworld		: 	"sector76",
      space_units	: 	["warsun","fighter","fighter"],
      ground_units	: 	["infantry","infantry","infantry","infantry","spacedock"],
      tech		: 	["plasma-scoring", "faction7-star-forge", "faction7-gashlai-physiology", "faction7-advanced-warsun-i","faction7-flagship"],
      background	: 	'faction7.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Yssaril Tribe, a primitive race of swamp-dwelling creatures whose fast instincts and almost unerring ability to change tactics on-the-fly lead many to suspect more is at work than their primitive appearance belies. Good luck!</div>`
    });






    this.importTech("faction7-star-forge", {

      name        :       "Star Forge" ,
      faction     :       "faction7",
      type      :         "ability" ,
      text        :       "Spend 1 strategy token to place 2 fighters or a destroy in sector with your warsun" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].star_forge == undefined) {
          imperium_self.game.players_info[player-1].star_forge = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction7-star-forge") {
          imperium_self.game.players_info[gainer-1].star_forge = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
        if (menu === "main") {
          x.event = 'starforge';
          x.html = '<li class="option" id="starforge">star forge</li>';
        }
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction7-star-forge") && menu === "main") {
          return 1;
        }
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

        if (imperium_self.game.player == player) {

	  //
	  // star forge logic
	  //
          imperium_self.playerSelectSectorWithFilter(
            "Star Forge spends 1 strategy token to drop 2 fighters or 1 destroyer in a sector containing your War Sun: " ,
            function(sector) {
	      return imperium_self.doesSectorContainPlayerUnit(imperium_self.game.player, sector, "warsun");
            },
            function(sector) {

              imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdestroyer\t"+sector);
              imperium_self.addMove("NOTIFY\tStar Forge adds destroyer to "+sector);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\t"+"strategy"+"\t"+"1");
              imperium_self.endTurn();
              return 0;

            },
            function() {
              imperium_self.playerTurn();
            }
          );

          return 0;

        };

	return 0;
      }
    });








    this.importTech("faction7-gashlai-physiology", {

      name        :       "Gashlai Physiology" ,
      faction     :       "faction7",
      type        :       "ability" ,
      text        :       "Player may move through supernovas" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].gashlai_physiology == undefined) {
          imperium_self.game.players_info[player-1].gashlai_physiology = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction7-gashlai-physiology") {
          imperium_self.game.players_info[gainer-1].gashlai_physiology = 1;
	  imperium_self.game.players_info[gainer-1].fly_through_supernovas = 1;
        }
      },
    });








    this.importTech("faction7-magmus-reactor", {

      name        :       "Magmus Reactor" ,
      faction     :       "faction7",
      type        :       "special" ,
      text        :       "Player may move into supernovas. Gain 1 trade good producing with Warsun or adjacent to Supernova" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].magmus_reactor == undefined) {
          imperium_self.game.players_info[player-1].magmus_reactor = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction7-magmus-reactor") {
          imperium_self.game.players_info[gainer-1].magmus_reactor = 1;
	  imperium_self.game.players_info[gainer-1].move_into_supernovas = 1;
        }
      },
      postProduction : function(imperium_self, player, sector, stuff) {
	if (imperium_self.game.players_info[player-1].magmus_reactor == 1) {
          let as = imperium_self.returnAdjacentSectors(sector);
	  let give_bonus = 0;
          if (imperium_self.doesSectorContainPlayerUnit(player, sector, "warsun")) { give_bonus = 1; }
	  if (give_bonus == 0) {
            for (let i = 0; i < as.length; i++) {
  	      let sys = imperium_self.returnSectorAndPlanets(as[i]);
	      if (sys.s.type == 4) { give_bonus = 1; }
	    }
	  }
	  if (give_bonus == 1) {
	    imperium_self.updateLog("Muatt gains 1 trade good from Magmus Reactor - producing in a sector with a Warsun or adjacent to a Supernova");
            imperium_self.game.players_info[player-1].goods += 1;
            imperium_self.updateTokenDisplay();
            imperium_self.displayFactionDashboard();
	  }
	}
      }
    });






    this.importTech("faction7-flagship", {
      name        	:       "Muaat Flagship" ,
      faction     	:       "faction7",
      type      	:       "ability" ,
      text        	:       "May spend 1 strategy token to place a cruiser in your flagship system" ,
    });


    this.importTech("faction7-advanced-warsun-i", {

      name        :       "Advanced Warsun I" ,
      faction     :       "faction7",
      replaces    :       "warsun",
      unit        :       1 ,
      type      :         "special",
      text        :       "A more dangerous and mobile warsun" ,
      prereqs     :       [],
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction7_advanced_warsun_i == undefined) {
          imperium_self.game.players_info[player-1].faction7_advanced_warsun_i = 0;
	}
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        imperium_self.game.players_info[gainer-1].faction7_advanced_warsun_i = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {

        if (imperium_self.game.players_info[unit.owner-1].faction7_advanced_warsun_i == 1 && unit.type == "warsun") {
          unit.cost = 12;
          unit.combat = 3;
          unit.move = 1;
          unit.capacity = 6;
	  unit.bombardment_rolls = 3;
	  unit.bombardment_combat = 3;
        }

        return unit;
      },

    });





    this.importTech("faction7-advanced-warsun-ii", {

      name        :       "Advanced Warsun II" ,
      faction     :       "faction7",
      replaces    :       "warsun",
      unit        :       1 ,
      type      :         "special",
      text        :       "A more dangerous and mobile warsun" ,
      prereqs     :       ["red","red","red","yellow"],
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction7_advanced_warsun_ii == undefined) {
          imperium_self.game.players_info[player-1].faction7_advanced_warsun_ii = 0;
	}
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        imperium_self.game.players_info[gainer-1].faction7_advanced_warsun_ii = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {

        if (imperium_self.game.players_info[unit.owner-1].faction7_advanced_warsun_ii == 1 && unit.type == "warsun") {
          unit.cost = 10;
          unit.combat = 3;
          unit.move = 3;
          unit.capacity = 6;
	  unit.bombardment_rolls = 3;
	  unit.bombardment_combat = 3;
        }

        return unit;
      },

    });






    this.importFaction('faction4', {
      id		:	"faction4" ,
      name		: 	"Sardakk N'Orr",
      nickname		: 	"Sardakk",
      homeworld		: 	"sector53",
      space_units	: 	["carrier","carrier","cruiser"],
      ground_units	: 	["infantry","infantry","infantry","infantry","infantry","spacedock"],
      tech		: 	["faction4-unrelenting", "faction4-exotrireme-i", "faction4-flagship"],
      background	: 	'faction4.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Sardaak N'Orr, an overpowered faction known for its raw strength in combat. Your brutal power makes you an intimidating faction on the board. Good luck!</div>`
    });




    this.importTech('faction4-unrelenting', {

      name        :       "Unrelenting" ,
      faction     :       "faction4",
      type        :       "ability" ,
      text	  :	  "+1 on all combat rolls" ,
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction4-unrelenting")) {
          imperium_self.game.players_info[player-1].faction4_unrelenting = 1;
        }
      },
      modifyCombatRoll :	  function(imperium_self, attacker, defender, player, combat_type, roll) {
	if (combat_type == "space" || combat_type == "ground") {
          if (imperium_self.doesPlayerHaveTech(attacker, "faction4-unrelenting")) {
  	    imperium_self.updateLog("Sardakk combat rolls +1 due to Sardakk");
	    roll += 1;
	    if (roll > 10) { roll = 10; }
	  }
        }
	return roll;
      },
    });


    this.importTech("faction4-flagship", {
      name        	:       "Sardakk Flagship" ,
      faction     	:       "faction4",
      type      	:       "ability" ,
      text	  :	  "+1 on all combat rolls for ships in same sector" ,
      modifyCombatRoll :	  function(imperium_self, attacker, defender, player, combat_type, roll) {
	if (combat_type == "space") {
	  let flagship_bonus = 0;
	  if (imperium_self.doesSectorContainPlayerUnit(attacker, imperium_self.game.state.activated_sector, "flagship")) {
	    imperium_self.updateLog("Sardakk Flagship adds +1 to dice roll");
	    roll += 1;
	    if (roll > 10) { roll = 10; }
	  } 
	}
        return roll;
      },
    });




    this.importTech("faction4-exotrireme-i", {

      name        :       "Exotrireme I" ,
      faction     :       "faction4",
      replaces    :       "dreadnaught",
      unit        :       1 ,
      type        :       "special",
      text	  :	  "A more powerful dreadnaught" ,
      prereqs     :       [],
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction4_advanced_dreadnaught_i == undefined) {
          imperium_self.game.players_info[player-1].faction4_advanced_dreadnaught_i = 0;
        }
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        imperium_self.game.players_info[gainer-1].faction4_advanced_dreadnaught_i = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (imperium_self.game.players_info[unit.owner-1].faction4_advanced_dreadnaught_i == 1 && unit.type == "dreadnaught") {
          unit.cost = 4;
          unit.combat = 5;
          unit.move = 1;
          unit.capacity = 1;
	  unit.strength = 2;
	  unit.bombardment_rolls = 2;
	  unit.bombardment_combat = 4;
	  unit.description = "The Exotrireme I is a more powerful dreadnaught not vulnerable to Direct Hit cards";
        }

        return unit;
      },

    });



    this.importTech("faction4-exotrireme-ii", {

      name        :       "Exotrireme II" ,
      faction     :       "faction4",
      replaces    :       "dreadnaught",
      unit        :       1 ,
      type        :       "special",
      prereqs     :       ["blue","blue","yellow"],
      text	  :	  "A much more powerful dreadnaught" ,
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction4_advanced_dreadnaught_ii == undefined) {
          imperium_self.game.players_info[player-1].faction4_advanced_dreadnaught_ii = 0;
        }
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        imperium_self.game.players_info[gainer-1].faction4_advanced_dreadnaught_ii = 1;
        imperium_self.game.players_info[gainer-1].faction4_advanced_dreadnaught_i = 0;
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (imperium_self.game.players_info[unit.owner-1].faction4_advanced_dreadnaught_ii == 1 && unit.type == "dreadnaught") {
          unit.cost = 4;
          unit.combat = 5;
          unit.move = 2;
          unit.capacity = 1;
	  unit.strength = 2;
	  unit.bombardment_rolls = 2;
	  unit.bombardment_combat = 4;
	  unit.description = "The Exotrireme II is a more powerful dreadnaught not vulnerable to Direct Hit cards. It may be destroyed after a round of space combat to destroy up to two opponent ships.";
        }
        return unit;
      },
      spaceCombatRoundEnd :    function(imperium_self, attacker, defender, sector) {
        if (imperium_self.doesPlayerHaveTech(attacker, "faction4-exotrireme-ii")) {
	  if (imperium_self.doesSectorContainPlayerUnit(attacker, sector, "dreadnaught")) {
	    imperium_self.addMove("faction4_exotrireme_ii_sacrifice\t"+attacker+"\t"+sector);
	  }
	}
        if (imperium_self.doesPlayerHaveTech(defender, "faction4-exotrireme-ii")) {
	  if (imperium_self.doesSectorContainPlayerUnit(defender, sector, "dreadnaught")) {
	    imperium_self.addMove("faction4_exotrireme_ii_sacrifice\t"+defender+"\t"+sector);
	  }
	}
	return 1;
      },
      handleGameLoop : function(imperium_self, qe, mv) {

        if (mv[0] == "faction4_exotrireme_ii_sacrifice") {

          let player_to_go = parseInt(mv[1]);
          let sys = imperium_self.returnSectorAndPlanets(mv[2]);
          let opponent = imperium_self.returnOpponentInSector(player_to_go, mv[2]);

	  if (player_to_go == imperium_self.game.player) {

	    if (opponent == -1) {
	      imperium_self.addMove("resolve\tfaction4_exotrireme_ii_sacrifice");

	      imperium_self.addMove("NOTIFY\tNo target ships for Sardakk Exotrireme II faction ability");
	      imperium_self.endTurn();
	      return 0;
	    }

	    let anything_to_kill = 0;
	    for (let i = 0; i < sys.s.units[opponent-1].length; i++) {
	      if (sys.s.units[opponent-1][i].strength > 0) {
	        anything_to_kill = 1;
	      }
	    }

	    if (anything_to_kill == 0) {
	      imperium_self.addMove("resolve\tfaction4_exotrireme_ii_sacrifice");
	      imperium_self.addMove("NOTIFY\tNo target ships for Sardakk Exotrireme II action ability");
	      imperium_self.endTurn();
	      return 0;
	    }

            html = '<div class="sf-readable">Do you wish to sacrifice a Dreadnaught to destroy up to 2 opponent ships?</div><ul>';
	    for (let i = 0; i < sys.s.units[imperium_self.game.player-1].length; i++) {
	      if (sys.s.units[imperium_self.game.player-1][i].type == "dreadnaught") {
                html += `<li class="option" id="${i}">sacrifice ${imperium_self.returnShipInformation(sys.s.units[imperium_self.game.player-1][i])}</li>`;
	      }
	    }
            html += '<li class="option" id="no">do not sacrifice</li>';
            html += '</ul>';

	    imperium_self.updateStatus(html);

            $('.option').on('click', function () {

	      let action2 = $(this).attr("id");

	      if (action2 === "no") {
	        imperium_self.addMove("resolve\tfaction4_exotrireme_ii_sacrifice");
	        imperium_self.endTurn();
	        return 0;
	      }

	      imperium_self.addMove("resolve\tfaction4_exotrireme_ii_sacrifice");
 	      imperium_self.addMove("faction4_exotrireme_ii_picktwo\t"+imperium_self.game.player+"\t"+mv[2]);
 	      imperium_self.addMove("NOTIFY\tSardakk sacrifies Exotritreme II to destroy opponent ships");
 	      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"space"+"\t"+mv[2]+"\t"+"0"+"\t"+action2+"\t"+"1");
	      imperium_self.endTurn();
	      return 0;
	    });
	  }
	  return 0;
        }



        if (mv[0] == "faction4_exotrireme_ii_picktwo") {

          let player_to_go = parseInt(mv[1]);
          let sys = imperium_self.returnSectorAndPlanets(mv[2]);

	  if (player_to_go == imperium_self.game.player) {
	    imperium_self.addMove("resolve\tfaction4_exotrireme_ii_picktwo");
	    imperium_self.playerDestroyOpponentShips(player_to_go, 2, mv[2]);
	  } else {
	    imperium_self.updateStatus("Exotrireme II engaging in suicide assault");
	  }

	  return 0;

        }
      }
    });




    this.importTech('faction4-particle-weave', {
      name        :       "Particle Weave" ,
      faction     :       "faction4",
      type        :       "special" ,
      prereqs	  :	["red","red"],
      text	  :	  "Infantry vaporize 1 opponent for each hit received" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction4_particle_weave == undefined) {
          imperium_self.game.players_info[player-1].faction4_particle_weave = 0;
          imperium_self.game.players_info[player-1].faction4_particle_weave_opponent = 0;
          imperium_self.game.players_info[player-1].faction4_particle_weave_my_forces = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
	if (tech == "faction4-particle-weave") {
          imperium_self.game.players_info[gainer-1].faction4_particle_weave = 1;
        }
      },
      groundCombatTriggers : function(imperium_self, player, sector, planet_idx) {
        if (imperium_self.doesPlayerHaveTech(player, "faction4-particle-weave")) {
	  //
	  // if player is in combat
	  //
	  let sys = imperium_self.returnSectorAndPlanets(sector);
          let planet = sys.p[planet_idx];
          imperium_self.game.players_info[player-1].faction4_particle_weave_my_forces = planet.units[player-1].length;

        }
        return 0;
      },

      groundCombatRoundEnd(imperium_self, attacker, defender, sector, planet_idx) { 

        if (imperium_self.doesPlayerHaveTech(attacker, "faction4-particle-weave")) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  let planet = sys.p[planet_idx];
	  let current_forces = planet.units[attacker-1].length;
	  if (current_forces < imperium_self.game.players_info[attacker-1].faction4_particle_weave_my_forces) {
	    imperium_self.updateLog("Sardakk Particle Weave vaporizes 1 opponent infantry...");
	    for (let z = 0; z < planet.units[defender-1].length; z++) {
	      if (planet.units[defender-1][z].type == "infantry") {
		planet.units[defender-1].splice(z, 1);
		z = planet.units[defender-1].length+1;
	      }
	    }
	  }
	  imperium_self.saveSystemAndPlanets(sys);
	}

        if (imperium_self.doesPlayerHaveTech(defender, "faction4-particle-weave")) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  let planet = sys.p[planet_idx];
	  let current_forces = planet.units[defender-1].length;
	  if (current_forces < imperium_self.game.players_info[defender-1].faction4_particle_weave_my_forces) {
	    imperium_self.updateLog("Sardakk Particle Weave vaporizes 1 opponent infantry...");
	    for (let z = 0; z < planet.units[attacker-1].length; z++) {
	      if (planet.units[attacker-1][z].type == "infantry") {
		planet.units[attacker-1].splice(z, 1);
		z = planet.units[attacker-1].length+1;
	      }
	    }
	  }
	  imperium_self.saveSystemAndPlanets(sys);
	}

	return 1; 
      }
    });



    this.importFaction('faction1', {
      id		:	"faction1" ,
      name		: 	"Federation of Sol",
      nickname		: 	"Sol",
      homeworld		: 	"sector52",
      space_units	:	["carrier","carrier","destroyer","fighter","fighter","fighter"],
      ground_units	:	["infantry","infantry","infantry","infantry","infantry","spacedock"],
      tech		:	["neural-motivator","antimass-deflectors", "faction1-orbital-drop", "faction1-versatile", "faction1-flagship"],
      background	: 	"faction1.jpg",
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Sol Federation. a Terran faction under cellular military government. Your reinforced infantry and tactical flexibility will be important in your fight for the Imperial Throne. Good luck!</div>`
    });
 


    this.importTech("faction1-flagship", {

      name        :       "Sol Flagship" ,
      faction     :       "faction1",
      text	  :	  "Flagship gains 1 infantry when player selects a strategy card" ,
      type	  :	  "ability" ,
      playersChooseStrategyCardsBeforeTriggers : function(imperium_self, player) {
	if (!imperium_self.doesPlayerHaveTech(player, "faction1-flagship")) { return 0; }
        let player_fleet = imperium_self.returnPlayerFleet(player);
	if (player_fleet.flagship > 0) {
	  return 1;
	}
	return 0;
      },
      playersChooseStrategyCardsBeforeEvent : function(imperium_self, player) {
	for (let i in this.game.sectors) {
	  if (imperium_self.doesSectorContainPlayerUnit(player, i, "flagship")) {
	    let sec = this.game.sectors[i];
	    for (let k = 0; k < sec.units[player-1].length; k++) {
	      if (sec.units[player-1][k].type == "flagship") {
		imperium_self.loadUnitOntoShip(player, i, k, "infantry");
		imperium_self.updateLog("Faction Ability: infantry added to Sol Flagship...");
		return 1;
	      }
	    }
	  }
	}
	return 1;
      }  
    });




    this.importTech("faction1-orbital-drop", {

      name        :       "Orbital Drop" ,
      faction     :       "faction1",
      type	:	  "ability" ,
      text	  :	  "Drop two infantry onto any controlled planet" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].orbital_drop == undefined) {
          imperium_self.game.players_info[player-1].orbital_drop = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction1-orbital-drop") {
          imperium_self.game.players_info[gainer-1].orbital_drop = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
	if (menu === "main") {
          x.event = 'orbitaldrop';
          x.html = '<li class="option" id="orbitaldrop">orbital drop</li>';
	}
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) { 
        if (imperium_self.doesPlayerHaveTech(player, "faction1-orbital-drop") && menu === "main") {
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) { 
	    if (imperium_self.game.state.active_player_moved == 0) {
	      return 1;
	    }
	  }
	}
        return 0; 
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

	if (imperium_self.game.player == player) {
	
          imperium_self.playerSelectPlanetWithFilter(
            "Use Orbital Drop to reinforce which planet with two infantry: " ,
            function(planet) {
	      if (imperium_self.game.planets[planet].owner == imperium_self.game.player) { return 1; } return 0;
            },
            function(planet) {
              planet = imperium_self.game.planets[planet];
              imperium_self.addMove("resolve\tplay");
              imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
              imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
              imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
              imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\t"+"strategy"+"\t"+"1");
              imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys three infantry to " + planet.name);
              imperium_self.endTurn();
              return 0;
            },
	    null
	  );
	  return 0;
        };
      }
    });

    this.importTech("faction1-versatile", {

      name        :       "Versatile" ,
      faction     :       "faction1",
      type        :       "ability" ,
      text	  :	  "Gain an extra command token each round" ,
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction1-versatile")) {
          imperium_self.game.players_info[player-1].new_tokens_per_round = 3;
	}
      },

    });


    this.importTech("faction1-advanced-carrier-ii", {

      name        :       "Advanced Carrier II" ,
      faction     :       "faction1",
      replaces    :       "carrier-ii",
      unit        :       1 ,
      type	  :	"special",
      text	  :	  "A more sophisticated carrier" ,
      prereqs     :       ["blue","blue"],
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction1_advanced_carrier_ii == undefined) {
	  imperium_self.game.players_info[player-1].faction1_advanced_carrier_ii = 0;
	}
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	imperium_self.game.players_info[gainer-1].faction1_advanced_carrier_ii = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {

	if (imperium_self.game.players_info[unit.owner-1].faction1_advanced_carrier_ii == 1 && unit.type == "carrier") {
          unit.cost = 3;
          unit.combat = 9;
          unit.move = 2;
          unit.capacity = 8;
        }

        return unit;
      },

    });


    this.importTech("faction1-advanced-infantry-ii", {

      name        :       "Special Ops II" ,
      faction     :       "faction1",
      replaces    :       "infantry-ii",
      unit        :       1 ,
      type	  :  	  "special",
      text	  :	  "Battle-hardened infantry" ,
      prereqs     :       ["green","green"],
      initialize  :       function(imperium_self, player) {
	imperium_self.game.players_info[player-1].faction1_advanced_infantry_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	imperium_self.game.players_info[gainer-1].faction1_advanced_infantry_ii = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {

	if (imperium_self.game.players_info[unit.owner-1].faction1_advanced_infantry_ii == 1 && unit.type == "infantry") {
          unit.cost = 0.5;
          unit.combat = 6;
        }

        return unit;
      },

    });




    this.importFaction('faction3', {
      id		:	"faction3" ,
      name		: 	"XXCha Kingdom",
      nickname		: 	"XXCha",
      homeworld		: 	"sector51",
      space_units	: 	["carrier","cruiser","cruiser","fighter","fighter","fighter"],
      ground_units	: 	["infantry","infantry","infantry","infantry","pds","spacedock"],
      tech		: 	["graviton-laser-system","faction3-peace-accords","faction3-quash","faction3-flagship","faction3-field-nullification"],
      background	: 	'faction3.jpg',
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the XXCha Kingdom, a faction which excels in diplomacy and defensive weaponry. With the proper alliances and political maneuvers your faction you can be a contender for the Imperial Throne. Good luck!</div>`
    });
  




    this.importTech('faction3-flagship', {
      name        :       "XXCha Flagship" ,
      faction     :       "faction3",
      type        :       "ability" ,
      text	:	  "3 space cannons which target adjacent systems attached to flagship" ,
      returnPDSUnitsWithinRange : function(imperium_self, player, attacker, defender, sector, battery) {

       if (!imperium_self.doesPlayerHaveTech(player, "faction3-flagship")) { return battery; }

       let player_fleet = imperium_self.returnPlayerFleet(player);
       if (player_fleet.flagship > 0) {

         let as = this.returnAdjacentSectors(sector);
         for (let i = 0; i < as.length; i++) {
	   if (imperium_self.doesSectorContainPlayerUnit(player, as[i], "flagship")) {

             let pds1 = {};
                 pds1.range = imperium_self.returnUnit(player, "pds").range;
                 pds1.combat = imperium_self.returnUnit(player, "pds").combat;
                 pds1.owner = player;
                 pds1.sector = sector;

             let pds2 = {};
                 pds2.range = imperium_self.returnUnit(player, "pds").range;
                 pds2.combat = imperium_self.returnUnit(player, "pds").combat;
                 pds2.owner = player;
                 pds2.sector = sector;

             let pds3 = {};
                 pds3.range = imperium_self.returnUnit(player, "pds").range;
                 pds3.combat = imperium_self.returnUnit(player, "pds").combat;
                 pds3.owner = player;
                 pds3.sector = sector;

             battery.push(pds1);
             battery.push(pds2);
             battery.push(pds3);
     
	     return battery;
	   }
	 }
        }
       return battery;
      }
    });






    this.importTech('faction3-peace-accords', {

      name        :       "Peace Accords" ,
      faction     :       "faction3",
      type        :       "ability",
      text	:	  "Colonize adjacent unprotected planet when diplomacy secondary is played" ,
      initialize  : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].peace_accords == undefined) {
          imperium_self.game.players_info[player-1].peace_accords = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction3-peace-accords") {
          imperium_self.game.players_info[gainer-1].peace_accords = 1;
        }
      },
      strategyCardAfterTriggers : function(imperium_self, player, strategy_card_player, card) {
	if (imperium_self.game.players_info[player-1].peace_accords == 1) { return 1; }
	return 0;
      },
      strategyCardAfterEvent : function(imperium_self, player, strategy_card_player, card) {

	if (card == "diplomacy") {

	  let pcs = imperium_self.returnPlayerPlanetCards(player);
	  let sectors = [];
	  let adjacent_sectors = [];
	  let seizable_planets = [];

	  for (let i = 0; i < pcs.length; i++) {
	    if (!sectors.includes(imperium_self.game.planets[pcs[i]].sector)) {
	      sectors.push(imperium_self.game.planets[pcs[i]].sector);
	      adjacent_sectors.push(imperium_self.game.planets[pcs[i]].sector);
	    }
	  }

	 /*** add to include planets adjacent to units ***
         let plsectors = this.returnSectorsWithPlayerUnits(player);
         for (let i = 0; i < plsectors.length; i++) {
	   if (!sectors.includes(plsectors[i])) {
	      sectors.push(plsectors[i]);
	      adjacent_sectors.push(plsectors[i]);
           }
         }
	 *** add to include planets adjacent to units ***/



	  //
	  // get all planets adjacent to...
	  //
	  for (let i = 0; i < sectors.length; i++) {
	    let as = imperium_self.returnAdjacentSectors(sectors[i]);
	    for (let z = 0; z < as.length; z++) {
	      if (!adjacent_sectors.includes(as[z])) { adjacent_sectors.push(as[z]); }
	    }
    	  }

	  //
	  // get all planets I don't control in those sectors
	  //
	  for (let b = 0; b < adjacent_sectors.length; b++) {
	    let sys = imperium_self.returnSectorAndPlanets(adjacent_sectors[b]);
	    if (sys.p) {
	      for (let y = 0; y < sys.p.length; y++) {
	        let planet_uncontrolled = 0;
	        if (sys.p[y].owner != player) {
		  if (!imperium_self.doesPlanetHaveInfantry(sys.p[y])) {
	  	    seizable_planets.push(sys.p[y].planet);
	          }
	        }
	      }
	    }
	  }

	  //
	  //
	  //
	  if (seizable_planets.length < 0) { 
	    return 1;
	  }



	  if (imperium_self.game.players_info[player-1].peace_accords == 1) {
	    if (imperium_self.game.player == player) {
              imperium_self.playerSelectPlanetWithFilter(
                "Select a planet to annex via Peace Accords: " ,
                function(planet) {
	  	  if (seizable_planets.includes(planet)) { return 1; } return 0;
                },
                function(planet) {
                  imperium_self.addMove("annex\t"+imperium_self.game.player+"\t"+imperium_self.game.planets[planet].sector+"\t"+imperium_self.game.planets[planet].idx);
                  imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " annexes " + imperium_self.game.planets[planet].name + " via Peace Accords");
	    	  imperium_self.endTurn();
                  return 0;
                },
	        function() {
	    	  imperium_self.endTurn();
                  return 0;
		}
              );
            }
            return 0;
          }
	  return 1;
	}
	return 1;
      }
    });




    this.importTech('faction3-quash', {
      name        :       "Quash" ,
      faction     :       "faction3",
      type        :       "ability" ,
      text	:	  "Spend strategy token to quash upcoming agenda" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].quash == undefined) {
          imperium_self.game.players_info[player-1].quash = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction3-quash") {
          imperium_self.game.players_info[gainer-1].quash = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
	if (menu === "main") {
          x.event = 'quash';
          x.html = '<li class="option" id="quash">quash agenda</li>';
        }
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) { 
        if (imperium_self.doesPlayerHaveTech(player, "faction3-quash") && menu == "main") {
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) { 
	    if (imperium_self.game.state.active_player_moved == 0) {
	      return 1;
	    }
	  }
	}
	return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

        if (imperium_self.game.player == player) {

          let html = '';
          html += 'Select one agenda to quash in the Galactic Senate.<ul>';
          for (i = 0; i < imperium_self.game.state.agendas.length; i++) {
	    if (imperium_self.game.state.agendas[i] != "") {
              html += '<li class="option" id="'+imperium_self.game.state.agendas[i]+'">' + imperium_self.agenda_cards[imperium_self.game.state.agendas[i]].name + '</li>';
            }
          }
          html += '</ul>';

          imperium_self.updateStatus(html);

          $('.option').off();
          $('.option').on('mouseenter', function() { let s = $(this).attr("id"); imperium_self.showAgendaCard(imperium_self.game.state.agendas[s]); });
          $('.option').on('mouseleave', function() { let s = $(this).attr("id"); imperium_self.hideAgendaCard(imperium_self.game.state.agendas[s]); });
          $('.option').on('click', function() {

             let agenda_to_quash = $(this).attr('id');
	     imperium_self.updateStatus("Quashing Agenda");

             imperium_self.addMove("expend\t"+imperium_self.game.player+"\t"+"strategy"+"\t"+"1");
             imperium_self.addMove("quash\t"+agenda_to_quash+"\t"+"1"); // 1 = re-deal
	     imperium_self.endTurn();
	  });
	}
      }
    });




    this.importTech('faction3-instinct-training', {
      name        :       "Instinct Training" ,
      faction     :       "faction3",
      prereqs	:	["green"] ,
      color	:   "green" ,
      type        :       "special" ,
      text	:	  "Expend strategy token to cancel opponent action card" ,
      initialize  :	  function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].instinct_training == null) {
          imperium_self.game.players_info[player-1].instinct_training = 0;
	}
      },
      gainTechnology : function(imperium_self, gainer, tech) {
	if (tech == "faction3-instinct-training") {
          imperium_self.game.players_info[gainer-1].instinct_training = 1;
        }
      },
      playActionCardTriggers : function(imperium_self, player, action_card_player, card) {
        if (imperium_self.game.players_info[player-1].instinct_training == 1) { return 1; }
	return 0;
      },
      playActionCardEvent : function(imperium_self, player, action_card_player, card) {

        if (imperium_self.game.player == player) {
          // remove previous action card
          imperium_self.addMove("resolve\t"+"action_card");
          imperium_self.addMove("resolve\t"+"action_card_post");
          imperium_self.addMove("expend\t"+imperium_self.game.player+"strategy"+"1");
	  imperium_self.endTurn();
        }

	return 0;

      },
    });

    this.importTech('faction3-field-nullification', {

      name        :       "Nullification Fields" ,
      faction     :       "faction3",
      type        :       "special" ,
      color	  :	  "yellow" ,
      prereqs	:	["yellow","yellow"] ,
      text	:	  "Terminate the turn of active player who activates a system containing your ship" ,
      initialize  : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].field_nullification == undefined) {
          imperium_self.game.players_info[player-1].field_nullification = 0;
          imperium_self.game.players_info[player-1].field_nullification_exhausted = 0;
        }
      },
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction3-field-nullification")) {
          imperium_self.game.players_info[player-1].field_nullification_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction3-field-nullification") {
          imperium_self.game.players_info[gainer-1].field_nullification = 1;
          imperium_self.game.players_info[gainer-1].field_nullification_exhausted = 0;
        }
      },
      activateSystemTriggers : function(imperium_self, activating_player, player, sector) {
        if (imperium_self.doesPlayerHaveTech(player, "faction3-field-nullification")) {
	  if (imperium_self.doesSectorContainPlayerShips(player, sector)) { 
	    if (activating_player != player) { return 1; }
	  }
	}
	return 0;
      },
      activateSystemEvent : function(imperium_self, activating_player, player, sector) {
        if (imperium_self.doesPlayerHaveTech(player, "faction3-field-nullification")) {

	  if (imperium_self.game.players_info[player-1].field_nullification_exhausted == 1) { return 1; }

	  if (imperium_self.game.player != player) {
	    imperium_self.updateStatus(imperium_self.returnFaction(player) + " is deciding whether to use Nullification Fields");
	    return 0;
	  }

	  let html = 'Do you wish to use Field Nullification to terminate this player\'s turn? <ul>';
	  html += '<li class="textchoice" id="yes">activate nullification field</li>';
	  html += '<li class="textchoice" id="no">do not activate</li>';
	  html += '</ul>';

	  imperium_self.updateStatus(html);

	  $('.textchoice').off();
	  $('.textchoice').on('click', function() {

	    let choice = $(this).attr("id");

	    if (choice == "yes") {
              imperium_self.addMove("resolve\tplay");
              imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
              imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
	      imperium_self.addMove("field_nullification\t"+player+"\t"+activating_player+"\t"+sector);
	      imperium_self.endTurn();
	    }
	    if (choice == "no") {
	      imperium_self.endTurn();
	    }
	  });
	  return 0;
        }
	return 1;
      },
      handleGameLoop : function(imperium_self, qe, mv) {
        if (mv[0] == "field_nullification") {

          let player = parseInt(mv[1]);
          let activating_player = parseInt(mv[2]);
	  let sector = mv[3];
          imperium_self.game.queue.splice(qe, 1);

	  imperium_self.updateLog(imperium_self.returnFactionNickname(player) + " uses Nullification Fields to end " + imperium_self.returnFactionNickname(activating_player) + " turn");

          return 1;

        }
	return 1;
      }
    });



    this.importFaction('faction5', {
      id		:	"faction5" ,
      name		: 	"Yin Brotherhood",
      nickname		: 	"Yin",
      homeworld		: 	"sector74",
      space_units	: 	["carrier","carrier","destroyer","fighter","fighter","fighter","fighter"],
      ground_units	: 	["infantry","infantry","infantry","infantry","spacedock"],
      tech		: 	["sarween-tools", "faction5-indoctrination", "faction5-devotion", "faction5-flagship"],
      background	: 	'faction5.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Yin Brotherhood, a monastic order of religious zealots whose eagerness to sacrifice their lives for the collective good makes them terrifying in one-on-one combat. Direct their self-destructive passion and you can win the Imperial Throne. Good luck!</div>`
    });



    // two influence to convert an opponent infantry to your side
    //
    // runs at the start of ground combat, and after every round
    //
    this.importTech('faction5-indoctrination', {
      name        :       "Indoctrination" ,
      faction     :       "faction5",
      type        :       "ability" ,
      text        :       "Spend 2 influence to convert 1 enemy infantry at combat start" ,
      groundCombatTriggers : function(imperium_self, player, sector, planet_idx) {
        if (imperium_self.doesPlayerHaveTech(player, "faction5-indoctrination")) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  if (sys.p[planet_idx].units[player-1].length > 0) {
            if (imperium_self.returnAvailableInfluence(player) >= 2) {
	      if (imperium_self.game.state.ground_combat_round < 2) {
	        return 1;
	      }
            }
          }
        }
	return 0;
      },
      groundCombatEvent : function(imperium_self, player, sector, planet_idx) { 
	if (imperium_self.game.player == player) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  if (sys.p[planet_idx].units[player-1].length > 0) {
            imperium_self.playIndoctrination(imperium_self, player, sector, planet_idx, function(imperium_self) {	  
  	      imperium_self.endTurn();
            });
	  } else {
  	    imperium_self.endTurn();
          }
          return 0;
        }
      },
    });



    //
    // after each space battle round, sacrifice cruiser or destroyer to assign 1 hit to a unit
    //
    this.importTech('faction5-devotion', {
      name        :       "Devotion" ,
      faction     :       "faction5",
      type        :       "ability" ,
      text        :       "Sacrifice destroyer or cruiser to assign 1 enemy hit at combat end" ,
      spaceCombatTriggers : function(imperium_self, player, sector) {
        if (imperium_self.doesPlayerHaveTech(player, "faction5-devotion")) {
          if (imperium_self.doesPlayerHaveShipsInSector(player, sector)) {
            if (imperium_self.game.state.space_combat_round > 0) {
              return 1;
            }
          }
        }
	return 0;
      },
      spaceCombatEvent : function(imperium_self, player, sector) {
        if (imperium_self.game.player == player) {
          imperium_self.playDevotion(imperium_self, player, sector, function() {
            imperium_self.endTurn();
          });
	}
	return 0;
      }
    });


    this.importTech('faction5-impulse-core', {
      name        :       "Impulse Core" ,
      faction     :       "faction5",
      prereqs     :       ["yellow", "yellow"] ,
      color       :       "yellow" ,
      type        :       "special" ,
      text        :       "Sacrifice destroyer or cruiser at combat start, opponent takes hit on capital ship" ,
      spaceCombatTriggers : function(imperium_self, player, sector) {
        if (imperium_self.doesPlayerHaveTech(player, "faction5-impulse-core")) {
          if (imperium_self.doesPlayerHaveShipsInSector(player, sector)) {
            if (imperium_self.game.state.space_combat_round == 0) {
              return 1;
            }
          }
        }
        return 0;
      },
      spaceCombatEvent : function(imperium_self, player, sector) {
	if (imperium_self.game.player == player) {
          imperium_self.playDevotion(imperium_self, player, sector, function() {
            imperium_self.endTurn();
          }, 1);
	}
	return 0;
      }
    });



    this.importTech('faction5-yin-spinner', {
      name        :       "Yin Spinner" ,
      faction     :       "faction5",
      prereqs     :       ["green", "green"] ,
      color       :       "green" ,
      type        :       "special" ,
      initialize  :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction5_yin_spinner == null) {
          imperium_self.game.players_info[player-1].faction5_yin_spinner = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction5-yin-spinner") {
          imperium_self.game.players_info[gainer-1].faction5_yin_spinner = 1;
        }
      },
      playerEndTurnTriggers : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction5_yin_spinner == 1) {
	  if (imperium_self.game.player == player) {
            if (imperium_self.game.state.active_player_has_produced == 1) {
	      return 1;
            }
          }
        }
	return 0;
      },
      playerEndTurnEvent : function(imperium_self, player) {

	if (imperium_self.game.player != player) { return 0; }

        imperium_self.playerSelectPlanetWithFilter(
              "Yin Spinner Tech: place additional infantry on which planet?",
              function(planet) {
                planet = imperium_self.game.planets[planet];
                if (planet.owner == imperium_self.game.player) { return 1; } return 0;
              },
              function(planet) {
                planet = imperium_self.game.planets[planet];
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sectors);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " spins extra infantry on " + planet.name);
                imperium_self.endTurn();
                return 0;

              },
              function() {
                imperium_self.playerTurn();
              }
        );
      }
    });










    
    this.importTech("faction5-flagship", {
      name        	:       "Yin Flagship" ,
      faction     	:       "faction5",
      type      	:       "ability" ,
      text        	:       "Wipes out all ships in sector when destroyed" ,
      unitDestroyed : function(imperium_self, attacker, unit) {
	if (unit.type == "flagship") {
          if (imperium_self.doesPlayerHaveTech(unit.owner, "faction5-flagship")) {

	    let active_sector = imperium_self.game.state.activated_sector;
            if (active_sector === "") { active_sector = imperium_self.game.state.space_combat_sector; }

	    // destroy all units in this sector
	    let sys = imperium_self.returnSectorAndPlanets(active_sector);

	    if (sys) {

	      for (let i = 0; i < sys.s.units.length; i++) {
		sys.s.units[i] = [];
	      }
	      for (let i = 0; i < sys.p.length; i++) {
	        for (let ii = 0; ii < sys.p[i].units.length; ii++) {
		  sys.p[i].units[ii] = [];
	        }
	      }

              imperium_self.saveSystemAndPlanets(active_sector);
              imperium_self.updateSectorGraphics(active_sector);
	      imperium_self.updateLog("The destruction of the Yin Flagship has caused a terrible calamity...");

	    }
	  }
	}
	return unit;
      },
    });





this.playIndoctrination = function(imperium_self, player, sector, planet_idx, mycallback) {

  if (this.game.player != player) { return; }
  if (this.game.player != player) { return; }

  let sys = imperium_self.returnSectorAndPlanets(sector);
  let planet = sys.p[planet_idx];
  let opponent = imperium_self.returnOpponentOnPlanet(player, planet);
  let can_play_indoctrination = 0;

  if (imperium_self.returnNonPlayerInfantryOnPlanet(player, planet) <= 0 || opponent == -1) {
    mycallback(imperium_self);
    return;
  }

  if (sys.p[planet_idx].units[opponent-1].length <= 0) {
    mycallback(imperium_self);
    return;
  }

  let html = "<div class='sf-readable'>Do you wish to spend 2 influence to convert 1 enemy infantry to your side?</div><ul>";
      html += '<li class="textchoice" id="yes">yes</li>';
      html += '<li class="textchoice" id="no">no</li>';
      html += '</ul>';
  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {
    let action2 = $(this).attr("id");
    if (action2 === "no") {
      mycallback(imperium_self);
      return;
    }
    if (action2 === "yes") {

      imperium_self.playerSelectInfluence(2, function (success) {

        if (success == 1) {
          imperium_self.addMove("destroy_infantry_on_planet"+"\t"+player+"\t"+sector+"\t"+planet_idx+"\t"+1);
          imperium_self.addMove("add_infantry_to_planet"+"\t"+player+"\t"+planet.planet+"\t"+1);
          imperium_self.addMove("NOTIFY\tYin Indoctrination converts opposing infantry");
        } else {
          mycallback(imperium_self);
          return;
        }
      });
    }
  });
}
   



this.playDevotion = function(imperium_self, player, sector, mycallback, impulse_core=0) {

  if (imperium_self.game.player != player) { return 0; }

  let sys = imperium_self.returnSectorAndPlanets(sector);
  let opponent = imperium_self.returnOpponentInSector(player, sector);

  let can_sacrifice_destroyer = imperium_self.doesSectorContainPlayerUnit(player, sector, "destroyer");
  let can_sacrifice_cruiser = imperium_self.doesSectorContainPlayerUnit(player, sector, "cruiser");
 
  if (can_sacrifice_destroyer != 1 && can_sacrifice_cruiser != 1) {
    mycallback(imperium_self);
    return;
  }
  if (opponent == -1) {
    mycallback(imperium_self);
    return;
  }


  let html = "<div class='sf-readable'>Do you wish to sacrifice a Destroyer or Cruiser to assign 1 hit to an enemy ship?</div><ul>";
  if (can_sacrifice_destroyer) {
      html += '<li class="textchoice" id="destroyer">sacrifice destroyer</li>';
  }
  if (can_sacrifice_cruiser) {
      html += '<li class="textchoice" id="cruiser">sacrifice cruiser</li>';
  }
      html += '<li class="textchoice" id="no">no</li>';
      html += '</ul>';
  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {
    let action2 = $(this).attr("id");
    if (action2 === "no") {
      mycallback(imperium_self);
      return;
    }
    if (action2 === "destroyer") {

      let unit_idx = 0;
      for (let i = 0; i < sys.s.units[player-1].length; i++) {
	if (sys.s.units[player-1][i].type == "destroyer") {
	  unit_idx = i;
        }
      }

      imperium_self.addMove("destroy_unit"+"\t"+player+"\t"+player+"\t"+"space"+"\t"+sector+"\t"+0+"\t"+unit_idx+"\t"+1);
      imperium_self.playDevotionAssignHit(imperium_self, player, sector, mycallback, impulse_core);
      return;
    }
    if (action2 === "cruiser") {

      let unit_idx = 0;
      for (let i = 0; i < sys.s.units[player-1].length; i++) {
	if (sys.s.units[player-1][i].type == "cruiser") {
	  unit_idx = i;
        }
      }

      imperium_self.addMove("destroy_unit"+"\t"+player+"\t"+player+"\t"+"space"+"\t"+sector+"\t"+0+"\t"+unit_idx+"\t"+1);
      imperium_self.playDevotionAssignHit(imperium_self, player, sector, mycallback, impulse_core);
      return;
    }
  });

  return 0;
}
   
this.playDevotionAssignHit = function(imperium_self, player, sector, mycallback, impulse_core=0) {

  let sys = imperium_self.returnSectorAndPlanets(sector);
  let opponent = imperium_self.returnOpponentInSector(player, sector);

  if (impulse_core == 1) {
    this.addMove("assign_hits_capital_ship"+"\t"+opponent+"\t"+sector+"\t"+1);
    mycallback();
    return;
  }

  let html = "<div class='sf-readable'>Assign 1 hit to which opponent ship?</div><ul>";
  for (let i = 0; i < sys.s.units[opponent-1].length; i++) {

    let unit = sys.s.units[opponent-1][i];

    html += '<li class="textchoice" id="'+i+'">'+unit.name;

    if (unit.capacity >= 1) {
      let fleet = '';
      let fighters = 0;
      let infantry = 0;
      for (let ii = 0; ii < unit.storage.length; ii++) {
        if (unit.storage[ii].type == "infantry") {
          infantry++;
        }
        if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
          fighters++;
        }
      }
      if (infantry > 0 || fighters > 0) {
        fleet += ' ';
        if (infantry > 0) { fleet += infantry + "i"; }
        if (fighters > 0) {
          if (infantry > 0) { fleet += ", "; }
          fleet += fighters + "f";
        }
        fleet += ' ';
      }
      html += fleet;
    }

    html += '</li>';

  }
  html += '</ul>';

  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    $('.textchoice').off();
    let unit_idx = $(this).attr("id");
    imperium_self.addMove("assign_hit"+"\t"+player+"\t"+opponent+"\t"+player+"\t"+"ship"+"\t"+sector+"\t"+unit_idx+"\t"+1);
    mycallback(imperium_self);
    return;

  }); 
}




    this.importFaction('faction6', {
      id		:	"faction6" ,
      name		: 	"Yssaril Tribes",
      nickname		: 	"Yssaril",
      homeworld		: 	"sector75",
      space_units	: 	["carrier","carrier","cruiser","fighter","fighter"],
      ground_units	: 	["infantry","infantry","infantry","infantry","infantry","pds","spacedock"],
      //tech		: 	["neural-motivator", "faction6-stall-tactics", "faction6-scheming", "faction6-crafty","faction6-transparasteel-plating","faction6-mageon-implants","faction6-flagship"],
      tech		: 	["neural-motivator", "faction6-stall-tactics", "faction6-scheming", "faction6-crafty","faction6-flagship"],
      background	: 	'faction6.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Yssaril Tribe, a primitive race of swamp-dwelling creatures whose fast instincts and almost unerring ability to change tactics on-the-fly lead many to suspect more is at work than their primitive appearance belies. Good luck!</div>`
    });






    this.importTech("faction6-stall-tactics", {

      name        :       "Stall Tactics" ,
      faction     :       "faction6",
      type      :         "ability" ,
      text        :       "Discard an Action Card to stall one turn" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].stall_tactics == undefined) {
          imperium_self.game.players_info[player-1].stall_tactics = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction6-stall-tactics") {
          imperium_self.game.players_info[gainer-1].stall_tactics = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
        if (menu === "main") {
          x.event = 'stalltactics';
          x.html = '<li class="option" id="stalltactics">discard action card (stall)</li>';
        }
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction6-stall-tactics") && menu === "main") {
	  let ac = imperium_self.returnPlayerActionCards(player);
	  if (ac.length > 0) {
            return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

        if (imperium_self.game.player == player) {
	  imperium_self.playerDiscardActionCards(1, function() {
            imperium_self.addMove("resolve\tplay");
            imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
            imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
            imperium_self.endTurn();
            return 0;
	  });
	}

	return 0;
      }
    });





    this.importTech("faction6-crafty", {

      name        :       "Crafty" ,
      faction     :       "faction6",
      type        :       "ability" ,
      text        :       "Unlimited action cards. Game effects cannot change." ,
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction6-crafty")) {
          imperium_self.game.players_info[player-1].action_card_limit = 1000;
        }
      },
    });






    this.importTech("faction6-scheming", {

      name        :       "Scheming" ,
      faction     :       "faction6",
      type        :       "ability" ,
      text        :       "Receive bonus card when gaining action cards, then discard one" ,
      initialize  :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction6_scheming == null) {
          imperium_self.game.players_info[player-1].faction6_scheming = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction6-scheming") {
          imperium_self.game.players_info[gainer-1].faction6_scheming = 1;
        }
      },
      gainActionCards : function(imperium_self, player, amount) {
        if (imperium_self.doesPlayerHaveTech(player, "faction6-scheming")) {
          imperium_self.game.queue.push("yssaril_action_card_discard\t"+player+"\t1");
          imperium_self.game.queue.push("gain\t"+player+"\taction_cards"+"\t"+1+"\t"+"0");
          imperium_self.game.queue.push("DEAL\t2\t"+player+"\t1");
          imperium_self.game.queue.push("NOTIFY\t" + imperium_self.returnFaction(player) + " gains bonus action card and must discard one");
	}
        return 1;
      },
      handleGameLoop : function(imperium_self, qe, mv) {
        if (mv[0] == "yssaril_action_card_discard") {

          let player = parseInt(mv[1]);
          let num = parseInt(mv[2]);
          imperium_self.game.queue.splice(qe, 1);

	  if (imperium_self.game.player === player) {
	    imperium_self.playerDiscardActionCards(num, function() {
	      imperium_self.endTurn();
	    });
	  }

          return 0;
        }
	return 1;
      }
    });







    //
    // players that have passed cannot play action cards during your turn
    //
    this.importTech('faction6-transparasteel-plating', {
      name        :       "Transparasteel Plating" ,
      faction     :       "faction6",
      prereqs     :       ["green"] ,
      color       :       "green" ,
      type        :       "special" ,
      text        :       "Selectively terminate action cards from players who have passed on your turn" ,
      initialize  :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].transparasteel_plating == null) {
          imperium_self.game.players_info[player-1].transparasteel_plating = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction6-transparasteel-plating") {
          imperium_self.game.players_info[gainer-1].transparasteel_plating = 1;
        }
      },
      playActionCardTriggers : function(imperium_self, player, action_card_player, card) {
        if (imperium_self.game.players_info[player-1].transparasteel_plating == 1) {
	  if (imperium_self.game.player == player && action_card_player != player && imperium_self.game.players_info[action_card_player-1].passed == 1) {
	    return 1;
	  }
	}
	return 0; 
      },
      playActionCardEvent : function(imperium_self, player, action_card_player, card) {
        if (imperium_self.game.player == player) {
          // remove action card
          imperium_self.addMove("resolve\t"+"action_card");
          imperium_self.addMove("resolve\t"+"action_card_post");
          imperium_self.addMove("expend\t"+imperium_self.game.player+"strategy"+"1");
          imperium_self.endTurn();
        }
        return 0;
      },
    });




    this.importTech('faction6-mageon-implants', {
      name        :       "Mageon Implants" ,
      faction     :       "faction6",
      prereqs     :       ["green","green","green"] ,
      color       :       "green" ,
      type        :       "special" ,
      text        :       "Exhaust to look at other players action cards and take one." ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].mageon_implants == undefined) {
          imperium_self.game.players_info[player-1].mageon_implants = 0;
          imperium_self.game.players_info[player-1].mageon_implants_exhausted = 0;
        }
      },
      onNewRound : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].mageon_implants == 1) {
          imperium_self.game.players_info[player-1].mageon_implants = 1;
          imperium_self.game.players_info[player-1].mageon_implants_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction6-mageon-implants") {
          imperium_self.game.players_info[gainer-1].mageon_implants = 1;
          imperium_self.game.players_info[gainer-1].mageon_implants_exhausted = 0;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        if (menu == "main") {
          return { event : 'mageonimplants', html : '<li class="option" id="mageonimplants">exhaust mageon implants</li>' };
        }
        return {};
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
        if (menu == "main" && imperium_self.game.players_info[player-1].mageon_implants_exhausted == 0 && imperium_self.game.players_info[player-1].mageon_implants == 1) {
          return 1;
        }
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

        imperium_self.playerSelectPlayerWithFilter(
          "Select a player from which to take an action card (if possible): " ,
          function(player) {
            if (player != imperium_self.game.player) { return 1; } return 0;
          },
          function(player) {
            imperium_self.addMove("faction6_choose_card_triggered\t"+imperium_self.game.player+"\t"+player);
            imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " pulls a random action card from " + imperium_self.returnFaction(player));
            imperium_self.endTurn();
            return 0;
          },
          function() {
            imperium_self.playerTurn();
          }
        );

        return 0;
      },
      handleGameLoop : function(imperium_self, qe, mv) {

        if (mv[0] == "faction6_choose_card_triggered") {

          let faction6_player = parseInt(mv[1]);
          let faction6_target = parseInt(mv[2]);
          imperium_self.game.queue.splice(qe, 1);

	  if (imperium_self.game.player === faction6_target) {
	    let ac = imperium_self.returnPlayerActionCards();
	    imperium_self.addMove("faction6_choose_card_return\t"+faction6_player+"\t"+faction6_target+"\t"+JSON.stringify(ac));
	    imperium_self.endTurn();
	  }

          return 0;
        }

        if (mv[0] == "faction6_choose_card_return") {

          let faction6_player = parseInt(mv[1]);
          let faction6_target = parseInt(mv[2]);
          let faction6_target_cards = JSON.parse(mv[3]);

          imperium_self.game.queue.splice(qe, 1);

	  if (imperium_self.game.player === faction6_player) {

    	    let html = '<div class="" style="margin-bottom:10px">Select ' + imperium_self.returnFactionNickname(faction6_target) + ' action card:</div><ul>';
	    for (let i = 0; i < faction6_target_cards.length; i++) {
      	      html += `<li class="option" id="${i}">${imperium_self.action_cards[faction6_target_cards[i]].name}</li>`;
	    }
	    html += `<li class="option" id="cancel">skip</li>`;

	    imperium_self.updateStatus(html);

            $('.option').off();
            $('.option').on('click', function () {

	      $('.option').off();

              let opt = $(this).attr("id");


	      if (opt === "skip") {
		imperium_self.playerTurn();	
		return 0;
	      }

	      imperium_self.addMove("setvar\tplayers\t"+imperium_self.game.player+"\t"+"mageon_implants_exhausted"+"\t"+"int"+"\t"+"1");
              imperium_self.addMove("pull\t"+imperium_self.game.player+"\t"+faction6_target+"\t"+"action"+"\t"+faction6_target_cards[opt]);
              imperium_self.endTurn();
              return 0;

            });
	  }

          return 0;
        }

	return 1;
      }

    });




    
    this.importTech("faction6-flagship", {
      name        	:       "Yssaril Flagship" ,
      faction     	:       "faction6",
      type      	:       "ability" ,
      text        	:       "May move through sectors containing other ships" ,
      upgradeUnit :       function(imperium_self, player, unit) {
        if (imperium_self.doesPlayerHaveTech(unit.owner, "faction6-flagship") && unit.type == "flagship") {
          unit.may_fly_through_sectors_containing_other_ships = 1;
          unit.move = 3;
        }
        return unit;
      },
    });







/****

this.playMageonImplants = function(imperium_self, player, target, mycallback) {

  if (imperium_self.game.player != player) { return 0; }



}



this.playDevotion = function(imperium_self, player, sector, mycallback, impulse_core=0) {


  let sys = imperium_self.returnSectorAndPlanets(sector);
  let opponent = imperium_self.returnOpponentInSector(player, sector);

  let can_sacrifice_destroyer = imperium_self.doesSectorContainPlayerUnit(player, sector, "destroyer");
  let can_sacrifice_cruiser = imperium_self.doesSectorContainPlayerUnit(player, sector, "cruiser");
 
  if (can_sacrifice_destroyer != 1 && can_sacrifice_cruiser != 1) {
    mycallback(imperium_self);
    return;
  }
  if (opponent == -1) {
    mycallback(imperium_self);
    return;
  }


  let html = "<div class='sf-readable'>Do you wish to sacrifice a Destroyer or Cruiser to assign 1 hit to an enemy ship?</div><ul>";
  if (can_sacrifice_destroyer) {
      html += '<li class="textchoice" id="destroyer">sacrifice destroyer</li>';
  }
  if (can_sacrifice_cruiser) {
      html += '<li class="textchoice" id="cruiser">sacrifice cruiser</li>';
  }
      html += '<li class="textchoice" id="no">no</li>';
      html += '</ul>';
  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {
    let action2 = $(this).attr("id");
    if (action2 === "no") {
      mycallback(imperium_self);
      return;
    }
    if (action2 === "destroyer") {

      let unit_idx = 0;
      for (let i = 0; i < sys.s.units[player-1].length; i++) {
	if (sys.s.units[player-1][i].type == "destroyer") {
	  unit_idx = i;
        }
      }

      imperium_self.addMove("destroy_unit"+"\t"+player+"\t"+player+"\t"+"space"+"\t"+sector+"\t"+0+"\t"+unit_idx+"\t"+1);
      imperium_self.playDevotionAssignHit(imperium_self, player, sector, mycallback, impulse_core);
      return;
    }
    if (action2 === "cruiser") {

      let unit_idx = 0;
      for (let i = 0; i < sys.s.units[player-1].length; i++) {
	if (sys.s.units[player-1][i].type == "cruiser") {
	  unit_idx = i;
        }
      }

      imperium_self.addMove("destroy_unit"+"\t"+player+"\t"+player+"\t"+"space"+"\t"+sector+"\t"+0+"\t"+unit_idx+"\t"+1);
      imperium_self.playDevotionAssignHit(imperium_self, player, sector, mycallback, impulse_core);
      return;
    }
  });

  return 0;
}

*****/






    this.importStrategyCard("construction", {
      name     			:       "Construction",
      rank			:	4,
      img			:	"/strategy/BUILD.png",

      text			:	"Build a PDS or Space Dock. Then build a PDS.<hr />Other players may spend a strategy token and activate a sector to build a PDS or Space Dock in it." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {
          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("strategy\t"+"construction"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
	  imperium_self.playerAcknowledgeNotice("You have played Construction. First you will have the option of producing a PDS or Space Dock. Then you will have the option of producing an additional PDS if you so choose.", function() {
            imperium_self.playerBuildInfrastructure((sector) => {
              imperium_self.playerBuildInfrastructure((sector) => {
		imperium_self.updateSectorGraphics(sector);
                imperium_self.endTurn();
              }, 2);
            }, 1);
          });
        }

      },


      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player != strategy_card_player && imperium_self.game.player == player) {

          let html = '<p>Construction has been played. Do you wish to spend 1 strategy token to build a PDS or Space Dock? This will activate the sector (if unactivated): </p><ul>';
          if (imperium_self.game.state.round == 1) { 
	    html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Construction strategy card. You may spend 1 strategy token to build a PDS or Space Dock on a planet you control (this will activate the sector). You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
	  }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            html += '<li class="option" id="yes">Yes</li>';
          }
	  html += '<li class="option" id="no">No</li>';
          html += '</ul>';
 
          imperium_self.updateStatus(html);

          imperium_self.lockInterface(); 

          $('.option').off();
          $('.option').on('click', function() {

            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();
 

            let id = $(this).attr("id");
 
            if (id == "yes") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tstrategy\t1");
              imperium_self.playerBuildInfrastructure((sector) => {
                imperium_self.addMove("activate\t"+imperium_self.game.player+"\t"+sector);
		imperium_self.updateSectorGraphics(sector);
                imperium_self.endTurn();
              }, 1);
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
          });
        }
      },
    });




    this.importStrategyCard("diplomacy", {
      name     			:       "Diplomacy",
      rank			:	2,
      img			:	"/strategy/DIPLOMACY.png",
      text			:	"Pick a sector other than New Byzantium. Other players activate it. Refresh two planets.<hr />Other players may spend a strategy token to refresh two planets." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

          imperium_self.updateStatus('Select sector to quagmire in diplomatic negotiations, and refresh any planets in that system: ');
          imperium_self.playerSelectSector(function(sector) {

	      if (sector.indexOf("_") > -1) { sector = imperium_self.game.board[sector].tile; }

              imperium_self.addMove("resolve\tstrategy");
              imperium_self.addMove("strategy\t"+"diplomacy"+"\t"+strategy_card_player+"\t2");
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player)+" uses Diplomacy to activate "+imperium_self.game.sectors[sector].name);

              for (let i = 0; i < imperium_self.game.players_info.length; i++) {
                imperium_self.addMove("activate\t"+(i+1)+"\t"+sector);
              }

              //
              // re-activate any planets in that system
              //
              let sys = imperium_self.returnSectorAndPlanets(sector);
	      if (sys.p) {
                for (let i = 0; i < sys.p.length; i++) {
                  if (sys.p[i].owner == imperium_self.game.player) {
		    for (let p in imperium_self.game.planets) {
		      if (sys.p[i] == imperium_self.game.planets[p]) {
                        imperium_self.addMove("unexhaust\t"+imperium_self.game.player+"\t"+"planet"+"\t"+p);
		      }
		    }
                  }
                }
	      }
              imperium_self.saveSystemAndPlanets(sys);
              imperium_self.endTurn();


          });
        }
	return 0;

      },

      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player != strategy_card_player && imperium_self.game.player == player) {

          let html = '<p>Do you wish to spend 1 strategy token to unexhaust two planet cards? </p><ul>';
	  if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has just played the Diplomacy strategy card. This lets you to spend 1 strategy token to unexhaust two planet cards. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
          }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) {
	    html += '<li class="option" id="yes">Yes</li>';
	  }
          html += '<li class="option" id="no">No</li>';
          html += '</ul>';
          imperium_self.updateStatus(html);

          $('.option').off();
          $('.option').on('click', function() {

            let id = $(this).attr("id");

            if (id == "yes") {

              let array_of_cards = imperium_self.returnPlayerExhaustedPlanetCards(imperium_self.game.player); // unexhausted

              let choices_selected = 0;
              let max_choices = 0;

              let html  = "<p>Select planets to unexhaust: </p><ul>";
              let divname = ".cardchoice";
              for (let z = 0; z < array_of_cards.length; z++) {
                max_choices++;
                html += '<li class="cardchoice" id="cardchoice_'+array_of_cards[z]+'">' + imperium_self.returnPlanetCard(array_of_cards[z]) + '</li>';
              }
              if (max_choices == 0) {
                html += '<li class="textchoice" id="cancel">cancel (no options)</li>';
                divname = ".textchoice";
              }
              html += '</ul>';
              if (max_choices >= 2) { max_choices = 2; }

              imperium_self.updateStatus(html);
	      imperium_self.lockInterface();

              $(divname).off();
              $(divname).on('click', function() {

	        if (!imperium_self.mayUnlockInterface()) {
	          salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
	          return;
	        }
	        imperium_self.unlockInterface();

                let action2 = $(this).attr("id");

                if (action2 === "cancel") {
                  imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	          imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
                  imperium_self.endTurn();
                  return;
                }

                let tmpx = action2.split("_");
                let divid = "#"+action2;
                let y = tmpx[1];
                let idx = 0;
                for (let i = 0; i < array_of_cards.length; i++) {
                  if (array_of_cards[i] === y) {
                    idx = i;
                  }
                }

                choices_selected++;
                imperium_self.addMove("unexhaust\t"+imperium_self.game.player+"\tplanet\t"+array_of_cards[idx]);

                $(divid).off();
                $(divid).css('opacity','0.2');

                if (choices_selected >= max_choices) {
                  imperium_self.prependMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	          imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
                  imperium_self.endTurn();
                }

              });
            }

            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }

          });

        }

      },
    });



    this.importStrategyCard("imperial", {
      name     			:       "Imperial",
      rank			:	8,
      img			:	"/strategy/EMPIRE.png",
      text			:	"You may score a public objective. If you control New Byzantium gain 1 VP. Otherwise gain a secret objective.<hr />All players score objectives in Initiative Order" ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

	  let supplementary_scoring = function() {
  	    imperium_self.playerAcknowledgeNotice("You will first be asked to score your public objective. The game will then allow other players to purchase secret objectives.", function() {
              imperium_self.addMove("resolve\tstrategy");
              imperium_self.playerScoreVictoryPoints(imperium_self, function(imperium_self, vp, objective) {

                if (vp > 0 && (imperium_self.stage_i_objectives[objective] != undefined || imperium_self.stage_ii_objectives[objective] != undefined)) {

                  if (imperium_self.stage_i_objectives[objective] != undefined) {
                    imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.endTurn();
		    });
		  } else {
                    imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.endTurn();
		    });
		  }
		} else {
                  imperium_self.addMove("score\t"+imperium_self.game.player+"\t"+"1"+"\t"+"new-byzantium");
		  imperium_self.updateStatus("scoring completed");
                  imperium_self.endTurn();
		}
              }, 1);
            });
	  };




	  let supplementary_secret = function() {
  	    imperium_self.playerAcknowledgeNotice("You will next be asked to score a public objective. The game will then allow other players to purchase secret objectives.", function() {
              imperium_self.addMove("resolve\tstrategy");
              imperium_self.playerScoreVictoryPoints(imperium_self, function(imperium_self, vp, objective) {

                if (vp > 0 && (imperium_self.stage_i_objectives[objective] != undefined || imperium_self.stage_ii_objectives[objective] != undefined)) {

                  if (imperium_self.stage_i_objectives[objective] != undefined) {
                    imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.addMove("gain\t"+strategy_card_player+"\t"+"secret_objective"+"\t"+"1");
                      for (let i = 0; i < imperium_self.game.players_info.length; i++) { imperium_self.addMove("DEAL\t6\t"+(i+1)+"\t1"); }
                      imperium_self.endTurn();
		    });
		  } else {
                    imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.addMove("gain\t"+strategy_card_player+"\t"+"secret_objective"+"\t"+"1");
                      for (let i = 0; i < imperium_self.game.players_info.length; i++) { imperium_self.addMove("DEAL\t6\t"+(i+1)+"\t1"); }
                      imperium_self.endTurn();
		    });
		  }
		} else {
                  imperium_self.addMove("gain\t"+strategy_card_player+"\t"+"secret_objective"+"\t"+"1");
                  for (let i = 0; i < imperium_self.game.players_info.length; i++) { imperium_self.addMove("DEAL\t6\t"+(i+1)+"\t1"); }
                  imperium_self.endTurn();
		}
              }, 1);
            });
	  };

	  if (imperium_self.game.planets['new-byzantium'].owner == strategy_card_player) {
	    imperium_self.playerAcknowledgeNotice("You are granted an additional Victory Point for controlling New Byzantium during Imperial Scoring", supplementary_scoring);
	  } else {
	    imperium_self.playerAcknowledgeNotice("As you do not control New Byzantium during Imperial Scoring, you will be issued an additional Secret Objective", supplementary_secret);
	  }
        }

	return 0;
      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        imperium_self.game.state.playing_strategy_card_secondary = 1;

        if (imperium_self.game.player == player) {
          if (imperium_self.game.player != strategy_card_player && imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            imperium_self.playerBuySecretObjective(2);
          } else {
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
            imperium_self.endTurn();
          }
        }

  	return 0;
      },
      strategyTertiaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        imperium_self.game.state.playing_strategy_card_secondary = 1;
        imperium_self.game.state.round_scoring = 1;

	if (player == imperium_self.game.player) {

	  let my_secret_objective = "";
	  let my_secret_vp = "";

          imperium_self.game.state.round_scoring = 2;

          imperium_self.playerScoreSecretObjective(imperium_self, function(x, vp, objective) {

	    my_secret_vp = vp;
	    my_secret_objective = objective;

            imperium_self.playerScoreVictoryPoints(imperium_self, function(x, vp, objective) {

	      imperium_self.updateStatus("scoring completed");
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);

              if (my_secret_vp > 0) { 
		
                if (imperium_self.secret_objectives[my_secret_objective] != undefined) {
                  imperium_self.secret_objectives[my_secret_objective].scoreObjective(imperium_self, player, function() {

		    imperium_self.addMove("score\t"+player+"\t"+my_secret_vp+"\t"+my_secret_objective); 

              	    if (vp > 0) {

        	      if (imperium_self.stage_i_objectives[objective] != undefined) {
        		imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
			  imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	    		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(my_secret_objective);
	      		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
			  imperium_self.endTurn();
			});
        	      }
        	      if (imperium_self.stage_ii_objectives[objective] != undefined) {
        		imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
			  imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	    		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(my_secret_objective);
	      		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
			  imperium_self.endTurn();
			});
        	      } 

		    } else {

	    	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(my_secret_objective);
		      imperium_self.endTurn();

		    }
		  });
                }
		return 0;
	      }

              if (vp > 0) {
        	if (imperium_self.stage_i_objectives[objective] != undefined) {
        	  imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
		    imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	            imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
		    imperium_self.endTurn();
		  });
        	}
        	if (imperium_self.stage_ii_objectives[objective] != undefined) {
        	  imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
		    imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	            imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
		    imperium_self.endTurn();
		  });
        	}
	      } else {

	        imperium_self.endTurn();

	      }
            }, 2);

          });
  	  return 0;
        }
      }
    });




    this.importStrategyCard("leadership", {
      name     			:       "Leadership",
      rank			:	1,
      img			:	"/strategy/INITIATIVE.png",
      text			:	"You may gain and distribute three tokens.<hr />All players may purchase extra tokens at three influence per token." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

	if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {
          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("strategy\t"+"leadership"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
          imperium_self.playerAllocateNewTokens(imperium_self.game.player, 3, 0, 1, 1);
 	}

	return 0;

      },

      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (player == imperium_self.game.player) {
	  if (strategy_card_player != imperium_self.game.player) {
            imperium_self.playerBuyTokens(2);
	    return 0;
 	  } else {
            imperium_self.playerBuyTokens(2);
	    return 0;
	  }
        }

	return 1;

      },

    });




    this.importStrategyCard("politics", {
      name     			:       "Politics",
      rank			:	3,
      img			:	"/strategy/POLITICS.png",
      text			:	"Pick a new Speaker. Gain 2 action cards. Vote on two agendas if New Byzantium is controlled.<hr />Other players may spend a strategy token to purchase two action cards.",
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        //
        // card player goes for primary
        //
        if (imperium_self.game.player === strategy_card_player && player == strategy_card_player) {

          //
          // two action cards
          //
          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("gain\t"+imperium_self.game.player+"\taction_cards"+"\t"+2);
          imperium_self.addMove("DEAL\t2\t"+imperium_self.game.player+"\t2");
          imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " gains action cards");
          imperium_self.addMove("strategy\t"+"politics"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);

          //
          // pick the speaker
          //
          let factions = imperium_self.returnFactions();
          let html = 'Make which player the speaker? <ul>';
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            html += '<li class="option" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
          }
          html += '</ul>';
          imperium_self.updateStatus(html);

          let chancellor = imperium_self.game.player;
          let selected_agendas = [];

          $('.option').off();
          $('.option').on('click', function() {

            let chancellor = (parseInt($(this).attr("id")) + 1);
            let laws = imperium_self.returnAgendaCards();
            let laws_selected = 0;

	    //
	    // if New Byzantium is unoccupied, we skip the voting stage
	    //
	    imperium_self.playerAcknowledgeNotice("You will receive two action cards once other players have decided whether to purchase action cards.", function() {
              imperium_self.addMove("change_speaker\t"+chancellor);
	      imperium_self.endTurn();
	    });
	    return 0;

          });
        }
      },

      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == player) {
          if (imperium_self.game.player != strategy_card_player && imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            imperium_self.playerBuyActionCards(2);
          } else {
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
            imperium_self.endTurn();
          }
        }
      },

      strategyTertiaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        let selected_agendas = [];
        let laws = imperium_self.returnAgendaCards();
        let laws_selected = 0;

        if (imperium_self.game.player == player) {

          //
          // refresh votes --> total available
          //
          imperium_self.game.state.votes_available = [];
          imperium_self.game.state.votes_cast = [];
          imperium_self.game.state.how_voted_on_agenda = [];
          imperium_self.game.state.voted_on_agenda = [];
          imperium_self.game.state.voting_on_agenda = 0;

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            imperium_self.game.state.votes_available.push(imperium_self.returnAvailableVotes(i+1));
            imperium_self.game.state.votes_cast.push(0);
            imperium_self.game.state.how_voted_on_agenda[i] = "abstain";
            imperium_self.game.state.voted_on_agenda[i] = [];
            //
            // add extra 0s to ensure flexibility if extra agendas added
            //
            for (let z = 0; z < imperium_self.game.state.agendas_per_round+2; z++) {
              imperium_self.game.state.voted_on_agenda[i].push(0);
            }
          }
        }


        if (imperium_self.game.player === imperium_self.game.state.speaker) {

            let html = '';
            if (imperium_self.game.state.agendas_per_round == 1) {
              html += 'Select one agenda to advance for consideration in the Galactic Senate.<ul>';
            }
            if (imperium_self.game.state.agendas_per_round == 2) {
              html += 'Select two agendas to advance for consideration in the Galactic Senate.<ul>';
            }
            if (imperium_self.game.state.agendas_per_round == 3) {
              html += 'Select three agendas to advance for consideration in the Galactic Senate.<ul>';
            }

            for (i = 0; i < 3 && i < imperium_self.game.state.agendas.length; i++) {
              html += '<li class="option" id="'+imperium_self.game.state.agendas[i]+'">' + laws[imperium_self.game.state.agendas[i]].name + '</li>';
            }
            html += '</ul>';

            imperium_self.updateStatus(html);

            $('.option').off();
            $('.option').on('mouseenter', function() { let s = $(this).attr("id"); imperium_self.showAgendaCard(s); });
            $('.option').on('mouseleave', function() { let s = $(this).attr("id"); imperium_self.hideAgendaCard(s); });
            $('.option').on('click', function() {

              laws_selected++;
              selected_agendas.push($(this).attr('id'));

              $(this).hide();
              imperium_self.hideAgendaCard(selected_agendas[selected_agendas.length-1]);

              if (laws_selected >= imperium_self.game.state.agendas_per_round) {
                for (i = 1; i >= 0; i--) {
                  imperium_self.addMove("resolve_agenda\t"+selected_agendas[i]);
                  imperium_self.addMove("post_agenda_stage_post\t"+selected_agendas[i]);
                  imperium_self.addMove("post_agenda_stage\t"+selected_agendas[i]);
                  imperium_self.addMove("agenda\t"+selected_agendas[i]+"\t"+i);
                  imperium_self.addMove("pre_agenda_stage_post\t"+selected_agendas[i]);
                  imperium_self.addMove("pre_agenda_stage\t"+selected_agendas[i]);
                  imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
                }
                imperium_self.endTurn();
              }
            });
        } else {

	  imperium_self.updateStatus("The Speaker is selecting two Agendas for consideration by the Senate");

	}
      },

    });




    this.importStrategyCard("technology", {
      name     			:       "Technology",
      rank			:	7,
      img			:	"/strategy/TECH.png",
      text			:	"Research a technology. You may spend 6 resources to research another.<hr />Other players may spend a strategy token and 4 resources to research a technology" ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {
        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {
          imperium_self.playerAcknowledgeNotice("You will first have the option of researching a free-technology, and then invited to purchase an additional tech for 6 resources:", function() {
            imperium_self.playerResearchTechnology(function(tech) {
	      imperium_self.game.players_info[imperium_self.game.player-1].tech.push(tech);
              imperium_self.addMove("resolve\tstrategy");
              imperium_self.addMove("strategy\t"+"technology"+"\t"+strategy_card_player+"\t2");
              imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
              imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
              imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);
              imperium_self.endTurn();
            });
          });
        }
      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

console.log("in secondary!");

	let html = "";
	let resources_to_spend = 0;

        if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) {
 
	  resources_to_spend = imperium_self.game.players_info[imperium_self.game.player-1].cost_of_technology_secondary;
;
          html = '<p>Technology has been played. Do you wish to spend 4 resources and a strategy token to research a technology? </p><ul>';
          if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Technology strategy card. You may spend 4 resources and a strategy token to gain a permanent new unit or ability. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability?</p><ul>`;
          }

	  if (
	    imperium_self.game.players_info[player-1].permanent_research_technology_card_must_not_spend_resources == 1 ||
	    imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 1
	  ) { 
            html = '<p>Technology has been played. Do you wish to spend a strategy token to research a technology? </p><ul>';
	    resources_to_spend = 0;
	  }

	  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
	  if (available_resources >= 4 && imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            html += '<li class="option" id="yes">Yes</li>';
          }
	  html += '<li class="option" id="no">No</li>';
          html += '</ul>';
 
          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {
 
            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();

            let id = $(this).attr("id");

            if (id === "yes") {

	      imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources = 0;
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.playerSelectResources(resources_to_spend, function(success) {
                if (success == 1) {
                  imperium_self.playerResearchTechnology(function(tech) {
                    imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);
                    imperium_self.addMove("expend\t"+imperium_self.game.player+"\tstrategy\t1");
                    imperium_self.endTurn();
                  });
                } else {
                  imperium_self.endTurn();
                }
              });
            }
            if (id === "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
          });

	  return 0;

        } else {

          if (imperium_self.game.player != strategy_card_player) { return 0; }

	  resources_to_spend = imperium_self.game.players_info[imperium_self.game.player-1].cost_of_technology_primary;

          html = '<p>Do you wish to spend '+resources_to_spend+' resources to research an additional technology? </p><ul>';

	  if (
	    imperium_self.game.players_info[player-1].permanent_research_technology_card_must_not_spend_resources == 1 ||
	    imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 1
	  ) { 
            html = '<p>Do you wish to research an additional technology? </p><ul>';
	    resources_to_spend = 0;
	  }

	  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
	  if (available_resources >= resources_to_spend) {
            html += '<li class="option" id="yes">Yes</li>';
	  }
          html += '<li class="option" id="no">No</li>';
          html += '</ul>';

          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {

            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();


            let id = $(this).attr("id");

            if (id == "yes") {
	      imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 0;
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.playerSelectResources(resources_to_spend, function(success) {
                if (success == 1) {
                  imperium_self.playerResearchTechnology(function(tech) {
                    imperium_self.addMove("purchase\t"+imperium_self.game.player+"\ttechnology\t"+tech);
                    imperium_self.endTurn();
                  });
                } else {
                }
              });
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
          });

	  return 0;

        }
      },
    });









    this.importAgendaCard('minister-of-technology', {
        name : "Minister of Technology" ,
        type : "Law" ,
        text : "Elect a player. They do not need to spend resources to research technology when the technology card is played" ,
	initialize : function(imperium_self) {
	  imperium_self.game.state.minster_of_technology = null;
	  imperium_self.game.state.minster_of_technology_player = null;
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_research_technology_card_must_not_spend_resources = 0;
	    imperium_self.game.players_info[i].permanent_research_technology_card_must_not_spend_resources = 0;
	  }
	},
        returnAgendaOptions : function(imperium_self) {
          let options = [];
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            options.push(imperium_self.returnFaction(i+1));
          }
          return options;
        },
        onPass : function(imperium_self, winning_choice) {
	  let player_number = 0;
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (imperium_self.returnFaction(i+1) == winning_choice) { player_number = i; }
	  }
          imperium_self.game.state.minister_of_technology = 1;
          imperium_self.game.state.minister_of_technology_player = player_number+1;
          imperium_self.game.players_info[player_number].permanent_research_technology_card_must_not_spend_resources = 1;

	  imperium_self.game.state.laws.push({ agenda : "minister-of-technology" , option : winning_choice });

        }
  });





    this.importActionCard('unexpected-breakthrough', {
        name : "Unexpected Breakthrough" ,
        type : "action" ,
        text : "Do not spend resources to research technology the next time the Technology card is played" ,
        playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_research_technology_card_must_not_spend_resources = 1;
          return 1;
        }
    });






    this.importStrategyCard("trade", {
      name     			:       "Trade",
      rank			:	5,
      img			:	"/strategy/TRADE.png",
      text			:	"Gain 3 trade goods. Refresh your commodities and those of any other players.<hr />Unrefreshed players may spend a strategy token to refresh their commodities." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("strategy\t"+"trade"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
          imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t3");
          imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tcommodities\t"+imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit);
 
          let factions = imperium_self.returnFactions();
          let html = '<p>You will receive 3 trade goods and '+imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit+' commodities. You may choose to replenish the commodities of any other players: </p><ul>';
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            if (i != imperium_self.game.player-1) {
              html += '<li class="option" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
            }
          }
          html += '<li class="option" id="finish">done</li>';
 
          imperium_self.updateStatus(html);
 
          $('.option').off();
          $('.option').on('click', function() {
            let id = $(this).attr("id");
            if (id != "finish") {
              imperium_self.addMove("purchase\t"+(parseInt(id)+1)+"\tcommodities\t"+imperium_self.game.players_info[id].commodity_limit);
              $(this).hide();
            } else {
              imperium_self.endTurn();
            }
          });

        }

      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) {

	  if (imperium_self.game.players_info[player-1].commodities == imperium_self.game.players_info[player-1].commodity_limit) { 
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	    imperium_self.updateLog(imperium_self.returnFaction(player) + " skips the Trade secondary as they have already refreshed commodities");
            imperium_self.endTurn();
	    return 1;
	  }

          let html = '<p>Trade has been played. Do you wish to spend 1 strategy token to refresh your commodities? </p><ul>';
          if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Trade strategy card. You may spend 1 strategy token to refresh your faction commodities, which may be exchanged with your neighbours on the board for trade goods. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
          }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            html += '<li class="option" id="yes">Yes</li>';
          }
          html += '<li class="option" id="no">No</li>';
	  html += '</ul>';


	  if (imperium_self.game.players_info[imperium_self.game.player-1].commodities == imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit) {
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
	    imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " already has commodities and skips trade secondary");
	    imperium_self.endTurn();
	    return 0;
	  }


          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {
 
            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();

            $('.option').off();
            let id = $(this).attr("id");

            if (id == "yes") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tcommodities\t"+imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tstrategy\t1");
	      imperium_self.endTurn();
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
 
          });
        }
      },
    });


    this.importStrategyCard("warfare", {
      name     			:       "Warfare",
      rank			:	6,
      img			:	"/strategy/MILITARY.png",
      text			:	"De-activate a sector. Gain and distribute 1 free token.<hr />Other players may spend a strategy token to producein their home system" ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

          imperium_self.updateStatus('Select sector to de-activate.');
          imperium_self.playerSelectSector(function(sector) {

	    let sys = imperium_self.returnSectorAndPlanets(sector);

            imperium_self.addMove("resolve\tstrategy");
            imperium_self.addMove("strategy\t"+"warfare"+"\t"+strategy_card_player+"\t2");
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
            imperium_self.addMove("deactivate\t"+strategy_card_player+"\t"+sector);
            imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(strategy_card_player)+" deactivates "+sys.s.name);
            imperium_self.playerAllocateNewTokens(imperium_self.game.player, 1, 0, 3, 0);
          });
    
        }

      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) { 

          let html = '<p>Do you wish to spend 1 strategy token to produce in your home sector? </p><ul>';
          if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Warfare strategy card. You may spend 1 strategy token to produce in your Homeworld without activating the sector. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
          }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0 ) { 
            html += '<li class="option" id="yes">Yes</li>';
	  }
          html += '<li class="option" id="no">No</li>';
          html += '</ul>';
 
          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {

            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();

            let id = $(this).attr("id");
 
            if (id == "yes") {
              imperium_self.playerProduceUnits(imperium_self.game.players_info[imperium_self.game.player-1].homeworld, 0, 0, 2, 1); // final is warfare card
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
 
          });
        }
      },
    });


  this.importSecretObjective('military-catastrophe', {
      name 		: 	"Military Catastrophe" ,
      text		:	"Destroy the flagship of another player" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_military_catastrophe = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
        if (imperium_self.game.players_info[imperium_self.game.player-1].units_i_destroyed_this_combat_round.includes("flagship")) {
	  imperium_self.game.state.secret_objective_military_catastrophe = 1;
	}
        return 0; 
      },
      groundCombatRoundEnd :	function(imperium_self, attacker, defender, sector, planet_idx) {
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_military_catastrophe == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('flagship-dominance', {
      name 		: 	"Blood Christening" ,
      text		:	"Achieve victory in a space combat in a system containing your flagship. Your flagship must survive this combat" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_flagship_dominance = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
	if (imperium_self.doesSectorContainPlayerUnit(imperium_self.game.player, sector, "flagship")) { 
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  if (sys.s.units[defender-1].length == 0) {
	    if (attacker == imperium_self.game.player && sys.s.units[attacker-1].length > 0) {
	      imperium_self.game.state.secret_objective_flagship_dominance = 1;
	    }
	  }
	  if (sys.s.units[attacker-1].length == 0) {
	    if (defender == imperium_self.game.player && sys.s.units[defender-1].length > 0) {
	      imperium_self.game.state.secret_objective_flagship_dominance = 1;
	    }
	  }
	}
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_flagship_dominance == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });



  this.importSecretObjective('nuke-them-from-orbit', {
      name 		: 	"Nuke them from Orbit" ,
      text		:	"Destroy the last of a player's ground forces using bombardment" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_nuke_from_orbit = 0;
	imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = 0;
        return 0; 
      },
      bombardmentTriggers :	function(imperium_self, player, bombarding_player, sector, planet_idx) {
	imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = 0;
	let sys = imperium_self.returnSectorAndPlanets(sector);
	let planet = sys.p[planet_idx];
	let infantry_on_planet = imperium_self.returnInfantryOnPlanet(planet);
	for (let i = 0; i < planet.units.length; i++) {
	  if (planet.units[i].length > 0) {
	    if ((i+1) != bombarding_player) {
	      defender = i+1;
	      imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = infantry_on_planet;
	    }
	  }
	}
	return 0;
      },
      planetaryDefenseTriggers :  function(imperium_self, player, sector, planet_idx) {
	if (imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked > 0) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
console.log("PIDX: " + planet_idx);
	  let planet = sys.p[planet_idx];
console.log("PLANET: " + JSON.stringify(planet));
	  let infantry_on_planet = imperium_self.returnInfantryOnPlanet(planet);
	  if (infantry_on_planet == 0) {
	    imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = 1;
	  }
	}
	return 0;
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_nuke_from_orbit == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('anti-imperialism', {
      name 		: 	"Anti-Imperialism" ,
      text		:	"Achieve victory in combat with a player with the most VP" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_anti_imperialism = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
        imperium_self.game.state.secret_objective_anti_imperialism = 0;
	let sys = imperium_self.returnSectorAndPlanets(sector);
	let players_with_most_vp = imperium_self.returnPlayersWithHighestVP();

	if (imperium_self.game.player == attacker && sys.s.units[attacker-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(attacker, sector) == 0) {
	    if (players_with_most_vp.includes(defender)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; } 
	  }
	}
	if (imperium_self.game.player == defender && sys.s.units[defender-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(defender, sector) == 0) {
	    if (players_with_most_vp.includes(attacker)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; }
	  }
	}
        return 0; 
      },
      groundCombatRoundEnd :	function(imperium_self, attacker, defender, sector, planet_idx) {
        let sys = imperium_self.returnSectorAndPlanets(sector);
        let planet = sys.p[planet_idx];
	let players_with_most_vp = imperium_self.returnPlayersWithHighestVP();

	if (imperium_self.game.player == attacker && planet.units[attacker-1].length > 0) {
	  if (planet.units[defender-1].length == 0) {
	    if (players_with_most_vp.includes(defender)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; } 
	  }
	}
	if (imperium_self.game.player == defender && planet.units[defender-1].length > 0) {
	  if (planet.units[attacker-1].length == 0) {
	    if (players_with_most_vp.includes(attacker)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; }
	  }
	}
	return 0;
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_anti_imperialism == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('end-their-suffering', {
      name 		: 	"End Their Suffering" ,
      text		:	"Eliminate a player with the lowest VP from the board in Space or Ground Combat" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_end_their_suffering = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);
	let players_with_lowest_vp = imperium_self.returnPlayersWithLowestVP();

	if (imperium_self.game.player == attacker) {
	  if (sys.s.units[defender-1].length == 0) {
	    if (players_with_lowest_vp.includes(defender)) { 
	      // does the player have any units left?
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[defender-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[defender-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
	if (imperium_self.game.player == defender) {
	  if (sys.s.units[attacker-1].length == 0) {
	    if (players_with_lowest_vp.includes(attacker)) { 
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[attacker-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[attacker-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
        return 0; 
      },
      groundCombatRoundEnd :	function(imperium_self, attacker, defender, sector, planet_idx) {
        let sys = imperium_self.returnSectorAndPlanets(sector);
        let planet = sys.p[planet_idx];
	let players_with_lowest_vp = imperium_self.returnPlayersWithLowestVP();

	if (imperium_self.game.player == attacker) {
	  if (planet.units[defender-1].length == 0) {
	    if (players_with_lowest_vp.includes(defender)) { 
	      // does the player have any units left?
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[defender-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[defender-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
	if (imperium_self.game.player == defender) {
	  if (planet.units[attacker-1].length == 0) {
	    if (players_with_lowest_vp.includes(attacker)) { 
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[attacker-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[attacker-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_end_their_suffering == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });




  this.importSecretObjective('establish-a-blockade', {
      name 		: 	"Establish a Blockade" ,
      text		:	"Have at least 1 ship in the same sector as an opponent's spacedock",
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	for (let i in imperium_self.game.sectors) {
	  if (imperium_self.game.sectors[i].units[player-1].length > 0) {
	    let sys = imperium_self.returnSectorAndPlanets(i);
	    for (let p = 0; p < sys.p.length; p++) {
	      for (let b = 0; b < sys.p[p].units.length; b++) {
	 	if ((b+1) != player) {
	          for (let bb = 0; bb < sys.p[p].units[b].length; bb++) {
		    if (sys.p[p].units[b][bb].type === "spacedock") { return 1; }
		  }
		}
	      }
	    }
	  }
	}
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });

  this.importSecretObjective('close-the-trap', {
      name 		: 	"Close the Trap" ,
      text		:	"Destroy another player's last ship in a system using a PDS" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_close_the_trap = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);
	if (imperium_self.game.player == attacker && sys.s.units[attacker-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(attacker, sector) == 0) {
	    imperium_self.game.state.secret_objective_close_the_trap = 1;
	  }
	}
	if (imperium_self.game.player == defender && sys.s.units[defender-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(defender, sector) == 0) {
	    imperium_self.game.state.secret_objective_close_the_trap = 1;
	  }
	}

        if (imperium_self.game.players_info[imperium_self.game.player-1].units_i_destroyed_this_combat_round.includes("flagship")) {
	  imperium_self.game.state.secret_objective_military_catastrophe = 1;
	}
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_close_the_trap == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('galactic-observer', {
      name 		: 	"Galactic Observer" ,
      text		:	"Have at least 1 ship in 6 different sectors" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let ships_in_systems = 0;
	for (let i in imperium_self.game.board) {
	  let sector = imperium_self.game.board[i].tile;
	  if (imperium_self.doesSectorContainPlayerShip(player, sector)) {
	    ships_in_systems++;
	  }
	}

	if (ships_in_systems > 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });



  this.importSecretObjective('master-of-the-ion-cannon', {
      name 		: 	"Master Cannoneer" ,
      text		:	"Have at least 4 PDS units in play" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let pds_units_in_play = 0;

	for (let i in imperium_self.game.planets) {
	  let planet = imperium_self.game.planets[i];
	  for (let ii = 0; ii < planet.units[player-1].length; ii++) {
	    if (planet.units[player-1][ii].type == "pds") {
	      pds_units_in_play++;
	    }
	  }
	}

	if (pds_units_in_play > 3) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('war-engine', {
      name 		: 	"War Engine" ,
      text		:	"Have three spacedocks in play" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let docks_in_play = 0;

	for (let i in imperium_self.game.planets) {
	  let planet = imperium_self.game.planets[i];
	  for (let ii = 0; ii < planet.units[player-1].length; ii++) {
	    if (planet.units[player-1][ii].type == "spacedock") {
	      docks_in_play++;
	    }
	  }
	}

	if (docks_in_play > 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });

  this.importSecretObjective('wormhole-administrator', {
      name 		: 	"Wormhole Administrator" ,
      text		:	"Have at least 1 ship in systems containing alpha and beta wormholes respectively" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let relevant_sectors = imperium_self.returnSectorsWithPlayerShips(player);
	let alpha = 0;
	let beta = 0;
	for (let i = 0; i < relevant_sectors.length; i++) {
	  if (imperium_self.game.sectors[relevant_sectors[i]].wormhole == 1) { alpha = 1; }
	  if (imperium_self.game.sectors[relevant_sectors[i]].wormhole == 2) { beta = 1; }
	}
	if (alpha == 1 && beta == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('fleet-of-terror', {
      name 		: 	"Fleet of Terror" ,
      text		:	"Have five dreadnaughts in play" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let dreadnaughts = 0;
	let relevant_sectors = imperium_self.returnSectorsWithPlayerShips(player);
	for (let i = 0; i < relevant_sectors.length; i++) {
	  for (let ii = 0; ii < imperium_self.game.sectors[relevant_sectors[i]].units[player-1].length; ii++) {
	    if (imperium_self.game.sectors[relevant_sectors[i]].units[player-1][ii].type === "dreadnaught") {
	      dreadnaughts++;
	    }
	  }
	}
	if (dreadnaughts >= 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('cultural-diplomacy', {
      name 		: 	"Cultural Diplomacy" ,
      text		:	"Control at least 4 cultural planets" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let cultural = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();
        for (let i = 0; i < planetcards.length; i++) { if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; } }
        if (cultural >= 4) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('act-of-espionage', {
      name 		: 	"Act of Espionage" ,
      text		:	"Discard five action cards from your hard" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.returnPlayerActionCards(player).length >= 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	if (imperium_self.game.player == player) {
	  imperium_self.playerDiscardActionCards(5, function() {
	    mycallback(1);
	  });
	} else {
	  mycallback(0);
	}
      }
  });


  this.importSecretObjective('space-to-breathe', {
      name 		: 	"Space to Breathe" ,
      text		:	"Have at least 1 ship in 3 systems with no planets" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let relevant_sectors = imperium_self.returnSectorsWithPlayerShips(player);
	let sectors_without_planets = 0;
	for (let i = 0; i < relevant_sectors.length; i++) {
	  if (imperium_self.game.sectors[relevant_sectors[i]].planets.length == 0) { sectors_without_planets++; }
	}
	if (sectors_without_planets >= 3) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('ascendant-technocracy', {
      name 		: 	"Ascendant Technocracy" ,
      text		:	"Research 4 tech upgrades on the same color path" , 
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {

        let techlist = imperium_self.game.players_info[player-1].tech;

        let greentech = 0;
        let bluetech = 0;
        let redtech = 0;
        let yellowtech = 0;

        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].color == "blue") { bluetech++; }
          if (imperium_self.tech[techlist[i]].color == "red") { redtech++; }
          if (imperium_self.tech[techlist[i]].color == "yellow") { yellowtech++; }
          if (imperium_self.tech[techlist[i]].color == "green") { greentech++; }
        }

        if (bluetech >= 4) { return 1; }
        if (yellowtech >= 4) { return 1; }
        if (redtech >= 4) { return 1; }
        if (greentech >= 4) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        mycallback(1);
      },
  });



  this.importSecretObjective('penal-colonies', {
      name 		: 	"Penal Colonies" ,
      text		:	"Control four planets with hazardous conditions" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let hazardous = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();
        for (let i = 0; i < planetcards.length; i++) { if (imperium_self.game.planets[planetcards[i]].type === "hazardous")   { hazardous++; } }
        if (hazardous >= 4) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('master-of-production', {
      name 		: 	"Master of Production" ,
      text		:	"Control four planets with industrial civilizations" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let industrial = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();
        for (let i = 0; i < planetcards.length; i++) { if (imperium_self.game.planets[planetcards[i]].type === "industrial")   { industrial++; } }
        if (industrial >= 4) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('faction-technologies', {
      name 		: 	"Faction Technologies" ,
      text		:	"Research 2 faction technologies" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let techlist = imperium_self.game.players_info[player-1].tech;
        let factiontech = 0;
        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].type == "normal" && techlist[i].indexOf("faction") == 0) { factiontech++; }
        }
        if (factiontech >= 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('occupy-new-byzantium', {
      name 		: 	"Occupy New Byzantium" ,
      text		:	"Control New Byzantium and have at least 3 ships protecting the sector" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.planets['new-byzantium'].owner == player) {
	  if (imperium_self.game.sectors['new-byzantium'].units[player-1].length >= 3) { return 1; }
	}
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('cast-a-long-shadow', {
      name 		: 	"Cast a Long Shadow" ,
      text		:	"Have at least 1 ship in a system adjacent to an opponent homeworld" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {

 	// 1_1, 4_7, etc.
	let homeworlds = imperium_self.returnHomeworldSectors(imperium_self.game.players_info.length);
	let sectors = [];

	for (let i = 0; i < homeworlds.length; i++) {
	  if (imperium_self.game.board[homeworlds[i]].tile != imperium_self.game.board[imperium_self.game.players_info[player-1].homeworld].tile) {
	    sectors.push(imperium_self.game.board[homeworlds[i]].tile);
	  }
	}

	for (let i = 0; i < sectors.length; i++) {
	  if (imperium_self.isPlayerAdjacentToSector(player, sectors[i])) { return 1; }
	}
       
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });






/***
  this.importStageIPublicObjective('manage-to-breathe', {
      name 	: 	"Deep Breathing" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Just score this for free..." ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	return 1;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
***/

  this.importStageIPublicObjective('planetary-unity', {
      name 	: 	"Planetary Unity" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Control four planets of the same planet type" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

	let hazardous = 0;
	let cultural = 0;
	let industrial = 0;

	let planetcards = imperium_self.returnPlayerPlanetCards(player);

	for (let i = 0; i < planetcards.length; i++) {
	  let p = imperium_self.game.planets[planetcards[i]];
	  if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
	  if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
	  if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
	}

	if (hazardous >= 4 || cultural >= 4 || industrial >= 4) { return 1; }

	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('forge-of-war', {
      name 	: 	"Forge of War" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Research 2 unit upgrade technologies" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	let techlist = imperium_self.game.players_info[player-1].tech;
	let unit_upgrades = 0;
	for (let i = 0; i < techlist.length; i++) {
	  if (imperium_self.tech[techlist[i]].unit == 1) {
	    unit_upgrades++;
	  }
	}
	if (unit_upgrades >= 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('diversified-research', {
      name 	: 	"Diversified Research" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Research 2 technologies in two different color paths" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

	let techlist = imperium_self.game.players_info[player-1].tech;

	let greentech = 0;
	let bluetech = 0;
	let redtech = 0;
	let yellowtech = 0;

	for (let i = 0; i < techlist.length; i++) {
	  if (imperium_self.tech[techlist[i]].color == "blue") { bluetech++; }
	  if (imperium_self.tech[techlist[i]].color == "red") { redtech++; }
	  if (imperium_self.tech[techlist[i]].color == "yellow") { yellowtech++; }
	  if (imperium_self.tech[techlist[i]].color == "green") { greentech++; }
	}

	let achieve_two = 0;
	
	if (bluetech >= 2) { achieve_two++; }
	if (yellowtech >= 2) { achieve_two++; }
	if (redtech >= 2) { achieve_two++; }
	if (greentech >= 2) { achieve_two++; }

	if (achieve_two >= 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('mining-conglomerate', {
      name 	: 	"Mining Conglomerate" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend eight resources when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if (imperium_self.returnAvailableResources(player) >= 8) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectResources(8, function(success) {
	    mycallback(success);
          });
	} else {
	  mycallback(0);
	}
      },
  });
  this.importStageIPublicObjective('conquest-of-science', {
      name 	: 	"Conquest of Science" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Control 3 planets with tech specialities" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let techbonuses = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (planetcards[i].bonus == "red") { techbonuses++; }
          if (planetcards[i].bonus == "blue") { techbonuses++; }
          if (planetcards[i].bonus == "green") { techbonuses++; }
          if (planetcards[i].bonus == "yellow") { techbonuses++; }
        }

	if (techbonuses >= 3) { return 1; }

	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('colonization', {
      name 	: 	"Colonization" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Control six planets outside your home system" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let hazardous = 0;
        let cultural = 0;
        let industrial = 0;
        let diplomatic = 0;

        let planetcards = imperium_self.returnPlayerPlanetCards(player);

        for (let i = 0; i < planetcards.length; i++) {
          if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
          if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
          if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
          if (imperium_self.game.planets[planetcards[i]].type === "diplomatic") { diplomatic++; }
        }

        if ((cultural+hazardous+industrial+diplomatic) >= 6) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });


  this.importStageIPublicObjective('grand-gesture', {
      name 	: 	"A Grand Gesture" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend 3 command or strategy tokens when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if ((imperium_self.game.players_info[player-1].strategy_tokens + imperium_self.game.players_info[player-1].command_tokens) >= 3) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectStrategyAndCommandTokens(3, function(success) {
	    mycallback(success);
          });
	} else {
	  mycallback(0);
	}
      },
  });


  this.importStageIPublicObjective('establish-trade-outposts', {
      name 	: 	"Establish Trade Outposts" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend 5 trade goods when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if (imperium_self.returnAvailableTradeGoods(player) >= 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        imperium_self.game.players_info[player-1].goods -= 5;
	imperium_self.displayFactionDashboard();
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('pecuniary-diplomacy', {
      name 	: 	"Pecuniary Diplomacy" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend 8 influence when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if (imperium_self.returnAvailableInfluence(player) >= 8) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectInfluence(8, function(success) {
	    mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });




  this.importStageIIPublicObjective('master-of-commerce', {
      name 	: 	"Master of Commerce" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 10 trade goods when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if (imperium_self.returnAvailableTradeGoods(player) >= 10) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        imperium_self.game.players_info[player-1].goods -= 10;
	imperium_self.displayFactionDashboard();
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('display-of-dominance', {
      name 	: 	"Display of Dominance" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control at least 1 planet in another player's home sector" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

	let homeworlds = [];
	let homeplanets = [];
	for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	  let home_sector = imperium_self.game.board[imperium_self.game.players_info[player-1].homeworld].tile;
	  let sys = imperium_self.returnSectorAndPlanets(home_sector);
	  for (let ii = 0; ii < sys.p.length; ii++) {
	    homeplanets.push(sys.p[ii].name);
	  }
	}

        let planetcards = imperium_self.returnPlayerPlanetCards();

	for (let i = 0; i < planetcards.length; i++) {
	  if (homeplanets.includes(planetcards[i].name)) { return 1; }
	}

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('technological-empire', {
      name 	: 	"Technological Empire" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control 5 planets with tech bonuses" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let techbonuses = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (planetcards[i].bonus == "red") { techbonuses++; }
          if (planetcards[i].bonus == "blue") { techbonuses++; }
          if (planetcards[i].bonus == "green") { techbonuses++; }
          if (planetcards[i].bonus == "yellow") { techbonuses++; }
        }

        if (techbonuses >= 3) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('establish-galactic-currency', {
      name 	: 	"Establish Galactic Currency" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 16 resources when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if (imperium_self.returnAvailableResources(player) >= 16) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectResources(16, function(success) {
	    mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });
  this.importStageIIPublicObjective('master-of-science', {
      name 	: 	"Master of Science" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Own 2 tech upgrades in each of 4 tech color paths" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let techlist = imperium_self.game.players_info[player-1].tech;

        let greentech = 0;
        let bluetech = 0;
        let redtech = 0;
        let yellowtech = 0;

        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].color == "blue") { bluetech++; }
          if (imperium_self.tech[techlist[i]].color == "red") { redtech++; }
          if (imperium_self.tech[techlist[i]].color == "yellow") { yellowtech++; }
          if (imperium_self.tech[techlist[i]].color == "green") { greentech++; }
        }

        let achieve_two = 0;

        if (bluetech >= 2) { achieve_two++; }
        if (yellowtech >= 2) { achieve_two++; }
        if (redtech >= 2) { achieve_two++; }
        if (greentech >= 2) { achieve_two++; }

        if (achieve_two >= 4) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },

  });
  this.importStageIIPublicObjective('imperial-unity', {
      name 	: 	"Imperial Unity" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control 6 planets of the same planet type" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let hazardous = 0;
        let cultural = 0;
        let industrial = 0;
        let diplomatic = 0;

        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
          if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
          if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
          if (imperium_self.game.planets[planetcards[i]].type === "diplomatic")   { diplomatic++; }
        }

        if (hazardous >= 6 || cultural >= 6 || industrial >= 6 || diplomatic >= 6) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        mycallback(1);
      },
  });
  this.importStageIIPublicObjective('advanced-technologies', {
      name 	: 	"Advanced Technologies" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Research 3 unit upgrade technologies" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        let techlist = imperium_self.game.players_info[player-1].tech;
        let unit_upgrades = 0;
        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].unit == 1) {
            unit_upgrades++;
          }
        }
        if (unit_upgrades >= 3) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('colonial-dominance', {
      name 	: 	"Colonial Dominance" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control 11 planets outside your home system" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let hazardous = 0;
        let cultural = 0;
        let industrial = 0;
        let diplomatic = 0;

        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
          if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
          if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
          if (imperium_self.game.planets[planetcards[i]].type === "diplomatic")   { diplomatic++; }
        }

        if ((cultural+hazardous+industrial+diplomatic) >= 11) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('power-broker', {
      name 	: 	"Power Broker" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 16 influence when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if (imperium_self.returnAvailableInfluence(player) >= 16) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectInfluence(16, function(success) {
            mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });
  this.importStageIIPublicObjective('cultural-revolution', {
      name 	: 	"Cultural Revolution" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 6 command or strategy tokens when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if ((imperium_self.game.players_info[player-1].strategy_tokens + imperium_self.game.players_info[player-1].command_tokens) >= 6) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectStrategyAndCommandTokens(6, function(success) {
            mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });
  
  
  

  this.importAgendaCard('shard-of-the-throne', {
  	name : "Shard of the Throne" ,
  	type : "Law" ,
	elect : "player" ,
  	text : "Elect a Player to earn 1 VP. When this player loses a space combat to another player, they transfer the VP to that player" ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.shard_of_the_throne = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.shard_of_the_throne_player = i+1;
	    }
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "shard-of-the-throne";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

          imperium_self.game.players_info[imperium_self.game.state.shard_of_the_throne_player-1].vp += 1;
	  imperium_self.updateLeaderboard();
	  imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.shard_of_the_throne_player) + " gains the Shard of the Throne (1VP)");

	},
        repealAgenda(imperium_self) {

	  //
	  // remove from active play
	  //
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	    if (imperium_self.game.state.laws[i].agenda === "shard-of-the-throne") {
	      imperium_self.game.state.laws.splice(i, 1);
	      i--;
	    }  
	  }

	  //
	  // unset the player
	  //
	  imperium_self.game.state.shard_of_the_throne_player = -2;

	  return 1;

        },
        spaceCombatRoundEnd : function(imperium_self, attacker, defender, sector) {
	  if (defender == imperium_self.game.state.shard_of_the_throne_player) {
	    if (!imperium_self.doesPlayerHaveShipsInSector(defender, sector)) {
	      imperium_self.game.state.shard_of_the_throne_player = attacker;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.shard_of_the_throne_player) + " gains the Shard of the Throne (1VP)");
	      imperium_self.game.players_info[attacker-1].vp += 1;
	      imperium_self.game.players_info[defender-1].vp -= 1;
	      imperium_self.updateLeaderboard();
	    }
	  }
	},
	groundCombatRoundEnd : function(imperium_self, attacker, defender, sector, planet_idx) {
	  if (defender == imperium_self.game.state.shard_of_the_throne_player) {
	    if (!imperium_self.doesPlayerHaveInfantryOnPlanet(defender, sector, planet_idx)) {
	      imperium_self.game.state.shard_of_the_throne_player = attacker;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.shard_of_the_throne_player) + " gains the Shard of the Throne (1VP)");
	      imperium_self.game.players_info[attacker-1].vp += 1;
	      imperium_self.game.players_info[defender-1].vp -= 1;
	      imperium_self.updateLeaderboard();
	    }
	  }
	},
  });


  this.importAgendaCard('homeland-defense-act', {
  	name : "Homeland Defense Act" ,
  	type : "Law" ,
  	text : "FOR: there is no limit to the number of PDS units on a planet. AGAINST: each player must destroy one PDS unit" ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.homeland_defense_act = 1;
	  let law_to_push = {};
	      law_to_push.agenda = "homeland-defense-act";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

          if (winning_choice === "for") {
	    imperium_self.game.state.pds_limit_per_planet = 100;
	  }

          if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.doesPlayerHaveUnitOnBoard((i+1), "pds")) {
	        imperium_self.game.queue.push("destroy_a_pds\t"+(i+1));
	      }
	    }
	  }

	  imperium_self.game.state.laws.push({ agenda : "homeland-defense-act" , option : winning_choice });

	},
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "homeland-defense-act") {
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the player
          //
          imperium_self.game.state.homeland_defense_act = 0;
	  imperium_self.game.state.pds_limit_per_planet = 2; // limit back

          return 1;

        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "destroy_a_pds") {

            let player = parseInt(mv[1]);
	    imperium_self.game.queue.splice(qe, 1);

	    if (imperium_self.game.player == player) {
              imperium_self.playerSelectUnitWithFilter(
                    "Select a PDS unit to destroy: ",
                    function(unit) {
		      if (unit == undefined) { return 0; }
                      if (unit.type == "pds") { return 1; }
                      return 0;
            	    },
                    function(unit_identifier) {

                      let sector        = unit_identifier.sector;
                      let planet_idx    = unit_identifier.planet_idx;
                      let unit_idx      = unit_identifier.unit_idx;
                      let unit          = unit_identifier.unit;

		      if (unit == null) {
                        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " has no PDS units to destroy");
		        imperium_self.endTurn();
			return 0;
		      }
                      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit.name + " in " + imperium_self.game.sectors[sector].name);
		      imperium_self.endTurn();
                    }
              );
	    }

            return 0;
          }
          return 1;
        }
  });




  this.importAgendaCard('holy-planet-of-ixth', {
  	name : "Holy Planet of Ixth" ,
  	type : "Law" ,
	elect : "planet" ,
  	text : "Elect a cultural planet. The planet's controller gains 1 VP. Units cannot be landed, produced or placed on this planet" ,
        returnAgendaOptions : function(imperium_self) {
	  return imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "cultural") { return 1; } return 0; 
	  });
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.holy_planet_of_ixth = 1;
	  imperium_self.game.state.holy_planet_of_ixth_planet = winning_choice;
	  let law_to_push = {};
	      law_to_push.agenda = "holy-planet-of-ixth";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  //
	  // lock the planet
	  //
	  imperium_self.game.planets[winning_choice].locked = 1;

	  //
	  // issue VP to controller
	  //
	  let owner = imperium_self.game.planets[winning_choice].owner;
	  if (owner != -1) {
	    imperium_self.game.players_info[owner-1].vp += 1;
	    imperium_self.updateLeaderboard();
	    imperium_self.updateLog(imperium_self.returnFaction(owner) + " gains 1 VP from Holy Planet of Ixth");
	  }

	},
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
	  let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "holy-planet-of-ixth") {
	      winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the player
          //
	  if (winning_choice != null) {
            imperium_self.game.state.holy_planet_of_ixth = 0;
            imperium_self.game.state.holy_planet_of_ixth_planet = -1;
	    imperium_self.game.planets[winning_choice].locked = 0;
	  }

          return 1;

        },
  });



  this.importAgendaCard('research-team-biotic', {
        name : "Research Team: Biotic" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an industrial planet. The owner may exhaust this planet to ignore 1 green technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-biotic") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_biotic = 0;
            imperium_self.game.state.research_team_biotic_planet = -1;
          }

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_biotic = 1;
          imperium_self.game.state.research_team_biotic_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-biotic";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].owner == player) {
            return { event : 'research_team_biotic', html : '<li class="option" id="research_team_biotic">use biotic (green) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_green_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].exhausted = 1;
	  }
          return 0;
        }
  });


  this.importAgendaCard('research-team-cybernetic', {
        name : "Research Team: Cybernetic" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an industrial planet. The owner may exhaust this planet to ignore 1 yellow technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_cybernetic = 1;
          imperium_self.game.state.research_team_cybernetic_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-cybernetic";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
	repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-cybernetic") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_cybernetic = 0;
            imperium_self.game.state.research_team_cybernetic_planet = -1;
          }

          return 1;

        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].owner == player) {
            return { event : 'research_team_cybernetic', html : '<li class="option" id="research_team_cybernetic">use cybernetic (yellow) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_yellow_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].exhausted = 1;
	  }
          return 0;
        }
  });


  this.importAgendaCard('research-team-propulsion', {
        name : "Research Team: Propulsion" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an industrial planet. The owner may exhaust this planet to ignore 1 blue technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-propulsion") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_propulsion = 0;
            imperium_self.game.state.research_team_propulsion_planet = -1;
          }

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_propulsion = 1;
          imperium_self.game.state.research_team_propulsion_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-propulsion";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].owner == player) {
            return { event : 'research_team_propulsion', html : '<li class="option" id="research_team_propulsion">use propulsion (blue) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_blue_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].exhausted = 1;
	  }
          return 0;
        }
  });


  this.importAgendaCard('research-team-warfare', {
        name : "Research Team: Warfare" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an hazardous planet. The owner may exhaust this planet to ignore 1 red technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-warfare") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_warfare = 0;
            imperium_self.game.state.research_team_warfare_planet = -1;
          }

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_warfare = 1;
          imperium_self.game.state.research_team_warfare_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-warfare";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].owner == player) {
            return { event : 'research_team_warfare', html : '<li class="option" id="research_team_warfare">use warfare (red) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_red_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].exhausted = 1;
	  }
          return 0;
        }
  });



  this.importAgendaCard('demilitarized-zone', {
  	name : "Demilitarized Zone" ,
  	type : "Law" ,
	elect : "planet" ,
  	text : "Elect a cultural planet. All units are destroyed and cannot be landed, produced or placed on this planet" ,
        returnAgendaOptions : function(imperium_self) {
	  return imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "cultural") { return 1; } return 0; 
	  });
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.demilitarized_zone = 1;
	  imperium_self.game.state.demilitarized_zone_planet = winning_choice;
	  let law_to_push = {};
	      law_to_push.agenda = "demilitarized-zone";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  imperium_self.game.planets[winning_choice].units = []; 
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.planets[winning_choice].units.push([]);
	  }

	  imperium_self.game.planets[winning_choice].locked = 1;

	},
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "demilitarized-zone") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.demilitarized_zone = 0;
            imperium_self.game.state.demilitarized_zone_planet = -1;
	    imperium_self.game.planets[winning_choice].locked = 0;
          }

          return 1;

        },
  });

  this.importAgendaCard('core-mining', {
  	name : "Core Mining" ,
  	type : "Law" ,
	elect : "planet" ,
  	text : "Elect a hazardous planet. Destroy half the infantry on that planet and increase its resource value by +2" ,
        returnAgendaOptions : function(imperium_self) {
	  return imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "hazardous") { return 1; } return 0; 
	  });
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "core-mining") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }


          if (winning_choice != null) {
            imperium_self.game.state.core_mining = 0;
            imperium_self.game.state.core_mining_planet = -1;
	    imperium_self.game.planets[winning_choice].locked = 0;
	    imperium_self.game.planets[winning_choice].resources -= 2;
          }
          return 1;

        },
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.core_mining = 1;
	  imperium_self.game.state.core_mining_planet = winning_choice;
	  let law_to_push = {};
	      law_to_push.agenda = "core-mining";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  let options = imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "hazardous") { return 1; } return 0; 
	  });

	  //
	  // also - destroy the planet and increase its resource value
	  //
	  //let planetidx = options[winning_choice];
	  let planetidx = winning_choice;

	  for (let i = 0; i < imperium_self.game.planets[planetidx].units.length; i++) {
	    let destroy = 1;
	    for (let ii = 0; ii < imperium_self.game.planets[planetidx].units[i].length; ii++) {
	      if (imperium_self.game.planets[planetidx].units[i][ii].type == "infantry") {
	        if (destroy == 1) {
	          imperium_self.game.players[planetidx].units[i].splice(ii, 1);
		  ii--;
		  destroy = 0;
		} else {
		  destroy = 1;
		}
	      }
	    }
	  }

	  imperium_self.game.planets[winning_choice].resources += 2;

	}
  });



  this.importAgendaCard('anti-intellectual-revolution', {
  	name : "Anti-Intellectual Revolution" ,
  	type : "Law" ,
  	text : "FOR: players must destroy a capital ship in order to play the Technology card. AGAINST: at the start of the next round, each player exhausts one planet for each technology they have." ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "anti-intellectual-revolution") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          let techcard = imperium_self.strategy_cards['technology'];
	  if (techcard.strategyPrimaryEventBackup) { techcard.strategyPrimaryEvent = techcard.strategyPrimaryEventBackup; }
	  if (techcard.strategySecondaryEventBackup) { techcard.strategySecondaryEvent = techcard.strategySecondaryEventBackup; }

          return 1;

        },
	initialize : function(imperium_self, winning_choice) {

          if (winning_choice === "for") {

            let techcard = imperium_self.strategy_cards['technology'];

            let old_tech_sec = techcard.strategySecondaryEvent;
            let new_tech_sec = function(imperium_self, player, strategy_card_player) {
	      if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) {
                imperium_self.playerAcknowledgeNotice("Anti-Intellectual Revolution is in play. Do you wish to destroy a capital ship to research technology?", function() {

                  imperium_self.playerSelectUnitWithFilter(
                    "Select a capital ship to destroy: ",
                    function(ship) {
                      if (ship.type == "destroyer") { return 1; }
                      if (ship.type == "cruiser") { return 1; }
                      if (ship.type == "carrier") { return 1; }
                      if (ship.type == "dreadnaught") { return 1; }
                      if (ship.type == "flagship") { return 1; }
                      if (ship.type == "warsun") { return 1; }
                      return 0;
                    },

                    function(unit_identifier) {

                      let sector        = unit_identifier.sector;
                      let planet_idx    = unit_identifier.planet_idx;
                      let unit_idx      = unit_identifier.unit_idx;
                      let unit          = unit_identifier.unit;

                      if (planet_idx == -1) {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"space"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      } else {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      }
                      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit.name + " in " + imperium_self.game.sectors[sector].name);
                      old_tech_sec(imperium_self, player, strategy_card_player);

                    }
                  );
                });
              }
            };
	    techcard.strategySecondaryEventBackup = old_tech_sec;
            techcard.strategySecondaryEvent = new_tech_sec;



            let old_tech_func = techcard.strategyPrimaryEvent;
            let new_tech_func = function(imperium_self, player, strategy_card_player) {
              if (imperium_self.game.player == strategy_card_player) {
                imperium_self.playerAcknowledgeNotice("Anti-Intellectual Revolution is in play. Do you wish to destroy a capital ship to research technology?", function() {

                  imperium_self.playerSelectUnitWithFilter(
                    "Select a capital ship to destroy: ",
                    function(ship) {
                      if (ship.type == "destroyer") { return 1; }
                      if (ship.type == "cruiser") { return 1; }
                      if (ship.type == "carrier") { return 1; }
                      if (ship.type == "dreadnaught") { return 1; }
                      if (ship.type == "flagship") { return 1; }
                      if (ship.type == "warsun") { return 1; }
                      return 0;
                    },

                    function(unit_identifier) {

                      let sector        = unit_identifier.sector;
                      let planet_idx    = unit_identifier.planet_idx;
                      let unit_idx      = unit_identifier.unit_idx;
                      let unit          = unit_identifier.unit;

                      if (planet_idx == -1) {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"space"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      } else {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      }
                      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit.name + " in " + imperium_self.game.sectors[sector].name);
                      old_tech_func(imperium_self, player, strategy_card_player);

                    }
                  );
                });
              }
            };
	    techcard.strategyPrimaryEventBackup = old_tech_func;
            techcard.strategyPrimaryEvent = new_tech_func;
          }

          if (winning_choice === "against") {
            // exhaust two planets
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              imperium_self.game.players_info[i].must_exhaust_at_round_start.push("planet","planet");
            }
          }
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.anti_intellectual_revolution = 1;
	  let law_to_push = {};
	      law_to_push.agenda = "anti-intellectual-revolution";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  this.initialize(imperium_self, winning_choice);
	}
  });



  this.importAgendaCard('unconventional-measures', {
  	name : "Unconventional Measures" ,
  	type : "Directive" ,
  	text : "FOR: each player that votes 'for' draws 2 action cards. AGAINST: each player that votes 'for' discards their action cards." ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
	onPass : function(imperium_self, winning_choice) {

	  //
	  // gain two action cards
	  //
	  if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == winning_choice) {
                imperium_self.game.queue.push("gain\t2\t"+(i+2)+"\taction_cards"+"\t"+2);
                imperium_self.game.queue.push("DEAL\t2\t"+(i+1)+"\t2");
                imperium_self.game.queue.push("NOTIFY\tdealing two action cards to player "+(i+1));
	      }	      
	    }
	  }

	  //
	  // everyone who votes against discards action cards
	  //
	  if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "for") {
                if (imperium_self.game.player == (i+1)) {
		  imperium_self.game.players_info[i].action_cards_in_hand = 0;
		} else {
		  imperium_self.game.players_info[i].action_cards_in_hand = 0;
		  imperium_self.game.deck[1].hand = [];
  		  let law_to_push = {};
		      law_to_push.agenda = "unconventional-measures";
		      law_to_push.option = "winning_choice";
		  imperium_self.game.state.laws.push(law_to_push);
		}
	      }	      
	    }
	  }

        }
  });


  this.importAgendaCard('seeds-of-an-empire', {
  	name : "Seeds of an Empire" ,
  	type : "Directive" ,
  	text : "FOR: the player(s) with the most VP gain a VP. AGAINST: the players with the least VP gain a VP" ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
	onPass : function(imperium_self, winning_choice) {

	  let io = imperium_self.returnInitiativeOrder();

	  //
	  // highest VP
	  //
	  if (winning_choice === "for") {

	    let highest_vp = 0;
	    for (let i = 0; i < io.length; i++) {
	      if (highest_vp >= imperium_self.game.players_info[io[i]-1].vp) { highest_vp = imperium_self.game.players_info[io[i]-1].vp; }
	      imperium_self.game.state.seeds_of_an_empire = io[i];
	    }

	    for (let i = 0; i < io.length; i++) {
	      if (highest_vp == imperium_self.game.players_info[io[i]-1].vp) {
		imperium_self.game.players_info[io[i]-1].vp += 1;
		imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction((io[i])) + " gains 1 VP from Seeds of an Empire");
	        imperium_self.game.state.seeds_of_an_empire = (io[i]);
		if (imperium_self.checkForVictory()) { return 0; }
	      }
	    }
	    
          }


	  //
	  // lowest VP
	  //
	  if (winning_choice === "against") {

	    let lowest_vp = 10000;
	    for (let i = 0; i < io.length; i++) {
	      if (lowest_vp <= imperium_self.game.players_info[io[i]-1].vp) { highest_vp = imperium_self.game.players_info[io[i]-1].vp; }
	    }

	    for (let i = 0; i < io.length; i++) {
	      if (lowest_vp == imperium_self.game.players_info[io[i]-1].vp) {
		imperium_self.game.players_info[io[i]-1].vp += 1;
		imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction((io[i]+1)) + " gains 1 VP from Seeds of an Empire");
	        imperium_self.game.state.seeds_of_an_empire = (io[i]);
		if (imperium_self.checkForVictory()) { return 0; }

	      }
	    }
	    
          }

	  imperium_self.updateLeaderboard();

	  return 1;
        }
  });


  this.importAgendaCard('space-cadet', {
  	name : "Space Cadet" ,
  	type : "Law" ,
  	text : "Any player more than 3 VP behind the lead must henceforth be referred to as an Irrelevant Loser" ,
        returnAgendaOptions : function(imperium_self) { 
	  let options = [ 'for' , 'against' ];
	  return options;
        },
	initialize : function(imperium_self, winning_choice) {
	  if (imperium_self.space_cadet_initialized == undefined) {
	    imperium_self.space_cadet_initialized = 1;
	    if (imperium_self.game.state.space_cadet == 1) {
	      imperium_self.returnFactionNamePreSpaceCadet = imperium_self.returnFactionName;
	      imperium_self.returnFactionName = function(imperium_self, player) {
	        let max_vp = 0;
	        for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	          if (max_vp < imperium_self.game.players_info[i].vp) {
		    max_vp = imperium_self.game.players_info[i].vp;
		  }
	        }
                if (imperium_self.game.players_info[player-1].vp <= (max_vp-3)) { return "Irrelevant Loser"; }
    	        return imperium_self.returnFactionNamePreSpaceCadet(imperium_self, player);
  	      }
	      imperium_self.returnFactionNameNicknamePreSpaceCadet = imperium_self.returnFactionNameNickname;
	      imperium_self.returnFactionNameNickname = function(imperium_self, player) {
	        let max_vp = 0;
	        for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	          if (max_vp < imperium_self.game.players_info[i].vp) {
		    max_vp = imperium_self.game.players_info[i].vp;
		  }
	        }
                if (imperium_self.game.players_info[player-1].vp <= (max_vp-3)) { return "Loser"; }
    	        return imperium_self.returnFactionNameNicknamePreSpaceCadet(imperium_self, player);
  	      }
	    }
	  }
	},
	onPass : function(imperium_self, winning_choice) {
	  if (winning_choice == 'for') {
	    imperium_self.game.state.space_cadet = 1;
	    let law_to_push = {};
	        law_to_push.agenda = "space-cadet";
	        law_to_push.option = winning_choice;
	    imperium_self.game.state.laws.push(law_to_push);
	    this.initialize(imperium_self);
	  }
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) { 
            if (imperium_self.game.state.laws[i].agenda === "space-cadet") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
	  imperium_self.game.state.space_cadet = 0;
          imperium_self.returnFactionName = imperium_self.returnFactionNamePreSpaceCadet;

          return 1;

        }
  });


  this.importAgendaCard('galactic-threat', {
  	name : "Galactic Threat" ,
  	type : "Law" ,
  	text : "Elect a player. They must henceforth be referred to as the Galatic Threat" ,
        returnAgendaOptions : function(imperium_self) { 
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
        },
	initialize : function(imperium_self, winning_choice) {
	  if (imperium_self.galactic_threat_initialized == undefined) {
	    imperium_self.galactic_threat_initialized = 1;
	    if (imperium_self.game.state.galactic_threat == 1) {
	      imperium_self.returnFactionNamePreGalacticThreat = imperium_self.returnFactionName;
	      imperium_self.returnFactionName = function(imperium_self, player) {
                if (imperium_self.game.state.galactic_threat_player == player) { return "The Galactic Threat"; }
    	        return imperium_self.returnFactionNamePreGalacticThreat(imperium_self, player);
  	      }
	      imperium_self.returnFactionNameNicknamePreGalacticThreat = imperium_self.returnFactionNameNickname;
	      imperium_self.returnFactionNameNickname = function(imperium_self, player) {
                if (imperium_self.game.state.galactic_threat_player == player) { return "Threat"; }
    	        return imperium_self.returnFactionNameNicknamePreGalacticThreat(imperium_self, player);
  	      }
	    }
	  }
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.galactic_threat = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.galactic_threat_player = i+1;
	    }
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "galactic-threat";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  this.initialize(imperium_self);
	},
        repealAgenda(imperium_self) {

	  let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) { 
            if (imperium_self.game.state.laws[i].agenda === "galactic-threat") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.galactic_threat = 0;
          imperium_self.game.state.galactic_threat_initialized = 0;
	  if (imperium_self.returnFactionNamePreGalacticThreat) {
            imperium_self.returnFactionName = imperium_self.returnFactionNamePreGalacticThreat;
	  }

          return 1;

        }
  });




  this.importAgendaCard('Committee Formation', {
  	name : "Committee Formation" ,
  	type : "Law" ,
	elect : "player" ,
  	text : "Elect a player. They may form a committee to choose a player to be elected in a future agenda, bypassing voting" ,
        returnAgendaOptions : function(imperium_self) { 
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
        },
	preAgendaStageTriggers : function(imperium_self, player, agenda) {
	  if (imperium_self.game.state.committee_formation == 1 && imperium_self.game.state.committee_formation_player == player) { return 1; }
	  return 0;
	},
	preAgendaStageEvent : function(imperium_self, player, agenda) {

	  let html = "Do you wish to use Committee Formation to select the winner yourself? <ul>";
	      html += '<li class="textchoice" id="yes">assemble the committee</li>';
	      html += '<li class="textchoice" id="no">not this time</li>';
	      html += '</ul>';

	  imperium_self.updateStatus(html);

	  $('.textchoice').off();
	  $('.textchoice').on('click', function() {

	    let action = $(this).attr("id");

	    if (action == "no") { imperium_self.endTurn(); }

	    //
	    // works by "Assassinating all other representatives, so they don't / can't vote"
	    //
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (i != imperium_self.game.player-1) {
                imperium_self.addMove("rider\t"+player+"\tassassinate-representative\t-1");
	      }
	    }
            imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " forms a committee...");
	    

	  });

          return 0;

	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.committee_formation = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.committee_formation_player = (i+1);
	    }
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "committee-formation";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	},
        repealAgenda(imperium_self) {

	  let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "committee_formation") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.game.state.committee_formation = 0;
          imperium_self.game.state.committee_formation_player = -1;
          imperium_self.returnFactionName = imperium_self.returnFactionNamePreGalacticThreat;
          
          return 1;

        }

  });




  this.importAgendaCard('minister-of-policy', {
        name : "Minister of Policy" ,
        type : "Law" ,
	elect : "player" ,
        text : "Elect a player. They draw an extra action card at the start of each round" ,
        returnAgendaOptions : function(imperium_self) {
          let options = [];
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            options.push(imperium_self.returnFaction(i+1));
          }
          return options;
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.minister_of_policy = 1;
          imperium_self.game.state.minister_of_policy_player = winning_choice;
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.minister_of_policy_player = i+1;
	    }
	  }
	  imperium_self.game.players_info[imperium_self.game.state.minister_of_policy_player-1].action_cards_bonus_when_issued++;
	  let law_to_push = {};
	      law_to_push.agenda = "minister-of-policy";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

        },
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "minister-of-policy") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.game.state.minister_of_policy = 0;
	  imperium_self.game.players_info[imperium_self.game.state.minister_of_policy_player-1].action_cards_bonus_when_issued--;
          imperium_self.game.state.minister_of_policy_player = -1;

          return 1;

        }
  });



  this.importAgendaCard('executive-sanctions', {
  	name : "Executive Sanctions" ,
  	type : "Law" ,
  	text : "Players may have a maximum of 3 action cards in their hands at all times" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].action_card_limit = 3;
	    }
	  }
	  let law_to_push = {};
	      law_to_push.agenda = "executive-sanctions";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  return 1;
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "executive-sanctions") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (imperium_self.game.players_info[i].action_card_limit == 3) {
	      imperium_self.game.players_info[i].action_card_limit = 7;
	    }
	  }

          return 1;

        }

  });

  this.importAgendaCard('fleet-limitations', {
  	name : "Fleet Limitations" ,
  	type : "Law" ,
  	text : "Players may have a maximum of four tokens in their fleet supply." ,
  	img : "/imperium/img/agenda_card_template.png" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].fleet_supply_limit = 4;
	      if (imperium_self.game.players_info[i].fleet_supply >= 4) { imperium_self.game.players_info[i].fleet_supply = 4; }
	    }
	  }
	  return 1;
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "fleet-limitations") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].fleet_supply_limit = 16;
          }

          return 1;

        }

  });


  this.importAgendaCard('restricted-conscription', {
  	name : "Restricted Conscription" ,
  	type : "Law" ,
  	text : "Production cost for infantry and fighters is 1 rather than 0.5 resources" ,
  	img : "/imperium/img/agenda_card_template.png" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    imperium_self.units["infantry"].cost = 1;
	    imperium_self.units["fighter"].cost = 1;
	  }
	  let law_to_push = {};
	      law_to_push.agenda = "restricted-conscription";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  return 1;
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "restricted-conscription") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.units["infantry"].cost = 0.5;
          imperium_self.units["fighter"].cost = 0.5;

          return 1;

        }
  });


  this.importAgendaCard('wormhole-travel-ban', {
  	name : "Wormhole Travel Ban" ,
  	type : "Law" ,
  	text : "All wormholes are closed." ,
  	img : "/imperium/img/agenda_card_template.png" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    imperium_self.game.state.wormholes_open = 0;
	  }
	  let law_to_push = {};
	      law_to_push.agenda = "wormhole-travel-ban";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  return 1;
	},
        repealAgenda(imperium_self) {
          
          let winning_choice = null;
          
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "wormhole-travel-ban") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.wormholes_open = 1;;
          
          return 1;

        }

  });





  this.importAgendaCard('archived-secret', {
  	name : "Archived Secret" ,
  	type : "Directive" ,
  	text : "Elected Player draws one secret objective" ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.archived_secret = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.archived_secret_player = i+1;
	    }
	  }

	  //
	  // deal secret objective
	  //
          imperium_self.game.queue.push("gain\t"+(imperium_self.game.state.archived_secret_player)+"\tsecret_objectives\t1");
          imperium_self.game.queue.push("DEAL\t6\t"+(imperium_self.game.state.archived_secret_player)+"\t1");

	  return 1;

	},
  });



  this.importAgendaCard('economic-equality', {
  	name : "Economic Equality" ,
  	type : "Directive" ,
  	text : "FOR: all players discard all trade goods, AGAINST: players lose all trade goods and then gain 5 trade goods. " ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.economic_equality = 1;

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].goods = 0;
	    }
	    imperium_self.updateLog("All players have 0 trade goods");
          }

          if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].goods = 5;
	    }
	    imperium_self.updateLog("All players have 5 trade goods");
          }

	  imperium_self.displayFactionDashboard();

	  return 1;

	},
  });






  this.importAgendaCard('mutiny', {
  	name : "Mutiny" ,
  	type : "Directive" ,
  	text : "FOR: all who vote FOR gain 1 VP, AGAINST: all players who vote FOR lose 1 VP" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.mutiny = 1;

          if (winning_choice === "for") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "for") {
                imperium_self.game.players_info[i].vp++;
	        imperium_self.updateLog(imperium_self.returnFaction(i+1) + " gains 1 VP from Mutiny");
              }
            }
          }

          //
          // everyone who votes against discards action cards
          //
          if (winning_choice === "against") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] === "for") {
                imperium_self.game.players_info[i].vp--;
	        imperium_self.updateLog(imperium_self.returnFaction(i+1) + " loses 1 VP from Mutiny");
              }
            }
	  }

	  imperium_self.updateLeaderboard();

	  return 1;

	},
  });




  this.importAgendaCard('conventions-of-war', {
  	name : "Conventions of War" ,
  	type : "Law" ,
  	text : "FOR: cultural planets are exempt from bombardment, AGAINST: players who vote against discard all action cards" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.conventions_of_war = 1;

          if (winning_choice === "for") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "against") {
                imperium_self.game.players_info[i].action_cards_in_hand = 0;
		if (imperium_self.game.player == (i+1)) {
		  imperium_self.game.deck[1].hand = [];
		}
              }
            }
          }

          //
          // everyone who votes against discards action cards
          //
          if (winning_choice === "against") {
            imperium_self.game.state.bombardment_against_cultural_planets = 0;
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "conventions-of-war";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  return 1;

	},
        repealAgenda(imperium_self) {
          
          let winning_choice = null;
          
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "conventions-of-war") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.bombardment_against_cultural_planets = 1;          

          return 1;

        }

  });





  this.importAgendaCard('swords-to-ploughshares', {
  	name : "Swords to Ploughshares" ,
  	type : "Directive" ,
  	text : "FOR: everyone destroys half their infantry (round up) on every planet, AGAINST: everyone gains 1 infantry each planet" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.swords_to_ploughshares = 1;

          if (winning_choice === "against") {
            for (let i in imperium_self.game.planets) {
	      if (imperium_self.game.planets[i].owner != -1) {
		imperium_self.game.planets[i].units[imperium_self.game.planets[i].owner-1].push(imperium_self.returnUnit("infantry", imperium_self.game.planets[i].owner));
	      }
	    }
	  }


          //
          // everyone who votes against discards action cards
          //

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {

	      let total_infantry_destroyed = 0;

              for (let k in imperium_self.game.planets) {
	        if (imperium_self.game.planets[k].owner == (i+1)) {

		  let destroy_this_infantry = 0;

		  for (let m = 0; m < imperium_self.game.planets[k].units[i].length; m++) {
		    if (imperium_self.game.planets[k].units[i][m].type == "infantry") {
		      if (destroy_this_infantry == 1) {
			destroy_this_infantry = 0;
			total_infantry_destroyed++;
		      } else {
			destroy_this_infantry = 1;
		      }
		    }
		  }

		  for (let m = 0, n = 0; n < total_infantry_destroyed && m < imperium_self.game.planets[k].units[i].length; m++) {
		    if (imperium_self.game.planets[k].units[i][m].type == "infantry") {
		      imperium_self.game.planets[k].units[i].splice(m, 1);
		      m--;
		      n++;
		    }
		  }


	        }
	      }

	      if (total_infantry_destroyed == 1) {
  	        imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " gains " + total_infantry_destroyed + " trade good");
	      } else {
  	        imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " gains " + total_infantry_destroyed + " trade goods");
	      }

	    }
	  }

	  return 1;

	},
  });




  this.importAgendaCard('wormhole-research', {
  	name : "Wormhole Research" ,
  	type : "Directive" ,
  	text : "FOR: all ships in sectors with alpha and beta wormholes are destroyed, their owners research 1 technology, AGAINST: everyone who voted against loses a command token" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.wormhole_research = 1;

	  let players_to_research_tech = [];

          if (winning_choice === "for") {
	    for (let i in imperium_self.game.sectors) {
	      if (imperium_self.game.sectors[i].wormhole != 0) {
	        for (let k = 0; k < imperium_self.game.sectors[i].units.length; k++) {
	          if (imperium_self.game.sectors[i].units[k].length > 0) {
	            imperium_self.game.sectors[i].units[k] = [];
		    if (!players_to_research_tech.includes((k+1))) {
		      players_to_research_tech.push((k+1));
		    }
		  }
		}
	      }
            }

	    players_to_research_tech.sort();
	    for (let i = 0; i < players_to_research_tech.length; i++) { 
	      imperium_self.game.queue.push("reearch\t"+players_to_research_tech[i]);
	    }
          }





          //
          // everyone who votes against loses command token
          //
          if (winning_choice === "against") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "against") {
                imperium_self.game.players_info[i].command_tokens--;
                if (imperium_self.game.players_info[i].command_tokens <= 0) {
                  imperium_self.game.players_info[i].command_tokens = 0;
		}
	      }
	    }
	    imperium_self.updateTokenDisplay();
	  }
	  return 1;

	},
  });







  this.importAgendaCard('new-constitution', {
  	name : "New Constitution" ,
  	type : "Directive" ,
  	text : "FOR: remove all laws in play and exhaust all homeworld at the start of the next round" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.new_constitution = 1;

	  //
	  // repeal any laws in plan
	  //
	  for (let i = imperium_self.game.state.laws.length-1; i > 0; i--) {
	    let saved_agenda = imperium_self.game.state.laws[i].agenda;
	    imperium_self.agenda_cards[saved_agenda].repealAgenda(imperium_self);
	  }

	  let players_to_research_tech = [];

          if (winning_choice === "for") {
	    imperium_self.game.state.laws = [];
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].must_exhaust_at_round_start.push("homeworld");
            }
          }

	  return 1;


	},
  });






  this.importAgendaCard('shared-research', {
  	name : "Shared Research" ,
  	type : "Directive" ,
  	text : "FOR: each player activates their home system, AGAINST: units can move through nebulas" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.shared_research = 1;

	  let players_to_research_tech = [];

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.queue.push("activate\t"+(i+1)+"\t"+imperium_self.returnPlayerHomeworld((i+1)));
            }
          }

          if (winning_choice === "against") {
	    imperium_self.game.players_info[i].fly_through_nebulas = 1;
	  }

	  return 1;

	},
  });







  this.importAgendaCard('wormhole-reconstruction', {
  	name : "Wormhole Reconstruction" ,
  	type : "Directive" ,
  	text : "FOR: alpha and beta wormholes connect to each other, AGAINST:  each player activates all systems with alpha and beta wormholes" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.wormhole_reconstruction = 1;

          if (winning_choice === "for") {
	    imperium_self.game.state.wormholes_adjacent = 1;
          }

          if (winning_choice === "against") {
	    for (let i in imperium_self.game.sectors) {
	      if (imperium_self.game.sectors[i].wormhole == 1 || imperium_self.game.sectors[i].wormhole == 2) {
		for (let ii = 0; ii < imperium_self.game.players_info.length; ii++) {
		  imperium_self.game.sectors[i].activated[ii] = 1;
		}
	        let sys = imperium_self.returnSectorAndPlanets(i);
		if (sys.s) {
		  imperium_self.updateSectorGraphics(i);
		}
	      }
	    }
	  }

	  return 1;

	},
  });





  this.importAgendaCard('crown-of-emphidia', {
        name : "Crown of Emphidia" ,
        type : "Law" ,
        elect : "player" ,
        text : "Elect a Player to earn 1 VP. When this player loses a homeworld to another player, they lose 1 VP and their opponent gains 1 VP" ,
        returnAgendaOptions : function(imperium_self) {
          let options = [];
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            options.push(imperium_self.returnFaction(i+1));
          }
          return options;
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.crown_of_emphidia = 1;

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            if (winning_choice === imperium_self.returnFaction((i+1))) {
              imperium_self.game.state.crown_of_emphidia_player = i+1;
            }
          }

          let law_to_push = {};
              law_to_push.agenda = "crown-of-emphidia";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);

          imperium_self.game.players_info[imperium_self.game.state.crown_of_emphidia_player-1].vp += 1;
          imperium_self.updateLeaderboard();
          imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.crown_of_emphidia_player) + " gains 1 VP from Crown of Emphidia");

        },
        repealAgenda(imperium_self) {
          
          let winning_choice = null;
          
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "crown-of-emphidia") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.crown_of_emphidia = -1;
          imperium_self.game.state.crown_of_emphidia_player = -1;
          
          return 1;

        },
        groundCombatRoundEnd : function(imperium_self, attacker, defender, sector, planet_idx) {
          if (defender == imperium_self.game.state.crown_of_emphidia_player) {
            if (!imperium_self.doesPlayerHaveInfantryOnPlanet(defender, sector, planet_idx)) {
              if (imperium_self.doesPlayerHaveInfantryOnPlanet(attacker, sector, planet_idx)) {
                imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.crown_of_emphidia_player) + " loses the Crown of Emphidia (-1VP)");
                imperium_self.game.state.crown_of_emphidia_player = attacker;
                imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.crown_of_emphidia_player) + " gains the Crown of Emphidia (+1VP)");
                imperium_self.game.players_info[attacker-1].vp += 1;
                imperium_self.game.players_info[defender-1].vp -= 1;
                imperium_self.updateLeaderboard();
	      }
            }
          }

	  return 1;

        },
  });

  this.importAgendaCard('terraforming-initiative', {
        name : "Terraforming Initiative" ,
        type : "Law" ,
        elect : "planet" ,
        text : "Elect a hazardous planet. The resource and influence values of this planet are increased by 1 point each" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "hazardous") { return 1; } return 0;
          });
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.terraforming_initiative = 1;
          imperium_self.game.state.terraforming_initiative_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "terraforming-initiative";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);

          //
          // alter planet
          //
          imperium_self.game.planets[winning_choice].resources++;
          imperium_self.game.planets[winning_choice].influence++;
          imperium_self.updateLog(imperium_self.game.planets[winning_choice].name + " increases resource and influence through terraforming");

	  return 1;

        },
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "terraforming-initiative") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.game.state.terraforming_initiative = -1;
	  if (winning_choice) {
            if (imperium_self.game.planets[winning_choice]) {
              imperium_self.game.planets[winning_choice].resources--;
              imperium_self.game.planets[winning_choice].influence--;
            }
	  }
	  imperium_self.game.state.terraforming_initiative_planet = -1;

          return 1;

        },

  });


  this.importAgendaCard('senate-sanctuary', {
        name : "Senate Sanctuary" ,
        type : "Law" ,
        elect : "planet" ,
        text : "Elect a cultural planet. The influence value of this planet is increased by 2 points" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "cultural") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {
  
          let winning_choice = null;     

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "senate-sanctuary") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;    
            }
          }

          if (winning_choice) {
            if (imperium_self.game.planets[winning_choice]) {
              imperium_self.game.planets[winning_choice].influence -= 2;
            }
          }
          imperium_self.game.state.senate_sanctuary = 0;
          imperium_self.game.state.senate_sanctuary_planet = -1;

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.senate_sanctuary = 1;
          imperium_self.game.state.senate_sanctuary_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "senate-sanctuary";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);

          //
          // alter planet
          //
          imperium_self.game.planets[winning_choice].influence+=2;
          imperium_self.updateLog(imperium_self.game.planets[winning_choice].name + " increases influence value by 2");

	  return 1;

        }
  });


  this.importAgendaCard('publicize-weapons-schematics', {
        name : "Publicize Weapons Schematics" ,
        type : "Directive" ,
        text : "FOR: all players now have War Suns technology, AGAINST: all players with War Suns technology discard all action cards" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.publicize_weapons_schematics = 1;

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (!imperium_self.doesPlayerHaveTech((i+1), "warsun")) {
		imperium_self.game.queue.push("purchase\t"+(i+1)+"\t"+"tech"+"\t"+"warsun");
	      }
 	    }
          }

          if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.doesPlayerHaveTech((i+1), "warsun")) {
		imperium_self.game.players_info[i].action_cards_in_hand = 0;
		if (imperium_self.game.player == (i+1)) {
		  imperium_self.game.deck[1].hand = [];
		}
		imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " discards all Action Cards");
	      }
	    }
	  }

	  return 1;

        }
  });



  this.importAgendaCard('incentive-program', {
        name : "Incentive Program" ,
        type : "Directive" ,
        text : "FOR: reveal a 1 VP public objective, AGAINST: reveal a 2 VP public objective" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.incentive_program = 1;

          if (winning_choice === "for") {
            imperium_self.game.queue.push("revealobjectives");
            for (let i = 1; i <= imperium_self.game.players_info.length; i++) {
              imperium_self.game.queue.push("FLIPCARD\t4\t1\t2\t"+i); // deck card poolnum player
            }
          }

          if (winning_choice === "against") {
            imperium_self.game.queue.push("revealobjectives");
            for (let i = 1; i <= imperium_self.game.players_info.length; i++) {
              imperium_self.game.queue.push("FLIPCARD\t5\t1\t3\t"+i); // deck card poolnum player
            }
	  }
	  return 1;
        }
  });


  this.importAgendaCard('colonial-redistribution', {
        name : "Colonial Redistribution" ,
        type : "Directive" ,
        elect : "planet" ,
        text : "Elect a cultural, industrial or hazardous planet. Destroy all units on the planet. Planet owner chooses a player with the fewest VP to gain control of the planet and gain 1 infantry on it. If no-one controls that planet, the Speaker chooses the recipient." ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "cultural") { return 1; }
            if (planet.type === "industrial") { return 1; }
            if (planet.type === "hazardous") { return 1; }
	    return 0;
          });
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.colonial_redistribution = 1;
          imperium_self.game.state.colonial_redistribution_planet = winning_choice;
	  imperium_self.game.queue.push("colonial_redistribution\t"+winning_choice);

	  imperium_self.game.state.laws.push({ agenda : "colonial-redistribution" , option : winning_choice });

	  return 0;

        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "colonial_redistribution") {

            let winning_choice = mv[1];
            imperium_self.game.queue.splice(qe, 1);

	    let owner = imperium_self.game.planets[winning_choice].owner;
	    let planet_idx = imperium_self.game.planets[winning_choice].idx;
	    let sector = imperium_self.game.planets[winning_choice].sector;

	    if (owner == -1) { owner = imperium_self.game.state.speaker; }
	    imperium_self.game.planets[winning_choice].units[owner] = [];

	    if (imperium_self.game.player == owner) {
            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player to receive 1 infantry and this planet" ,
              function(player) {
	        let lower_vp_player = 0;
		let this_player_vp = player.vp;
	        for (let i = 0; i < imperium_self.game.players_info.length; i++) {
		  if (imperium_self.game.players_info[i] < this_player_vp) { lower_vp_player = 1; }
		}
	        if (lower_vp_player == 1) { return 0; }
		return 1;
              },
	      function(player) {
		imperium_self.updateStatus("");
		imperium_self.addMove("produce\t" + player + "\t" + "1" + "\t" + planet_idx + "\t" + "infantry" + "\t" + sector);
		imperium_self.addMove("annex\t" + player + "\t" + sector + "\t" + planet_idx);
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " gains the contested planet");
		imperium_self.endTurn();
		return 0;
	      },
	    );
	    }

            return 0;
          }

          return 1;
        }
  });



  this.importAgendaCard('compensated-disarmament', {
        name : "Compensated Disarmament" ,
        type : "Directive" ,
        elect : "planet" ,
        text : "Destroy all ground forces on planet. For each infantry destroyed planet owner gains 1 trade good" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
	    return 1;
          });
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.compensated_disarmament = 1;
          imperium_self.game.state.compensated_disarmament_planet = winning_choice;

console.log("planet is: " + winning_choice);

	  let planet = imperium_self.game.planets[winning_choice];
	  let owner = parseInt(planet.owner);
	  let total_infantry = 0;

	  if (owner == -1) { return 1; }

	  let units_to_check = planet.units[owner-1].length;
	  for (let i = 0; i < units_to_check; i++) {
	    let unit = planet.units[owner-1][i];
	    if (unit.type == "infantry") {
	      total_infantry++;
	      planet.units[owner-1].splice(i, 1);
	      i--;
	      units_to_check = planet.units[owner-1].length;
	    }
	  }

	  if (total_infantry > 0) {
	    imperium_self.game.queue.push("purchase\t"+owner+"\tgoods\t"+total_infantry);
	  }

	  imperium_self.updateSectorGraphics(planet.sector);

	  return 1;

        }
  });


  this.importAgendaCard('judicial-abolishment', {
        name : "Judicial Abolishment" ,
        type : "Directive" ,
        elect : "law" ,
        text : "Discard a law if one is in play" ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	    options.push(imperium_self.agenda_cards[imperium_self.game.state.laws[i].agenda].name);
	  }
	  return options;
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.judicial_abolishment = 1;
          imperium_self.game.state.judicial_abolishment_law = winning_choice;

	  let repealed = null;

	  for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	    if (winning_choice === imperium_self.agenda_cards[imperium_self.game.state.laws[i].agenda].name) {
	      imperium_self.agenda_cards[ imperium_self.game.state.laws[i].agenda ].repealAgenda(imperium_self);
	      repealed = imperium_self.game.state.laws[i].agenda;
	      i = imperium_self.game.state.laws.length+2;
	    }
	  }

	  if (repealed) {
	    imperium_self.updateLog(imperium_self.agenda_cards[repealed].name + " abolished");
	  }

	  return 1;

        }
  });




  this.importAgendaCard('public-execution', {

        name : "Public Execution" ,
        type : "Directive" ,
	elect : "player" ,
        text : "Elect a player. They discard all their action cards, lose the speaker token to the next player in initiative order (if they have it) and lose all of their votes." ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
	},
        onPass : function(imperium_self, winning_choice) {

	  let initiative_order = imperium_self.returnInitiativeOrder();

          imperium_self.game.state.public_execution = 1;

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            if (winning_choice === imperium_self.returnFaction((i+1))) {
              imperium_self.game.state.public_execution_player = i+1;
            }
          }


	  // lose action cards
          imperium_self.game.players_info[imperium_self.game.state.public_execution_player-1].action_cards_in_hand = 0;
	  if (imperium_self.game.player == imperium_self.game.state.public_execution_player) {
	    imperium_self.game.deck[1].hand = [];
	  }

	  // lose speakership
	  if (winning_choice == imperium_self.game.state.speaker) {
	    imperium_self.game.state.speaker = initiative_order[0];
	    for (let i = 0; i < initiative_order.length-1; i++) {
	      if (initiative_order[i] == imperium_self.game.state.public_execution_player) {
	        imperium_self.game.state.speaker = initiative_order[i+1];
	      }
	    }
	  }

	  // lose all voting power
          imperium_self.game.state.votes_available[imperium_self.game.state.public_execution_player-1] = 0;

	  imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.public_execution_player) + " representative publicly executed");

	  return 1;

        }
  });








  this.importAgendaCard('ixthian-artifact', {

        name : "Ixthian Artifact" ,
        type : "Directive" ,
        text : "FOR: roll a die. On rolls of 5 and under destroy all units on New Byzantium and 3 units in each adjacent system. On all other rolls each player researches 2 technologies" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
        onPass : function(imperium_self, winning_choice) {

	  if (winning_choice == "for") {

	    let roll = imperium_self.rollDice(10);

imperium_self.updateLog("Ixthian Artifact rolls " + roll);

	    if (roll <= 5) {

	      // destroy all units
	      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
		imperium_self.game.planets['new-byzantium'].units[i] = [];
		imperium_self.game.sectors['new-byzantium'].units[i] = [];
	      }

     	      let as = imperium_self.returnAdjacentSectors('new-byzantium');
 	      for (let i = 0; i < as.length; i++) {
	        for (let ii = 0; ii < imperium_self.game.players_info.length; ii++) {
  	          if (imperium_self.doesSectorContainPlayerUnits((ii+1), as[i])) {
		    imperium_self.game.queue.push("destroy_units\t"+(ii+1)+"\t"+3+"\t"+as[i]+"\t"+0);
    	          }
    	        }
	      }

	    }

	    if (roll >= 6) {
	      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
		imperium_self.game.queue.push("research\t"+(i+1));
		imperium_self.game.queue.push("research\t"+(i+1));
	      }
	      imperium_self.game.queue.push("ACKNOWLEDGE\tThe Ixthian Artifact did not explode. All players may now research two technologies...");
          }
        }
        return 1;
      }
  });



/************************************
  
ACTION CARD - types

"action" -> main menu
"bombardment_attacker"
"bombardment_defender"
"combat"
"ground_combat"
"pds" -> before pds fire
"post_pds" -> after pds fire
"pre_agenda" --> before agenda voting
"post_agenda" --> after agenda voting
"space_combat"
"space_combat_victory"
"rider"


************************************/


    this.importActionCard('infiltrate', {
  	name : "Infiltrate" ,
  	type : "instant" ,
  	text : "The next time you invade a planet, you may takeover any existing PDS units or Space Docks" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_infiltrate_infrastructure_on_invasion = 1;
	  return 1;
	},
    });




    this.importActionCard('reparations', {
  	name : "Reparations" ,
  	type : "action" ,
  	text : "If you have lost a planet this round, refresh one of your planets" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.players_info[action_card_player-1].lost_planet_this_round != -1) {

	    let my_planets = imperium_self.returnPlayerExhaustedPlanetCards(imperium_self.game.player);

            imperium_self.playerSelectPlanetWithFilter(
              "Select an exhausted planet to refresh: " ,
              function(planet) {
		if (my_planets.includes(planet)) { return 1; } return 0;
              },
              function(planet) {
                imperium_self.addMove("unexhaust\tplanet\t"+planet);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player)+" refreshes " + imperium_self.game.planets[planet].name);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	    return 0;
	  }
	  return 1;
	},
    });



    this.importActionCard('political-stability', {
  	name : "Political Stability" ,
  	type : "instant" ,
  	text : "Pick a strategy card you have already played this round. You may keep this for next round" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let html = '<div class="sf-readable">Pick a Strategy Card to keep for next round: </div><ul>';
	    for (let i = 0; i < imperium_self.game.players_info[action_card_player-1].strategy_cards_played.length; i++) {
	      let card = imperium_self.game.players_info[action_card_player-1].strategy_cards_played[i];
              html += '<li class="option" id="'+card+'">' + imperium_self.strategy_cards[card].name + '</li>';
	    }
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.option').off();
	    $('.option').on('click', function() {
	      let card = $(this).attr("id");
	      imperium_self.addMove("strategy_card_retained\t"+imperium_self.game.player+"\t"+card);
	      imperium_self.endTurn();
	      return 0;
	    });

	  }

	  return 0;
	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "strategy_card_retained") {

            let player = parseInt(mv[1]);
            let card = mv[2];
            imperium_self.game.queue.splice(qe, 1);
	    imperium_self.game.players_info[player-1].strategy_cards_retained.push(card);

            return 1;
          }

	  return 1;
        }
    });



    this.importActionCard('lost-star-chart', {
  	name : "Lost Star Chart" ,
  	type : "instant" ,
  	text : "During this turn, all wormholes are adjacent to each other" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.temporary_wormholes_adjacent = 1;
	  return 1;
	},
    });


    this.importActionCard('plague', {
  	name : "Plague" ,
  	type : "action" ,
  	text : "ACTION: Select a planet. Roll a dice for each infantry on planet and destroy number of rolls 6 or higher." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet to cripple with the plague:",
              function(planet) {
		return imperium_self.doesPlanetHaveInfantry(planet);
              },
	      function(planet) {
		imperium_self.addMove("plague\t"+imperium_self.game.player+"\t"+planet);
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " unleashes a plague on " + imperium_self.game.planets[planet].name);
		imperium_self.endTurn();
		return 0;
	      },
	      null
	    );
	  }
	  return 0;
	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "plague") {

            let attacker = parseInt(mv[1]);
            let target = mv[2];
	    let sector = imperium_self.game.planets[target].sector;
	    let planet_idx = imperium_self.game.planets[target].idx;
	    let sys = imperium_self.returnSectorAndPlanets(sector);
	    let z = imperium_self.returnEventObjects();
	    let player = sys.p[planet_idx].owner;

	    let total_units_destroyed = 0;

            for (let i = 0; i < sys.p[planet_idx].units.length; i++) {
              for (let ii = 0; ii < sys.p[planet_idx].units[i].length; ii++) {
		let thisunit = sys.p[planet_idx].units[i][ii];

		if (thisunit.type == "infantry") {
		  let roll = imperium_self.rollDice(10);
		  if (roll > 6) {
		    thisunit.destroyed = 1;
		    for (z_index in z) {
		      thisunit = z[z_index].unitDestroyed(this, attacker, thisunit);
		    }
	            total_units_destroyed++;
		  }
		}
	      }
            }

	    imperium_self.updateLog("The plague destroys " + total_units_destroyed + " infantry");

            imperium_self.eliminateDestroyedUnitsInSector(player, sector);
            imperium_self.saveSystemAndPlanets(sys);
            imperium_self.updateSectorGraphics(sector);
            imperium_self.game.queue.splice(qe, 1);

            return 1;
          }

	  return 1;
        }

    });



    this.importActionCard('repeal-law', {
  	name : "Repeal Law" ,
  	type : "action" ,
  	text : "ACTION: Repeal one law that is in effect." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

	    let html = '<div class="sf-readable">Pick a Law to Repeal: </div><ul>';
	    for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	      let law = imperium_self.game.state.laws[i];
	      let agenda = imperium_self.agenda_cards[law];
              html += '<li class="option" id="'+agenda+'">' + imperium_self.agenda_cards[card].name + '</li>';
	    }
            html += '<li class="option" id="cancel">cancel</li>';
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.option').off();
	    $('.option').on('click', function() {

	      let card = $(this).attr("id");

	      if (card === "cancel") {
	        imperium_self.endTurn();
		return 0;
	      }

	      imperium_self.addMove("repeal_law\t"+card);
	      imperium_self.endTurn();
	      return 0;
	    });
          }

	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "repeal_law") {

            let card = mv[2];
            imperium_self.game.queue.splice(qe, 1);
	    for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	      if (imperium_self.game.state.laws[i] == card) {
		imperium_self.agenda_cards[card].repealAgenda(imperium_self);
	        return 1;
	      }
	    }

            return 1;
          }

	  return 1;
        }
    });



    this.importActionCard('veto', {
  	name : "Veto" ,
  	type : "action" ,
  	text : "ACTION: Select one agenda to remove from consideration and draw a replacement" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            let html = '';
            html += 'Select one agenda to quash in the Galactic Senate.<ul>';
            for (i = 0; i < 3; i++) {
              html += '<li class="option" id="'+imperium_self.game.state.agendas[i]+'">' + imperium_self.agenda_cards[imperium_self.game.state.agendas[i]].name + '</li>';
            }
            html += '</ul>';

            imperium_self.updateStatus(html);

            $('.option').off();
            $('.option').on('mouseenter', function() { let s = $(this).attr("id"); imperium_self.showAgendaCard(s); });
            $('.option').on('mouseleave', function() { let s = $(this).attr("id"); imperium_self.hideAgendaCard(s); });
            $('.option').on('click', function() {

              let agenda_to_quash = $(this).attr('id');

	      imperium_self.hideAgendaCard(agenda_to_quash);

              imperium_self.updateStatus("Quashing Agenda");
              imperium_self.addMove("quash\t"+agenda_to_quash+"\t"+"1"); // 1 = re-deal
              imperium_self.endTurn();
            });
          }

	  return 0;
        }
    });


    this.importActionCard('flank-speed1', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed2', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed3', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed4', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });



    this.importActionCard('propulsion-research', {
  	name : "Propulsion Research" ,
  	type : "instant" ,
  	text : "Gain +1 movement on a single ship moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_ship_move_bonus = 1;
	  return 1;
	}
    });




    this.importActionCard('military-drills', {
  	name : "Military Drills" ,
  	type : "action" ,
  	text : "ACTION: Gain two new command tokens" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    imperium_self.playerAllocateNewTokens(action_card_player, 2);
	  }
	  return 0;
	}
    });



    this.importActionCard('cripple-defenses', {
  	name : "Cripple Defenses" ,
  	type : "action" ,
  	text : "ACTION: Select a planet and destroy all PDS units on that planet" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet to destroy all PDS units on that planet: ",
              function(planet) {
		return imperium_self.doesPlanetHavePDS(planet);
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
		let tile = planet.tile;	        
		let planet_idx = planet.idx;
		let sys = imperium_self.returnSectorAndPlanets(sector);

		for (let b = 0; b < sys.p[planet_idx].units.length; b++) {
		  for (let bb = 0; bb < sys.p[planet_idx].units[b].length; bb++) {
		    if (sys.p[planet_idx].units[b][bb].type == "pds") {
		      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+(b+1)+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+bb+"\t"+"1");
		    }
                  }
                }

		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys all PDS units destroyed on "+sys.p[planet_idx].name);
		imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('reactor-meltdown', {
  	name : "Reactor Meltdown" ,
  	type : "action" ,
  	text : "ACTION: Select a non-homeworld planet and destroy one Space Dock on that planet" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a non-homeworld planet and destroy one Space Dock on that planet: " ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
	        if (planet.hw == 0 && imperium_self.doesPlanetHaveSpaceDock(planet)) {
		  return 1;
		}
              },
	      function(planet) {
		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
		let tile = planet.tile;	        
		let planet_idx = planet.idx;
		let sys = imperium_self.returnSectorAndPlanets(sector);

		for (let b = 0; b < sys.p[planet_idx].units.length; b++) {
		  for (let bb = 0; bb < sys.p[planet_idx].units[b].length; bb++) {
		    if (sys.p[planet_idx].units[b][bb].type == "spacedock") {
		      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+(b+1)+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+bb+"\t"+"1");
		    }
                  }
                }

		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys all Space Docks on "+sys.p[planet_idx].name);
		imperium_self.endTurn();
		return 0;

	      },
	      // cancel -- no space dock available?
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('lost-mission', {
  	name : "Lost Mission" ,
  	type : "action" ,
  	text : "ACTION: Place 1 Destroyer in a system with no existing ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector with no existing ships in which to place a Destroyer: ",
              function(sector) {
		return !imperium_self.doesSectorContainShips(sector);
              },
	      function(sector) {

                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdestroyer\t"+sector);
                imperium_self.addMove("NOTIFY\tAdding destroyer to gamebaord");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });

    this.importActionCard('accidental-colonization', {
  	name : "Accidental Colonization" ,
  	type : "action" ,
  	text : "ACTION: Gain control of one planet not controlled by any player" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet not controlled by another player: ",
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner == -1) { return 1; } return 0;
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
                imperium_self.addMove("gain_planet\t"+imperium_self.game.player+"\t"+sector+"\t"+planet.idx);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " gains planet " + planet.name);
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('uprising', {
  	name : "Uprising" ,
  	type : "action" ,
  	text : "ACTION: Exhaust a non-home planet card held by another player. Gain trade goods equal to resource value." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Exhaust a non-homeworld planet card held by another player. Gain trade goods equal to resource value." ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner != -1 && planet.owner != imperium_self.game.player && planet.exhausted == 0 && planet.hw == 0) { return 1; } return 0;
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let goods = planet.resources;

                imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+goods);
                imperium_self.addMove("expend\t"+imperium_self.game.player+"\tplanet\t"+planet.planet);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " exhausting "+planet.name + " and gaining " + goods + " trade goods");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });



    this.importActionCard('diaspora-conflict', {
  	name : "Diaspora Conflict" ,
  	type : "action" ,
  	text : "ACTION: Exhaust a non-home planet card held by another player. Gain trade goods equal to resource value." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Exhaust a planet card held by another player. Gain trade goods equal to resource value." ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner != -1 && planet.owner != imperium_self.game.player && planet.exhausted == 0 && planet.hw ==0) { return 1; } return 0;
              },
	      function(planet) {

	        let planetname = planet;
		planet = imperium_self.game.planets[planet];
		let goods = planet.resources;

                imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+goods);
                imperium_self.addMove("expend\t"+imperium_self.game.player+"\tplanet\t"+planetname);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " exhausting "+planet.name + " and gaining " + goods + " trade goods");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });



    this.importActionCard('economic-initiative', {
  	name : "Economic Initiative" ,
  	type : "action" ,
  	text : "ACTION: Ready each cultural planet in your control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      if (imperium_self.game.planets[i].type == "cultural") {
		imperium_self.game.planets[i].exhausted = 0;
	      }
	    }
	  }
	  return 1;
	}
    });


    this.importActionCard('focused-research', {
  	name : "Focused Research" ,
  	type : "action" ,
  	text : "ACTION: Spend 4 Trade Goods to Research 1 Technology" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let p = imperium_self.game.players_info[imperium_self.game.player-1];

	  if (p.goods < 4) {
	    imperium_self.updateLog("Player does not have enough trade goods to research a technology");
	    return 1;
	  }

	  //
	  // otherwise go for it
	  //
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerResearchTechnology(function(tech) {
              imperium_self.addMove("purchase\t"+imperium_self.game.player+"\ttech\t"+tech);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tgoods\t4");
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " researches " + imperium_self.tech[tech].name);
              imperium_self.endTurn();
	    });

	  }
	  return 0;
	}
    });



    this.importActionCard('frontline-deployment', {
  	name : "Frontline Deployment" ,
  	type : "action" ,
  	text : "ACTION: Deploy three infantry on one planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
              "Deploy three infantry to a planet you control: ",
              function(planet) {
                if (imperium_self.game.planets[planet].owner == imperium_self.game.player) { return 1; } return 0;
              },
              function(planet) {
		planet = imperium_self.game.planets[planet];
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys three infantry to " + planet.name);
                imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
	}
    });



    this.importActionCard('ghost-ship', {
  	name : "Ghost Ship" ,
  	type : "action" ,
  	text : "ACTION: Place a destroyer in a sector with a wormhole and no enemy ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {
            imperium_self.playerSelectSectorWithFilter(
              "Place a destroyer in a sector with a wormhole and no enemy ships: " ,
              function(sector) {
                if (imperium_self.doesSectorContainShips(sector) == 0 && imperium_self.game.sectors[sector].wormhole != 0) { return 1; } return 0;
              },
              function(sector) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+"-1"+"\t"+"destroyer"+"\t"+sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys a Destroyer to " + imperium_self.game.sectors[sector].name);
               imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
        }
    });



    this.importActionCard('war-effort', {
  	name : "War Effort" ,
  	type : "action" ,
  	text : "ACTION: Place a cruiser in a sector with one of your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
              "Place a cruiser in a sector with one of your ships: " ,
              function(sector) {
                if (imperium_self.doesSectorContainPlayerShips(player, sector) == 1) { return 1; } return 0;
              },
              function(sector) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+"-1"+"\t"+"cruiser"+"\t"+sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys a Cruiser to " + imperium_self.game.sectors[sector].name);
                imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
        }
    });





    this.importActionCard('industrial-initiative', {
  	name : "Industrial Initiative" ,
  	type : "action" ,
  	text : "ACTION: Gain a trade good for each industrial planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let trade_goods_to_gain = 0;

	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      if (imperium_self.game.planets[i].type == "industrial") {
		trade_goods_to_gain++;
	      }
	    }
	  }

	  if (trade_goods_to_gain > 0 ) {
            imperium_self.game.queue.push("purchase\t"+imperium_self.game.player+"\tgoods\t"+trade_goods_to_gain);
	  }

	  return 1;
	}
    });




    this.importActionCard('Insubordination', {
  	name : "Insubordination" ,
  	type : "action" ,
  	text : "ACTION: Select a player and remove 1 token from their command pool" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player and remove one token from their command pool: " ,
              function(player) {
	        if (player != imperium_self.game.player) { return 1; } return 0;
              },
	      function(player) {
                imperium_self.addMove("expend\t"+player+"\tcommand\t"+"1");
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFactionNickname(player) + " loses one comand token");
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
        }
    });




    this.importActionCard('Lucky Shot', {
  	name : "Lucky Shot" ,
  	type : "action" ,
  	text : "ACTION: Destroy a destroyer, cruiser or dreadnaught in a sector with a planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Destroy a destroyer, cruiser or dreadnaught in a sector containing a planet you control: " ,
              function(sector) {
  		if (imperium_self.doesSectorContainPlanetOwnedByPlayer(sector, imperium_self.game.player)) {
  		  if (imperium_self.doesSectorContainUnit(sector, "destroyer") || imperium_self.doesSectorContainUnit(sector, "cruiser") || imperium_self.doesSectorContainUnit(sector, "dreadnaught")) {
		    return 1;
		  }
		}
		return 0;
              },
	      function(sector) {

                imperium_self.playerSelectUnitInSectorWithFilter(
	          "Select a ship in this sector to destroy: " ,
		  sector,
                  function(unit) {
		    if (unit.type == "destroyer") { return 1; }
		    if (unit.type == "cruiser") { return 1; }
		    if (unit.type == "dreadnaught") { return 1; }
		    return 0;
                  },
	          function(unit_info) {

		    let s = unit_info.sector;
		    let p = parseInt(unit_info.unit.owner);
		    let uidx = unit_info.unit_idx;

		    let sys = imperium_self.returnSectorAndPlanets(s);
		    let unit_to_destroy = unit_info.unit;

                    imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+unit_to_destroy.owner+"\t"+"space"+"\t"+s+"\t"+"-1"+"\t"+uidx+"\t"+"1");
		    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit_to_destroy.name + " in " + sys.name);
		    imperium_self.endTurn();
		    return 0;
	          },
	          null
	        );
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
        }
    });





    this.importActionCard('mining-initiative-ac', {
  	name : "Mining Initiative" ,
  	type : "action" ,
  	text : "ACTION: Gain trade goods equal to the highest resource value planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

   	    let maximum_resources = 0;
	    for (let i in imperium_self.game.planets) {
	      if (imperium_self.game.planets[i].owner == action_card_player && imperium_self.game.planets[i].resources > maximum_resources) {
		maximum_resources = imperium_self.game.planets[i].resources;
	      }
	    }

            imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+maximum_resources);
            imperium_self.endTurn();
	    return 0;

	  }
	  return 0;
	}
    });




    this.importActionCard('rise-of-a-messiah', {
  	name : "Rise of a Messiah" ,
  	type : "action" ,
  	text : "ACTION: Add one infantry to each planet player controls" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " adds 1 infantry to " + imperium_self.game.planets[i].name);
	      imperium_self.addPlanetaryUnit(action_card_player, imperium_self.game.planets[i].sector, imperium_self.game.planets[i].idx, "infantry");
	    }
	  }
	  return 1;
	}
    });



    this.importActionCard('unstable-planet', {
  	name : "Unstable Planet" ,
  	type : "action" ,
  	text : "ACTION: Choose a hazardous planet and exhaust it. Destroy 3 infantry on that planet if they exist" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a hazardous planet and exhaust it. Destroy 3 infantry on that planet if they exist" ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
	        if (planet.type == "hazardous") { return 1; } return 0;
              },
	      function(planet) {
                imperium_self.addMove("expend\t"+player+"\tplanet\t"+planet);

		let planet_obj   = imperium_self.game.planets[planet];	
		let planet_owner = parseInt(planet_obj.owner);
		let planet_res   = parseInt(planet_obj.resources);

		let infantry_destroyed = 0;

		if (planet_owner >= 0) {
		  for (let i = 0; i < planet_obj.units[planet_owner-1].length; i++) {
		    if (infantry_destroyed < 3) {
		      if (planet_obj.units[planet_owner-1][i].type == "infantry") {
		        imperium_self.addMove("destroy_unit\t"+action_card_player+"\t"+planet_owner+"\t"+"ground"+"\t"+planet_obj.sector+"\t"+planet_obj.idx+"\t"+"1");
		    	infantry_destroyed++;
		      }
		    }
		  }
		}
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });






    this.importActionCard('Covert Operation', {
  	name : "Covert Operation" ,
  	type : "action" ,
  	text : "ACTION: Choose a player. They give you one of their action cards, if possible" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player. They give you one of their action cards: ",
              function(player) {
	        if (player != imperium_self.game.player) { return 1; } return 0;
              },
	      function(player) {
                imperium_self.addMove("pull\t"+imperium_self.game.player+"\t"+player+"\t"+"action"+"\t"+"random");
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " pulls a random action card from " + imperium_self.returnFaction(player));
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('tactical-bombardment', {
  	name : "Tactical Bombardment" ,
  	type : "action" ,
  	text : "ACTION: Choose a sector in which you have ships with bombardment. Exhaust all planets in that sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector in which you have ships with bombardment. Exhaust all planets in that sector" ,
              function(sector) {
	        if (imperium_self.doesSectorContainPlayerUnit(player, sector, "dreadnaught") == 1) { return 1; }
	        if (imperium_self.doesSectorContainPlayerUnit(player, sector, "warsun") == 1) { return 1; }
		return 0;
              },

	      function(sector) {

		let planets_in_sector = imperium_self.game.sectors[sector].planets;
		for (let i = 0; i < planets_in_sector.length; i++) {
                  imperium_self.addMove("expend\t"+player+"\tplanet\t"+planets_in_sector[i]);
		  imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " exhausts " + imperium_self.game.planets[planets_in_sector[i]].name);
		}
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('signal-jamming', {
  	name : "Signal Jamming" ,
  	type : "action" ,
  	text : "ACTION: Choose a player. They must activate a system in or next to a system in which you have a ship" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector in which you have a ship or one adjacent to one: ",
              function(sector) {
	        if (imperium_self.isPlayerShipAdjacentToSector(action_card_player, sector)) {
		  return 1;
		}
	        return 0;
              },
	      function(sector) {

            	imperium_self.playerSelectPlayerWithFilter(
	          "Select a player to signal jam in that sector: " ,
                  function(p) {
	            if (p != imperium_self.game.player) { return 1; } return 0;
                  },
	          function(p) {
                    imperium_self.addMove("activate\t"+p+"\t"+sector);
		    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(p) + " suffers signal jamming in " + imperium_self.game.sectors[sector].name);
		    imperium_self.endTurn();
		    return 0;
	          },
	          null
	        );
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('unexpected-action', {
  	name : "Unexpected Action" ,
  	type : "action" ,
  	text : "ACTION: Deactivate a stystem you have activated. Gain one command or strategy token: ", 
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector that you have activated and deactivate it: " ,
              function(sector) {
		if (imperium_self.game.sectors[sector].activated[action_card_player-1] == 1) {
		  return 1;
		}
              },
	      function(sector) {
                imperium_self.addMove("purchase\t"+action_card_player+"\tcommand\t"+"1");
                imperium_self.addMove("deactivate\t"+action_card_player+"\t"+sector);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " deactivates " + imperium_self.game.sectors[sector].name);
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('in-the-silence-of-space', {
  	name : "In the Silence of Space" ,
  	type : "instant" ,
  	text : "Your ships may move through sectors with other player ships this turn: " ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_move_through_sectors_with_opponent_ships = 1;
	  return 1;
	}
    });



    this.importActionCard('upgrade', {
  	name : "Upgrade" ,
  	type : "activate" ,
  	text : "After you activate a system containing one of your ships, place a Dreadnaught from your reinforcements in that sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let sector = imperium_self.game.state.activated_sector;
	  if (imperium_self.doesSectorContainPlayerShips(action_card_player, sector)) {
	    imperium_self.addSpaceUnit(action_card_player, sector, "dreadnaught");
	  }

	  return 1;
	}
    });



    this.importActionCard('disable', {
  	name : "Disable" ,
  	type : "activate" ,
  	text : "Your fleet cannot be hit by PDS fire or Planetary Defense during this invasion" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_immune_to_pds_fire = 1;
	  imperium_self.game.players_info[action_card_player-1].temporary_immune_to_planetary_defense = 1;
	  return 1;
	}
    });





    this.importActionCard('bunker', {
  	name : "Bunker" ,
  	type : "bombardment_defender" ,
  	text : "During this bombardment, attacker gets -4 applied to each bombardment roll." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_bombardment_combat_roll_modifier = -4;
	  }
	  return 1;
	}
    });


    this.importActionCard('thunder-from-the-heavens', {
  	name : "Thunder from the Heavens" ,
  	type : "bombardment_attacker" ,
  	text : "During this bombardment, attacker gets +2 applied to each bombardment roll." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_bombardment_combat_roll_modifier = 2;
	  }
	  return 1;
	}
    });




    this.importActionCard('sabotage1', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage2', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage3', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage4', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });



    this.importActionCard('fire-team', {
  	name : "Fire Team" ,
  	type : "ground_combat" ,
  	text : "Reroll up to 15 dice during this round of ground combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].combat_dice_reroll = 15; // 15 
	  return 1;

	}
    });


    this.importActionCard('parley', {
  	name : "Parley" ,
  	type : "ground_combat" ,
  	text : "Return invading infantry to space if player ships exist in the sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	
	  if (player == action_card_player) {

	    let sector = imperium_self.game.state.ground_combat_sector;
	    let planet_idx = imperium_self.game.state.ground_combat_planet_idx;
	    let attacker = imperium_self.game.state.ground_combat_attacker;

	    let sys = imperium_self.returnSectorAndPlanets(sector);

	    let attacker_infantry = sys.p[planet_idx].units[attacker-1];
	    sys.p[planet_idx].units[attacker-1] = [];;

	    for (let i = 0; i < sys.s.units[attacker-1].length; i++) {
	      while (imperium_self.returnRemainingCapacity(sys.s.units[attacker-1][i]) > 0 && attacker_infantry.length > 0) {
		imperium_self.loadUnitByJSONOntoShip(attacker, sector, i, JSON.stringify(attacker_infantry[0]));
	        attacker_infantry.splice(0, 1);
	      }
	    }

	  }

	  imperium_self.updateSectorGraphics(sector);
	  return 1;

	}

    });




/*****
    this.importActionCard('confusing-legal-text', {
  	name : "Confusing Legal Text" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his votes, pick another player to win if you are the leading candidate" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

//	    imperium_self.game.state.votes_cast[bribing_player-1].votes += goods_spent;

	  if (imperium_self.agenda_cards[card].elect === "player") {

            let winning_options = [];
            for (let i = 0; i < imperium_self.game.state.choices.length; i++) {
              winning_options.push(0);
            }
            for (let i = 0; i < imperium_self.game.players.length; i++) {
              winning_options[imperium_self.game.state.how_voted_on_agenda[i]] += imperium_self.game.state.votes_cast[i];
            }

            //
            // determine winning option
            //
            let max_votes_options = -1;
            let max_votes_options_idx = 0;
            for (let i = 0; i < winning_options.length; i++) {
              if (winning_options[i] > max_votes_options) {
                max_votes_options = winning_options[i];
                max_votes_options_idx = i;
              }
            }

            let total_options_at_winning_strength = 0;
            for (let i = 0; i < winning_options.length; i++) {
              if (winning_options[i] == max_votes_options) { total_options_at_winning_strength++; }
            }

	    if (total_options_at_winning_strength == 1) {

	      //
	      // cast 1000 votes for someone else
	      //
	      if (imperium_self.game.player == action_card_player) { 
                html = '<div class="sf-readable">Who do you wish to be elected instead? </div><ul>';
	        for (let i = 0; i < imperium_self.game.state.choices.length; i++) {
		  if (imperium_self.game.state.choices[i] != imperium_self.game.player) {
		    html += '<li class="options textchoice" id="'+imperium_self.game.state.choices[i]+'">'+imperium_self.returnFaction(imperium_self.game.state.choices[i])+'</li>';
		  }
	        }
		html += '</ul>';
	      }

      	      $('.textchoice').off();
	      $('.textchoice').on('click', function() {

		let action = $(this).attr("id");

		imperium_self.addMove("vote\t"+imperium_self.returnActiveAgenda()+"\t"+action+"\t"+"1000");
		imperium_self.endTurn();
		return 0;

	      });
	
	      return 0;
	    } else {
	      return 1;
	    }
	  }
	  return 1;
	}
    });
****/


    this.importActionCard('distinguished-councillor', {
  	name : "Distinguished Coucillor" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his votes, cast an additional 5 votes" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          imperium_self.game.state.votes_cast[action_card_player-1] += 5;
	  imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " casts an additional 5 votes with Distinguished Councillor");

	  return 1;

	}
    });


    this.importActionCard('bribery', {
  	name : "Bribery" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his vote, spend any number of trade goods to purchase the same number of additional voutes" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

	    let html  = '<div class="sf-readable">Spend any number of trade goods to purchase additional votes: </div><ul>';
	    if (imperium_self.game.players_info[action_card_player-1].goods > 0) {
	      html   += '<li class="textchoice" id="0">0 votes</li>';
	      for (let i = 1; i <= imperium_self.game.players_info[action_card_player-1].goods+1; i++) {
	        if (i == 1) { html   += '<li class="textchoice" id="1">'+i+' vote</li>'; }
	        else { html   += '<li class="textchoice" id="'+i+'">'+i+' votes</li>'; }
	      }
	    } else {
	      html   += '<li class="textchoice" id="0">0 votes</li>';
            }
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.textchoice').off();
	    $('.textchoice').on('click', function() {

	      let action = $(this).attr("id");

	      imperium_self.addMove("bribery\t"+action_card_player+"\t"+action);
	      imperium_self.endTurn();
	    });

	  }

	  return 0;

	},
	handleGameLoop : function(imperium_self, qe, mv) {

	  if (mv[0] == "bribery") {

	    let bribing_player = parseInt(mv[1]);
	    let goods_spent = parseInt(mv[2]);
	    imperium_self.game.queue.splice(qe, 1);

	    imperium_self.game.state.votes_cast[bribing_player-1].votes += goods_spent;
	    imperium_self.game.players_info[bribing_player-1].goods -= goods_spent;
	    if (goods_spent == 1) {
	      imperium_self.updateLog(imperium_self.returnFaction(bribing_player) + " bribes the Council for " + goods_spent + " additional vote");
	    } else {
	      imperium_self.updateLog(imperium_self.returnFaction(bribing_player) + " bribes the Council for " + goods_spent + " additional votes");
	    }

	    return 1;
	  }

	  return 1;

	}
    });






    //
    // invisible and unwinnable rider attached to prevent voting
    //
    this.importActionCard('assassinate-representative', {
  	name : "Assassinate Representative" ,
  	type : "pre_agenda" ,
  	text : "Choose a player. That player cannot vote on the Agenda" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectPlayerWithFilter(
              "Select a player who will not be able to vote on this Agenda: " ,
              function(player) {
                if (player != imperium_self.game.player) { return 1; } return 0;
              },
              function(player) {
                imperium_self.addMove("rider\t"+player+"\tassassinate-representative\t-1");
                //imperium_self.addMove("assassinate_representative\t"+imperium_self.game.player+"\t"+player);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " assassinates the voting representative of " + imperium_self.returnFaction(player));
                imperium_self.endTurn();
                return 0;
              },
              null,
            );
	  }
	  return 0;
        },
    });




    this.importActionCard('ancient-burial-sites', {
  	name : "Ancient Burial Sites" ,
  	type : "pre_agenda" ,
  	text : "Chose a player. That player loses a maximum of four votes on this agenda" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectPlayerWithFilter(
              "Select a player to lose 4 votes: " ,
              function(player) {
                if (player != imperium_self.game.player) { return 1; } return 0;
              },
              function(player) {
                imperium_self.addMove("ancient_burial\t"+imperium_self.game.player+"\t"+player);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " finds soe dirt on the voting representative of " + imperium_self.returnFaction(player));
                imperium_self.endTurn();
                return 0;
              },
              null,
            );
	  }
	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "ancient_burial") {

            let player = parseInt(mv[1]);
            let target = parseInt(mv[2]);
            imperium_self.game.queue.splice(qe, 1);

            imperium_self.game.state.votes_available[target-1] -= 4;
            if (imperium_self.game.state.votes_available[target-1] < 0) { 
              imperium_self.game.state.votes_available[target-1] = 0;
            }

            return 1;
          }

	  return 1;
        }

    });







    this.importActionCard('leadership-rider', {
  	name : "Leadership Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to gain two strategy tokens and 1 command token" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
            let msg  = 'On which choice do you wish to place your Leadership rider?';
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"diplomacy-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium.self.game.player)+" has placed a Leadership Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
          imperium_self.game.players_info[action_card_player-1].strategy_tokens += 2;
          imperium_self.game.players_info[action_card_player-1].command_tokens += 1;
	  imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " gains 2 strategy tokens and 1 command token");
	  return 1;
	}
    });






    this.importActionCard('diplomacy-rider', {
  	name : "Diplomacy Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to have others activate system with planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg  = 'On which choice do you wish to place your Diplomacy rider?';
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"diplomacy-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Diplomacy Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {

	  //
	  // rider is executed
	  //
	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectSectorWithFilter(
              "Select a sector with a planet you control to mire in diplomatic conflict: ",
              function(sector) {
		for (let i = 0; i < imperium_self.game.sectors[sector].planets.length; i++) {
  		  if (imperium_self.game.planets[imperium_self.game.sectors[sector].planets[i]].owner == imperium_self.game.player) { return 1; } return 0;
                }
              },
              function(sector) {
                for (let b = 0; b < imperium_self.game.players_info.length; b++) {
                  imperium_self.addMove("activate\t"+(b+1)+"\t"+sector);
                }
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFactionNickname(imperium_self.game.player) + " uses Diplomacy Rider to protect " + sector);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	  }
	  return 0;
	}
    });





    this.importActionCard('politics-rider', {
  	name : "Politics Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to gain three action cards and the speaker token" ,
        playActionCard : function(imperium_self, player, action_card_player, card) {
          if (imperium_self.game.player == action_card_player) {
            let active_agenda = imperium_self.returnActiveAgenda();
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;
            let msg  = 'On which choice do you wish to place your Politics rider?';
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"politics-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Politics Rider on "+choices[choice]);
              imperium_self.endTurn();
            });
          }
          return 0;
        },
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	
	  if (imperium_self.game.player == action_card_player) {

	    // three action cards
            imperium_self.addMove("gain\t"+imperium_self.game.player+"\taction_cards\t3");
            imperium_self.addMove("DEAL\t2\t"+imperium_self.game.player+"\t3");
            imperium_self.addMove("NOTIFY\tdealing two action cards to player "+player);

	    // and change speaker
	    let html = 'Make which player the speaker? <ul>';
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              html += '<li class="textchoice" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
            }
            html += '</ul>';
            imperium_self.updateStatus(html);

            let chancellor = imperium_self.game.player;

            $('.textchoice').off();
            $('.textchoice').on('click', function() {
              let chancellor = (parseInt($(this).attr("id")) + 1);
	      imperium_self.addMove("change_speaker\t"+chancellor);
	      imperium_self.endTurn();
	    });
	  } 

 	  return 0;
	}
    });




    this.importActionCard('construction-rider', {
  	name : "Construction Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to place a space dock on a planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (action_card_player == imperium_self.game.player) {

            let active_agenda = imperium_self.returnActiveAgenda();
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg = 'On which choice do you wish to place the Construction rider?';
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"construction-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Construction Rider on "+choices[choice]);
              imperium_self.endTurn();
            });

	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	  if (action_card_player == imperium_self.game.player) {
            imperium_self.playerSelectPlanetWithFilter(
              "Select a planet you control without a Space Dock: ",
              function(planet) {
  		if (imperium_self.game.planets[planet].owner == imperium_self.game.player && imperium_self.doesPlanetHaveSpaceDock(planet) == 0) { return 1; } return 0;
              },
              function(planet) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t"+imperium_self.game.planets[planet].idx+"\t"+"spacedock"+"\t"+imperium_self.game.planets[planet].sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " builds a Space Dock in " + imperium_self.game.sectors[imperium_self.game.planets[planet].sector].name);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	  }
	  return 0;
	}
    });



    this.importActionCard('trade-rider', {
  	name : "Trade Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to receive 5 trade goods" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();

            let html  = 'On which choice do you wish to place your Trade rider?';
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
	    imperium_self.playerSelectChoice(html, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"trade-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Trade Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
 
 	  return 0;
	},
	playActionCardEvent(imperium_self, player, action_card_player, card) {
	  imperium_self.game.queue.push("purchase\t"+action_card_player+"\t"+"goods"+"\t"+5);
	  imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " gains 5 Trade Goods through their Trade Rider");
	  return 1;
	}
    });




    this.importActionCard('warfare-rider', {
  	name : "Warfare Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to place a dreadnaught in a system with one of your ships: " ,
        playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            let active_agenda = imperium_self.returnActiveAgenda();

            let msg  = 'On which choice do you wish to place your Warfare Rider?';
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"warfare-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Warfare Rider on "+choices[choice]);
              imperium_self.endTurn();
            });
          }

          return 0;
        },
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
              "Select a sector which contains at least one of your ships: ",
              function(sector) {
                return imperium_self.doesSectorContainPlayerShips(action_card_player, sector);
              },
              function(sector) {

                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdreadnaught\t"+sector);
                imperium_self.addMove("NOTIFY\tAdding dreadnaught to board");
                imperium_self.endTurn();
                return 0;

              },
              null
            );
          }
	  return 0;
	}
    });


    this.importActionCard('technology-rider', {
  	name : "Technology Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to research a technology for free" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();

            let msg  = 'On which choice do you wish to place your Technology rider?';
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"technology-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Technology Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
 
 	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    imperium_self.playerResearchTechnology(function(tech) {
	      imperium_self.endTurn();
	    });
	  } 
 	  return 0;
	}
    });


    this.importActionCard('imperial-rider', {
  	name : "Imperial Rider" ,
  	type : "rider" ,
  	text : "Player gains 1 VP" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg = 'On which choice do you wish to place the Imperial rider?';	
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"imperial-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed an Imperial Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });

	  }

	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
          imperium_self.game.players_info[action_card_player-1].vp += 1;
          imperium_self.game.players_info[action_card_player-1].objectives_scored.push("imperial-rider");
	  return 1;
	}
    });







    this.importActionCard('intercept', {
  	name : "Intercept" ,
  	type : "retreat" ,
  	text : "After your opponent declares a retreat in space combat, they cannot retreat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  imperium_self.game.players[action_card_player-1].temporary_opponent_cannot_retreat = 1;
	  return 1;

        }
    });





    this.importActionCard('courageous-to-the-end', {
  	name : "Courageous to the End" ,
  	type : "space_combat_after" ,
  	text : "For one ship lost in last round of space combat, fire twice. With each hit your opponent must destroy a ship of their chosing" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round.length > 0) {

	    let lowest_combat_roll_ship = 10;
	    for (let i = 0; i < imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round[i]; i++) {
	      let unittype = imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round[i];
	      let unit = imperium_self.returnUnit(unittype, player);
	      if (unit.combat < lowest_combat_roll_ship) { lowest_combat_roll_ship = unit.combat; }
	    }

	    let roll1 = imperium_self.rollDice(10);
	    let roll2 = imperium_self.rollDice(10);

	    let counterparty = imperium_self.game.state.space_combat_attacker;
	    if (counterparty == player) { counterparty = imperium_self.game.state.space_combat_defender; }

	    let total_ships_to_destroy = 0;

	    if (roll1 >= lowest_combat_roll_ship) {
	      total_ships_to_destroy++;
	    }
	    if (roll2 >= lowest_combat_roll_ship) {
	      total_ships_to_destroy++;
	    }

	    if (imperium_self.game.player == action_card_player) {
	      imperium_self.addMove("player_destroy_unit"+"\t"+player+"\t"+counterparty+"\t"+total_ships_to_destroy+"\t"+"space"+"\t"+imperium_self.game.state.space_combat_sector+"\t"+0);
	      imperium_self.endTurn();
	    }

	    return 0;

	  }

	  return 1;
        }
    });




    this.importActionCard('salvage', {
  	name : "Salvage" ,
  	type : "space_combat_victory" ,
  	text : "If you win a space combat, opponent gives you all their commodities" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (player == action_card_player) {

  	    let a = imperium_self.game.players_info[imperium_self.game.state.space_combat_attacker];
	    let d = imperium_self.game.players_info[imperium_self.game.state.space_combat_defender];


	    if (d.commodities > 0) {
	      a.goods += d.commodities;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.space_combat_attacker) + " takes " + d.commodities + " in trade goods from commodities lost in combat");
	      d.commodities = 0;
	    }
	  
	    return 1;
	  }
        }
    });



    this.importActionCard('shields-holding1', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding2', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding3', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding4', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });


    this.importActionCard('maneuvering-jets1', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets2', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets3', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets4', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });



    this.importActionCard('emergency-repairs', {
  	name : "Emergency Repairs" ,
  	type : "assign_hits" ,
  	text : "Repair all damaged ships not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // repairs all non-full-strength units for the action_card_player
	  //
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let i = 0; i < sys.s.units[action_card_player-1].length; i++) {
	    if (sys.s.units[action_card_player-1][i].strength < sys.s.units[action_card_player-1][i].max_strength) {
	      sys.s.units[action_card_player-1][i].strength = sys.s.units[action_card_player-1][i].max_strength;
	    }
	  }

	  return 1;

	}

    });

    this.importActionCard('experimental-fighter-prototype', {
  	name : "Experimental Fighter Prototype" ,
  	type : "space_combat" ,
  	text : "Your fighters get +2 on their combat rolls for a single round of space combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units[action_card_player-1].length; p++) {
            let unit = sys.s.units[action_card_player-1][p];
	    if (unit.type == "fighter") {
	      unit.temporary_combat_modifier += 2;
	    }
	  }

	  return 1;

	}

    });

    this.importActionCard('moral-boost', {
  	name : "Moral Boost" ,
  	type : "combat" ,
  	text : "Apply +1 to each of your units' combat rolls during this round of combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.state.space_combat_sector) {
            let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	    for (let i = 0; i < sys.s.units[action_card_player-1].length; i++) {
              let unit = sys.s.units[action_card_player-1][i];
	      unit.temporary_combat_modifier += 1;
	    }
	  }

	  if (imperium_self.game.state.ground_combat_sector) {
	    if (imperium_self.game.state.ground_combat_planet_idx) {
              let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	      for (let p = 0; i < sys.p.length; p++) {
	        for (let i = 0; i < sys.p[p].units[action_card_player-1].length; i++) {
                  let unit = sys.p[p].units[action_card_player-1][i];
	          unit.temporary_combat_modifier += 1;
	        }
	      }
	    }
	  }
	  return 1;
        }
    });



    this.importActionCard('experimental-battlestation', {
  	name : "Experimental Battlestation" ,
  	type : "pre_pds" ,
  	text : "After a player moves ships into a sector, a space dock in that or an adjacent sector can fire 3 PDS shots" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  imperium_self.updateLog("Experimental Battlestation");

	  let sector = imperium_self.game.state.activated_sector;
	  let adjacent_sectors = imperium_self.returnAdjacentSectors(sector);
	  adjacent_sectors.push(sector);

	  let has_experimental_battlestation = 0;

	  for (let n = 0; n < adjacent_sectors.length; n++) {
	    let sys = imperium_self.returnSectorAndPlanets(adjacent_sectors[n]);
	    for (let p = 0; p < sys.p.length; p++) {
	      if (sys.p[p].owner == imperium_self.game.player) {
  	        if (imperium_self.doesPlayerHaveSpaceDock(sys.p[p])) {
		  imperium_self.game.players_info[action_card_player-1].experimental_battlestation = sector;
		  return 1;
		}
	      }
	    }
	  }

	  return 1;
        }
    });










    this.importActionCard('direct-hit1', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit2', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit3', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit4', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });






    this.importActionCard('skilled-retreat1', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "skilled_retreat") {

            let player = parseInt(mv[1]);
            let destination = mv[2];
	    let source = mv[3];
            imperium_self.game.queue.splice(qe, 1);

	    let dsys = imperium_self.returnSectorAndPlanets(destination);
	    let ssys = imperium_self.returnSectorAndPlanets(source);

	    //
	    // move the units over
	    //
	    for (let i = 0; i < ssys.s.units[player-1].length; i++) {
	      dsys.s.units[player-1].push(ssys.s.units[player-1][i]);
	    }
	    ssys.s.units[player-1] = [];

	    imperium_self.saveSystemAndPlanets(dsys);
	    imperium_self.saveSystemAndPlanets(ssys);

	    //
	    // eliminate all commands down to "continue"
	    //
	    for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	      let tmpk = imperium_self.game.queue[i].split("\t");
	      if (tmpk[0] !== "continue") {
		imperium_self.game.queue.splice(i, 1);
	      } else {
		i = -1;
	      }
	    }


	    //
	    // update sector graphics
	    //
	    imperium_self.updateSectorGraphics(ssys.s.sector);
	    imperium_self.updateSectorGraphics(dsys.s.sector);

	    //
	    // handle fleet supply
	    //
	    return imperium_self.handleFleetSupply(player, destination);

          }

          return 1;
        }

    });
    this.importActionCard('skilled-retreat2', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });
    this.importActionCard('skilled-retreat3', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });
    this.importActionCard('skilled-retreat4', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });





    this.importActionCard('public-disgrace', {
  	name : "Public Disgrace" ,
  	type : "activate" ,
  	text : "Force a player who has already picked a strategy card to select another. They select before you do" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  // pick the player

	  // pick the strategy card

	  // insert the card into the strategy_cards list
	  return 0;

	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "public_disgrace") {

            let player = parseInt(mv[1]);
            let target = parseInt(mv[2]);
            let card   = mv[3];
            imperium_self.game.queue.splice(qe, 1);

	    for (let i = 0; i < imperium_self.game.players_info[target-1].strategy.length; i++) {
	      if (imperium_self.game.players_info[target-1].strategy[i] == card) {
		imperium_self.game.players_info[target-1].strategy.splice(i, 1);
	      }
	    }

	    imperium_self.game.queue.push("pickstrategy\t"+player);
	    imperium_self.game.queue.push("reinsert_strategy_card\t"+card);
	    imperium_self.game.queue.push("pickstrategy\t"+target);

	    return 1;

          }

	  if (mv[0] == "reinsert_strategy_card") {

	    let card = mv[1];

            imperium_self.game.state.strategy_cards.push(card);
            imperium_self.game.state.strategy_cards_bonus.push(0);

	    return 1;

	  }
    

          return 1;
        }

    });




returnPlayers(num = 0) {

  var players = [];

  let factions = JSON.parse(JSON.stringify(this.returnFactions()));

  for (let i = 0; i < num; i++) {

    if (i == 0) { col = "color1"; }
    if (i == 1) { col = "color2"; }
    if (i == 2) { col = "color3"; }
    if (i == 3) { col = "color4"; }
    if (i == 4) { col = "color5"; }
    if (i == 5) { col = "color6"; }

    var keys = Object.keys(factions);
    let rf = keys[this.rollDice(keys.length) - 1];

    if (i == 0) {
      if (this.game.options.player1 != undefined) {
        if (this.game.options.player1 != "random") {
          rf = this.game.options.player1;
        }
      }
    }
    if (i == 1) {
      if (this.game.options.player2 != undefined) {
        if (this.game.options.player2 != "random") {
          rf = this.game.options.player2;
        }
      }
    }
    if (i == 2) {
      if (this.game.options.player3 != undefined) {
        if (this.game.options.player3 != "random") {
          rf = this.game.options.player3;
        }
      }
    }
    if (i == 3) {
      if (this.game.options.player4 != undefined) {
        if (this.game.options.player4 != "random") {
          rf = this.game.options.player4;
        }
      }
    }
    if (i == 4) {
      if (this.game.options.player5 != undefined) {
        if (this.game.options.player5 != "random") {
          rf = this.game.options.player5;
        }
      }
    }
    if (i == 5) {
      if (this.game.options.player6 != undefined) {
        if (this.game.options.player6 != "random") {
          rf = this.game.options.player6;
        }
      }
    }

    delete factions[rf];


    players[i] = {};
    players[i].can_intervene_in_action_card = 0;
    players[i].secret_objectives_in_hand = 0;
    players[i].action_cards_in_hand = 0;
    players[i].action_cards_per_round = 1;
    players[i].action_card_limit = 7;
    players[i].action_cards_played = [];
    players[i].new_tokens_per_round = 2;
    players[i].command_tokens = 3;
    players[i].strategy_tokens = 2;
    players[i].fleet_supply = 3;
    players[i].fleet_supply_limit = 16;
    players[i].faction = rf;
    players[i].homeworld = "";
    players[i].color = col;
    players[i].goods = 0;
    players[i].commodities = 0;
    players[i].commodity_limit = 3;
    players[i].vp = 0;
    players[i].passed = 0;
    players[i].strategy_cards_played = [];
    players[i].strategy_cards_retained = [];
    players[i].cost_of_technology_primary = 6;
    players[i].cost_of_technology_secondary = 4;
    players[i].promissary_notes = [];

    //
    // unit limits
    //
    players[i].infantry_limit = 30;
    players[i].fighter_limit = 30;
    players[i].carrier_limit = 4;
    players[i].destroyer_limit = 8;
    players[i].cruiser_limit = 8;
    players[i].dreadnaught_limit = 5;
    players[i].flagship_limit = 1;
    players[i].warsun_limit = 2;
    players[i].pds_limit = 4;
    players[i].spacedock_limit = 3;


    players[i].traded_this_turn = 0;


    //
    // gameplay modifiers (action cards + tech)
    //
    players[i].new_token_bonus_when_issued = 0;
    players[i].action_cards_bonus_when_issued = 0;
    players[i].new_tokens_bonus_when_issued = 0;
    players[i].fleet_move_bonus = 0;
    players[i].temporary_fleet_move_bonus = 0;
    players[i].ship_move_bonus = 0;
    players[i].temporary_ship_move_bonus = 0;
    players[i].fly_through_asteroids = 0;
    players[i].fly_through_nebulas = 0;
    players[i].fly_through_supernovas = 0;
    players[i].move_into_supernovas = 0;
    players[i].reinforce_infantry_after_successful_ground_combat = 0;
    players[i].bacterial_weapon = 0;
    players[i].evasive_bonus_on_pds_shots = 0;
    players[i].perform_two_actions = 0;
    players[i].move_through_sectors_with_opponent_ships = 0;
    players[i].temporary_move_through_sectors_with_opponent_ships = 0;
    players[i].assign_pds_hits_to_non_fighters = 0;
    players[i].reallocate_four_infantry_per_round = 0;
    players[i].may_produce_after_gaining_planet = 0;
    players[i].extra_roll_on_bombardment_or_pds = 0;
    players[i].stasis_on_opponent_combat_first_round = 0;
    players[i].may_repair_damaged_ships_after_space_combat = 0;
    players[i].may_assign_first_round_combat_shot = 0;
    players[i].production_bonus = 0;
    players[i].may_player_produce_without_spacedock = 0;
    players[i].may_player_produce_without_spacedock_production_limit = 0;
    players[i].may_player_produce_without_spacedock_cost_limit = 0;
    players[i].may_produce_warsuns = 0;

    //
    // must target certain units when assigning hits, if possible
    //
    players[i].target_units = [];
    players[i].planets_conquered_this_turn = [];
    players[i].objectives_scored_this_round = [];
    players[i].must_exhaust_at_round_start = [];


    //
    // faction-inspired gameplay modifiers 
    //
    players[i].deep_space_conduits = 0; // treat all systems adjacent to activated system
    players[i].resupply_stations = 0; // gain trade goods on system activation if contains ships 
    players[i].turn_nullification = 0; // after player activates system with ships, can end turn ...

    //
    // roll modifiers
    //
    players[i].space_combat_roll_modifier = 0;
    players[i].ground_combat_roll_modifier = 0;
    players[i].pds_combat_roll_modifier = 0;
    players[i].bombardment_combat_roll_modifier = 0;
    players[i].space_combat_roll_bonus_shots = 0;
    players[i].ground_combat_roll_bonus_shots = 0;
    players[i].pds_combat_roll_bonus_shots = 0;
    players[i].bombardment_combat_roll_bonus_shots = 0;

    players[i].ground_combat_dice_reroll = 0;
    players[i].space_combat_dice_reroll = 0;
    players[i].pds_combat_dice_reroll = 0;
    players[i].bombardment_combat_dice_reroll = 0;
    players[i].combat_dice_reroll = 0;

    players[i].temporary_immune_to_pds_fire = 0;
    players[i].temporary_immune_to_planetary_defense = 0;

    players[i].temporary_space_combat_roll_modifier = 0;
    players[i].temporary_ground_combat_roll_modifier = 0;
    players[i].temporary_pds_combat_roll_modifier = 0;
    players[i].temporary_bombardment_combat_roll_modifier = 0;

    players[i].units_i_destroyed_this_combat_round = [];
    players[i].units_i_destroyed_last_combat_round = [];
    players[i].my_units_destroyed_this_combat_round = [];
    players[i].my_units_destroyed_last_combat_round = [];

    //
    // tech upgrades
    //
    players[i].temporary_green_tech_prerequisite = 0;
    players[i].temporary_yellow_tech_prerequisite = 0;
    players[i].temporary_red_tech_prerequisite = 0;
    players[i].temporary_blue_tech_prerequisite = 0;
    players[i].permanent_green_tech_prerequisite = 0;
    players[i].permanent_yellow_tech_prerequisite = 0;
    players[i].permanent_red_tech_prerequisite = 0;
    players[i].permanent_blue_tech_prerequisite = 0;
    players[i].temporary_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 0;
    players[i].permanent_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 0;
    players[i].temporary_infiltrate_infrastructure_on_invasion = 0;
    players[i].permanent_infiltrate_infrastructure_on_invasion = 0;
    players[i].temporary_opponent_cannot_retreat = 0;
    players[i].permanent_opponent_cannot_retreat = 0;
    players[i].permanent_research_technology_card_must_not_spend_resources = 0;

    if (i == 1) { players[i].color = "yellow"; }
    if (i == 2) { players[i].color = "green"; }
    if (i == 3) { players[i].color = "blue"; }
    if (i == 4) { players[i].color = "purple"; }
    if (i == 5) { players[i].color = "black"; }

    players[i].planets = [];
    players[i].tech = [];
    players[i].tech_exhausted_this_turn = [];
    players[i].upgrades = [];
    players[i].strategy = [];        // strategy cards  

    // scored objectives
    players[i].objectives_scored = [];


    // random
    players[i].lost_planet_this_round = -1; // is player to whom lost

  }

  return players;

}








playerTurn(stage = "main") {

  let html = '';
  let imperium_self = this;
  let technologies = this.returnTechnology();
  let relevant_action_cards = ["action", "main", "instant"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  this.updateLeaderboard();
  this.updateTokenDisplay();

  if (stage == "main") {

    let playercol = "player_color_" + this.game.player;

    let html = '';
    html += '<div class="terminal_header2 sf-readable"><div class="player_color_box ' + playercol + '"></div>' + this.returnFaction(this.game.player) + ":</div><p><ul class='terminal_header3'>";

    if (this.canPlayerPass(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 1) {
        //
        // if we have already moved, we end turn rather than pass
        //
        html += '<li class="option" id="endturn">end turn</li>';
      } else {
        //
        // otherwise we pass
        //
        html += '<li class="option" id="pass">pass</li>';
      }
    } else {
      if (this.game.state.active_player_moved == 1) {
        //
        // if we have already moved, we end turn rather than pass
        //
        html += '<li class="option" id="endturn">end turn</li>';
      }
    }

    if (this.game.state.round == 1 && this.game.state.active_player_moved == 0) {
      if (this.tutorial_move_clicked == 0) {
        html += '<li class="option" id="tutorial_move_ships">move ships</li>';
      }
      if (this.tutorial_produce_clicked == 0) {
        html += '<li class="option" id="tutorial_produce_units">produce units</li>';
      }
    }

    if (this.game.players_info[this.game.player - 1].command_tokens > 0) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="activate">activate sector</li>';
      }
    }
    if (this.canPlayerPlayStrategyCard(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="select_strategy_card">play strategy card</li>';
      }
    }
    if (ac.length > 0 && this.game.tracker.action_card == 0 && this.canPlayerPlayActionCard(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="action">play action card</li>';
      }
    }
    if (this.game.tracker.trade == 0 && this.canPlayerTrade(this.game.player) == 1) {
      html += '<li class="option" id="trade">trade</li>';
    }

    //
    // add tech and factional abilities
    //
    let tech_attach_menu_events = 0;
    let tech_attach_menu_triggers = [];
    let tech_attach_menu_index = [];
    let z = this.returnEventObjects();

    if (this.game.state.active_player_moved == 0) {
      for (let i = 0; i < z.length; i++) {
        if (z[i].menuOptionTriggers(this, "main", this.game.player) == 1) {
          let x = z[i].menuOption(this, "main", this.game.player);
          html += x.html;
          tech_attach_menu_index.push(i);
          tech_attach_menu_triggers.push(x.event);
          tech_attach_menu_events = 1;
        }
      }
    }



    html += '</ul></p>';

    this.updateStatus(html);

    $('.option').on('click', function () {

      let action2 = $(this).attr("id");

      //
      // respond to tech and factional abilities
      //
      if (tech_attach_menu_events == 1) {
        for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
          if (action2 == tech_attach_menu_triggers[i]) {
            $(this).remove();
            imperium_self.game.state.active_player_moved = 1;
            z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "main", imperium_self.game.player);
            return;
          }
        }
      }

      if (action2 == "activate") {
        imperium_self.playerActivateSystem();
      }

      if (action2 == "tutorial_move_ships") {
        imperium_self.tutorial_move_clicked = 1;
        imperium_self.playerAcknowledgeNotice("To move ships select \"activate sector\". Be careful as most ships can only move 1-hexagon and you cannot move ships from sectors that are already activated. You will be able to choose the ships to move, and load infantry and fighters into units that can carry them.", function () {
          imperium_self.playerTurn();
        });
        return;
      }
      if (action2 == "tutorial_produce_units") {
        imperium_self.tutorial_produce_clicked = 1;
        imperium_self.playerAcknowledgeNotice("To produce units, select \"activate sector\" and activate a sector with a space dock (like your home system). You can only have as many non-fighter ships in any sector as your fleet supply, so move your ships out before producing more!", function () {
          imperium_self.playerTurn();
        });
        return;
      }

      if (action2 == "select_strategy_card") {
        imperium_self.playerSelectStrategyCard(function (success) {
          imperium_self.game.state.active_player_moved = 1;
          imperium_self.addMove("strategy_card_after\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.addMove("strategy\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.addMove("strategy_card_before\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.endTurn();
        });
      }
      if (action2 == "action") {
        imperium_self.playerSelectActionCard(function (card) {
          if (imperium_self.action_cards[card].type == "action") { imperium_self.game.state.active_player_moved = 1; }
          imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
          imperium_self.endTurn();
        }, function () { imperium_self.playerTurn(); },
          relevant_action_cards);
      }
      if (action2 == "trade") {
        imperium_self.playerTrade();
        return 0;
      }
      if (action2 == "pass") {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
        imperium_self.addMove("pass\t" + imperium_self.game.player);
        imperium_self.endTurn();
      }
      if (action2 == "endturn") {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
        imperium_self.endTurn();
      }
    });
  }
}




playerPlayActionCardMenu(action_card_player, card, action_cards_played = []) {

  let imperium_self = this;
  let relevant_action_cards = ["counter"];

  for (let i = 0; i < this.game.deck[1].hand.length; i++) {
    if (this.game.deck[1].hand[i].indexOf("sabotage") > -1) {
      this.game.players_info[this.game.player - 1].can_intervene_in_action_card = 1;
    }
  }

  if (this.game.players_info[this.game.player - 1].can_intervene_in_action_card) {

    let html = '<div class="action_card_instructions_hud">' + this.returnFaction(action_card_player) + ' has played an action card:</div>';
    html += '<div class="action_card_name_hud">' + imperium_self.action_cards[card].name + '</div>';
    html += '<div class="action_card_text_hud">';
    html += this.action_cards[card].text;
    html += '</div>';
    html += '<ul>';

    let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);
    if (ac.length > 0) {
      html += '<li class="option" id="cont">continue</li>';
      html += '<li class="option" id="action">play action card</li>';
    } else {
      html += '<li class="option" id="cont">continue</li>';
    }

    let tech_attach_menu_events = 0;
    let tech_attach_menu_triggers = [];
    let tech_attach_menu_index = [];

    let z = this.returnEventObjects();
    for (let i = 0; i < z.length; i++) {
      if (z[i].menuOptionTriggers(this, "action_card", this.game.player) == 1) {
        let x = z[i].menuOption(this, "action_card", this.game.player);
        html += x.html;
        tech_attach_menu_index.push(i);
        tech_attach_menu_triggers.push(x.event);
        tech_attach_menu_events = 1;
      }
    }
    html += '</ul>';

    this.updateStatus(html);

    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");

      //
      // respond to tech and factional abilities
      //
      if (tech_attach_menu_events == 1) {
        for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
          if (action2 == tech_attach_menu_triggers[i]) {
            $(this).remove();
            z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "action_card", imperium_self.game.player);
          }
        }
      }

      if (action2 == "action") {
        imperium_self.playerSelectActionCard(function (card) {
          imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(card);
          imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
          imperium_self.playerPlayActionCardMenu(action_card_player, card);
        }, function () {
          imperium_self.playerPlayActionCardMenu(action_card_player, card);
        }, relevant_action_cards);
      }

      if (action2 == "cont") {
        imperium_self.endTurn();
      }
      return 0;
    });

  } else {

    let notice = '<div class="action_card_instructions_hud">' + this.returnFaction(action_card_player) + ' has played an action card:</div>';
    notice += '<div class="action_card_name_hud">' + imperium_self.action_cards[card].name + '</div>';
    notice += '<div class="action_card_text_hud">';
    notice += this.action_cards[card].text;
    notice += '</div>';

    this.playerAcknowledgeNotice(notice, function () { imperium_self.endTurn(); });
    return 0;
  }

}





playerPlayBombardment(attacker, sector, planet_idx) {

  let imperium_self = this;

  this.game.state.bombardment_sector = sector;
  this.game.state.bombardment_planet_idx = planet_idx;

  let sys = imperium_self.returnSectorAndPlanets(sector);


  //
  // some laws prohibit bombardment against
  //
  if (this.game.state.bombardment_against_cultural_planets == 0 && sys.p[planet_idx].type == "cultural") {
    this.updateLog("Bombardment not possible against cultural planets. Skipping.");
    this.endTurn();
  }
  if (this.game.state.bombardment_against_industrial_planets == 0 && sys.p[planet_idx].type == "industrial") {
    this.updateLog("Bombardment not possible against industrial planets. Skipping.");
    this.endTurn();
  }
  if (this.game.state.bombardment_against_hazardous_planets == 0 && sys.p[planet_idx].type == "hazardous") {
    this.updateLog("Bombardment not possible against hazardous planets. Skipping.");
    this.endTurn();
  }
  //
  // no bombardment of my own planets (i.e. if parlay ends invasion)
  //
  if (sys.p[planet_idx].owner == imperium_self.game.player) {
    imperium_self.endTurn();
    return 0;
  }
  //
  // no bombardment of PDS-defended territories
  //
  if (this.doesPlanetHavePDS(sys.p[planet_idx])) {
    this.updateLog("Bombardment not possible against PDS-defended planets. Skipping.");
    imperium_self.endTurn();
    return 0;
  }

  html = '<div class="sf-readable">Do you wish to bombard ' + sys.p[planet_idx].name + '? </div><ul>';

  let ac = this.returnPlayerActionCards(this.game.player, ["pre_bombardment"]);
  if (ac.length > 0) {
    html += '<li class="option" id="bombard">bombard planet</li>';
    html += '<li class="option" id="action">play action card</li>';
    html += '<li class="option" id="skip">skip bombardment</li>';
  } else {
    html += '<li class="option" id="bombard">bombard planet</li>';
    html += '<li class="option" id="skip">skip bombardment</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pre_bombardment", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pre_bombardment", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pre_bombardment", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.game.players_info[this.game.player - 1].action_cards_played.push(card);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, function () {
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, ["pre_bombardment"]);
    }

    if (action2 == "bombard") {
      imperium_self.addMove("bombard\t" + imperium_self.game.player + "\t" + sector + "\t" + planet_idx);
      imperium_self.endTurn();
    }
    if (action2 == "skip") {
      imperium_self.endTurn();
    }
    return 0;
  });


}


playerAcknowledgeNotice(msg, mycallback) {

  let html = '<div class="sf-readable">' + msg + "</div><ul>";
  html += '<li class="textchoice" id="confirmit">I understand...</li>';
  html += '</ul></p>';

  this.updateStatus(html);

  try {
  $('.textchoice').off();
  $('.textchoice').on('click', function () { mycallback(); });
  } catch (err) {}

  return 0;

}

//
// assign hits to capital ships without triggering events or special abilities
//  -- this is used by special abilities that assign damage outside combat, where they
//  -- cannot be removed by normal factional abilities, etc.
//
 playerAssignHitsCapitalShips(player, sector, total_hits) {

  let imperium_self = this;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let total_targetted_units = 0;

  let targetted_units = ["destroyer","cruiser","carrier","dreadnaught","warsun","flagship"];

  html = '<div class="sf-readable">You must assign ' + total_hits + ' to your capital ships (if possible):</div><ul>';
  html += '<li class="option" id="assign">continue</li>';
  html += '</ul>';
  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "assign") {

      let sys = imperium_self.returnSectorAndPlanets(sector);

      let html = '';
      html += '<div class="sf-readable">Assign <div style="display:inline" id="total_hits_to_assign">' + total_hits + '</div> hits:</div>';
      html += '<ul>';

      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].destroyed == 0 && sys.s.units[imperium_self.game.player - 1][i].strength > 0) {

          let unit = sys.s.units[imperium_self.game.player - 1][i];
          maximum_assignable_hits++;
          if (targetted_units.includes(unit.type)) { total_targetted_units++; }
          html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name;
          if (unit.capacity >= 1) {
	    let fleet = '';
            let fighters = 0;
            let infantry = 0;
            for (let ii = 0; ii < sys.s.units[imperium_self.game.player-1][i].storage.length; ii++) {
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "infantry") {
                infantry++;
              }
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
                fighters++;
              }
            }
            if (infantry > 0 || fighters > 0) {
              fleet += ' ';
              if (infantry > 0) { fleet += infantry + "i"; }
              if (fighters > 0) {
                if (infantry > 0) { fleet += ", "; }
                fleet += fighters + "f";
              }
              fleet += ' ';
            }
	    html += fleet;
	  }
          if (unit.strength > 1) {
            maximum_assignable_hits += (unit.strength - 1);
            html += ' <div style="display:inline" id="player_ship_' + i + '_hits">(';
            for (let bb = 1; bb < unit.strength; bb++) { html += '*'; }
            html += ')';
	    html += '</div>'
          }
          html += '</li>';
        }

      }
      html += '</ul>';

      if (maximum_assignable_hits == 0) {
        imperium_self.endTurn();
        return 0;
      }

      imperium_self.updateStatus(html);

      $('.textchoice').off();
      $('.textchoice').on('click', function () {

        let ship_idx = $(this).attr("id");
        let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

        if (total_targetted_units > 0) {
          if (!targetted_units.includes(selected_unit.type)) {
            salert("You must first assign hits to the required unit types");
            return;
          } else {
            total_targetted_units--;
          }
        }

        imperium_self.addMove("assign_hit\t" + player + "\t" + player + "\t" + imperium_self.game.player + "\tship\t" + sector + "\t" + ship_idx + "\t0"); // last argument --> player should not assign again 


        total_hits--;
        hits_assigned++;

        $('#total_hits_to_assign').innerHTML = total_hits;

        if (selected_unit.strength > 1) {
          selected_unit.strength--;
          let ship_to_reduce = "#player_ship_" + ship_idx + '_hits';
          let rhtml = '';
          if (selected_unit.strength > 1) {
            html += '(';
            for (let bb = 1; bb < selected_unit.strength; bb++) {
              rhtml += '*';
            }
            rhtml += ')';
          }
          $(ship_to_reduce).html(rhtml);
        } else {
          selected_unit.strength = 0;
          selected_unit.destroyed = 0;
          $(this).remove();
        }

        //
        // we have assigned damage, so make sure sys is updated
        //
        imperium_self.saveSystemAndPlanets(sys);

        if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
          imperium_self.updateStatus("Notifying players of hits assignment...");
          imperium_self.endTurn();
          imperium_self.updateStatus("Hits taken...");
        }

      });
    }

  });

}



//
// assign hits to my forces
//
 playerAssignHits(attacker, defender, type, sector, details, total_hits, source = "") {

  let imperium_self = this;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let relevant_action_cards = ["assign_hits"];
  if (details == "pds") { relevant_action_cards = ["post_pds"]; }

  html = '<div class="sf-readable">You must assign ' + total_hits + ' to your fleet:</div><ul>';

  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);
  if (ac.length > 0) {
    html += '<li class="option" id="assign">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="assign">continue</li>';
  }

  let menu_type = "";
  if (details == "pds") { menu_type = "assign_hits_pds"; }
  if (menu_type == "" && type == "space") { menu_type = "assign_hits_space"; }
  if (type == "ground") { menu_type = "assign_hits_ground"; }
  if (type == "anti_fighter_barrage") { menu_type = "assign_hits_anti_fighter_barrage"; }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, menu_type, this.game.player) == 1) {
      let x = z[i].menuOption(this, menu_type, this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          let mytech = this.tech[imperium_self.game.players_info[imperium_self.game.player - 1].tech[tech_attach_menu_index]];
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, menu_type, imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove(imperium_self.game.state.assign_hits_queue_instruction);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
        imperium_self.updateStatus("playing action card before hits assignment");
      }, function () {
        imperium_self.playerAssignHits(attacker, defender, type, sector, details, total_hits, source);
      }, relevant_action_cards);
    }

    if (action2 == "assign") {

      if (imperium_self.game.state.assign_hits_to_cancel > 0) {
        total_hits -= imperium_self.game.state.assign_hits_to_cancel;
        if (total_hits < 0) { total_hits = 0; }
        if (total_hits == 0) {
          imperium_self.updateLog("NOTIFY\t" + imperium_self.returnFactionNickname(imperium_self.game.player) + " does not take any hits");
          imperium_self.endTurn();
          return 0;
        }
      }

      let sys = imperium_self.returnSectorAndPlanets(sector);

      let html = '';
      html += '<div class="sf-readable">Assign <div style="display:inline" id="total_hits_to_assign">' + total_hits + '</div> hits:</div>';
      html += '<ul>';

      let total_targetted_units = 0;
      let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;
      if (type == "anti_fighter_barrage") {
	//
	// overwrite
	//
	targetted_units = [	"fighter", "fighter", "fighter" , "fighter" , "fighter" , 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter" ];
      }

      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].destroyed == 0 && sys.s.units[imperium_self.game.player - 1][i].strength > 0) {

          let unit = sys.s.units[imperium_self.game.player - 1][i];
          maximum_assignable_hits++;
          if (targetted_units.includes(unit.type)) { total_targetted_units++; }
          html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name;
          if (unit.capacity >= 1) {
	    let fleet = '';
            let fighters = 0;
            let infantry = 0;
            for (let ii = 0; ii < sys.s.units[imperium_self.game.player-1][i].storage.length; ii++) {
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "infantry") {
                infantry++;
              }
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
                fighters++;
              }
            }
            if (infantry > 0 || fighters > 0) {
              fleet += ' ';
              if (infantry > 0) { fleet += infantry + "i"; }
              if (fighters > 0) {
                if (infantry > 0) { fleet += ", "; }
                fleet += fighters + "f";
              }
              fleet += ' ';
            }
	    html += fleet;
	  }
          if (unit.strength > 1) {
            maximum_assignable_hits += (unit.strength - 1);
            html += ' <div style="display:inline" id="player_ship_' + i + '_hits">(';
            for (let bb = 1; bb < unit.strength; bb++) { html += '*'; }
            html += ')';
	    html += '</div>'
          }
          html += '</li>';
        }

      }
      html += '</ul>';

      if (maximum_assignable_hits == 0) {
        console.log("ERROR: you had no hits left to assign, bug?");
        console.log("SHIPS: " + JSON.stringify(sys.s.units[imperium_self.game.player - 1]));
//        imperium_self.eliminateDestroyedUnitsInSector(imperium_self.game.player, sector);
//        imperium_self.saveSystemAndPlanets(sys);
//        imperium_self.updateSectorGraphics(sector);
        imperium_self.endTurn();
        return 0;
      }

      imperium_self.updateStatus(html);

      $('.textchoice').off();
      $('.textchoice').on('click', function () {

        let ship_idx = $(this).attr("id");
        let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

        if (total_targetted_units > 0) {
          if (!targetted_units.includes(selected_unit.type)) {
            salert("You must first assign hits to the required unit types");
            return;
          } else {
            total_targetted_units--;
          }
        }

        imperium_self.addMove("assign_hit\t" + attacker + "\t" + defender + "\t" + imperium_self.game.player + "\tship\t" + sector + "\t" + ship_idx + "\t0"); // last argument --> player should not assign again 

        total_hits--;
        hits_assigned++;

        $('#total_hits_to_assign').innerHTML = total_hits;

        if (selected_unit.strength > 1) {
          selected_unit.strength--;
          let ship_to_reduce = "#player_ship_" + ship_idx + '_hits';
          let rhtml = '';
          if (selected_unit.strength > 1) {
            html += '(';
            for (let bb = 1; bb < selected_unit.strength; bb++) {
              rhtml += '*';
            }
            rhtml += ')';
          }
          $(ship_to_reduce).html(rhtml);
        } else {
          selected_unit.strength = 0;
          selected_unit.destroyed = 0;
          $(this).remove();
        }

        //
        // we have assigned damage, so make sure sys is updated
        //
        imperium_self.saveSystemAndPlanets(sys);

        if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
          imperium_self.updateStatus("Notifying players of hits assignment...");
          imperium_self.endTurn();
          imperium_self.updateStatus("Hits taken...");
        }

      });
    }

  });
}





//
// destroy units
//
playerDestroyUnits(player, total, sector, capital = 0) {

  let imperium_self = this;
  let total_hits = total;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  html = '<div class="sf-readable">You must destroy ' + total + ' units in sector: ' + imperium_self.game.sectors[sector].name + ':</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
    let unit = sys.s.units[imperium_self.game.player - 1][i];
    maximum_assignable_hits++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  for (let p = 0; i < sys.p.length; p++) {
    for (let i = 0; i < sys.p[p].units[imperium_self.game.player - 1].length; i++) {
      let unit = sys.p[p].units[imperium_self.game.player - 1][i];
      maximum_assignable_hits++;
      if (targetted_units.includes(unit.type)) { total_targetted_units++; }
      html += '<li class="textchoice player_unit_' + p + '_' + i + '" id="ground_unit_' + p + '_' + i + '">' + unit.name + '</li>';
    }
  }
  html += '</ul>';

  if (maximum_assignable_hits == 0) {
    this.addMove("NOTIFY\t" + this.returnFaction(player) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }


  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {


    let ship_idx = $(this).attr("id");
    let planet_idx = 0;
    let unit_idx = 0;
    let unit_type = "ship";

    if (ship_idx.indexOf("_unit_") > 0) {
      unit_type = "ground";
      let tmpk = ship_idx.split("_");
      planet_idx = tmpk[1];
      unit_idx = tmpk[2];

    }

    let selected_unit = null;
    if (unit_type == "ship") {
      selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];
    } else {
      selected_unit = sys.p[planet_idx].units[imperium_self.game.player - 1][unit_idx];
    }

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    if (unit_type == "ship") {
      imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");
    } else {
      imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "ground\t" + sector + "\t" + planet_idx + "\t" + unit_idx + "\t1");
    }

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total_hits--;
    hits_assigned++;

    if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
      imperium_self.updateStatus("Notifying players of units destroyed...");
      imperium_self.endTurn();
    }

  });
}





//
// destroy ships
//
playerDestroyShips(player, total, sector, capital = 0) {

  let imperium_self = this;
  let total_hits = total;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  html = '<div class="sf-readable">You must destroy ' + total + ' ships in your fleet:</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
    let unit = sys.s.units[imperium_self.game.player - 1][i];
    maximum_assignable_hits++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  html += '</ul>';

  if (maximum_assignable_hits == 0) {
    this.addMove("NOTIFY\t" + this.returnFaction(player) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }


  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let ship_idx = $(this).attr("id");
    let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total_hits--;
    hits_assigned++;

    if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
      imperium_self.updateStatus("Notifying players of hits assignment...");
      imperium_self.endTurn();
    }

  });
}


//
// destroy opponent ships (not assigning hits)
//
playerDestroyOpponentShips(player, total, sector, capital = 0) {

  let imperium_self = this;
  let ships_destroyed = 0;
  let maximum_destroyable_ships = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  let opponent = imperium_self.returnOpponentInSector(player, sector);

  if (opponent == -1) {
    this.addMove("NOTIFY\t" + this.returnFactionNickname(opponent) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }

  html = '<div class="sf-readable">You may destroy ' + total + ' ships in opponent fleet:</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[opponent-1].length; i++) {
    let unit = sys.s.units[opponent-1][i];
    maximum_destroyable_ships++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  html += '</ul>';

  if (maximum_destroyable_ships == 0) {
    this.addMove("NOTIFY\t" + this.returnFactionNickname(opponent) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }

  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

   let ship_idx = $(this).attr("id");
    let selected_unit = sys.s.units[opponent - 1][ship_idx];

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    imperium_self.addMove("destroy_unit\t" + player + "\t" + opponent + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total--;
    ships_destroyed++;

    if (total == 0 || ships_destroyed >= maximum_destroyable_ships) {
      imperium_self.updateStatus("Notifying players of destroyed ships...");
      imperium_self.endTurn();
    }

  });
}








//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlaySpaceCombat(attacker, defender, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let html = '';
  let relevant_action_cards = ["space_combat"];
  if (this.game.state.space_combat_round > 1) {
    relevant_action_cards.push("space_combat_post");
  }

  let opponent = attacker;
  if (imperium_self.game.player == attacker) { opponent = defender; }

  this.game.state.space_combat_sector = sector;

  html = '<div class="sf-readable"><b>Space Combat: round ' + this.game.state.space_combat_round + ':</b><div class="combat_attacker">' + this.returnFaction(attacker) + '</div><div class="combat_attacker_fleet">' + this.returnPlayerFleetInSector(attacker, sector) + '</div><div class="combat_defender">' + this.returnFaction(defender) + '</div><div class="combat_defender_fleet">' + this.returnPlayerFleetInSector(defender, sector) + '</div><ul>';

  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards)
  if (ac.length > 0) {
    html += '<li class="option" id="attack">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="attack">continue</li>';
  }

  //
  // can I retreat
  //
  if (this.canPlayerRetreat(imperium_self.game.player, attacker, defender, sector)) {
    html += '<li class="option" id="retreat">announce retreat</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "space_combat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "space_combat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }, function () {
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }, relevant_action_cards);
    }

    if (action2 == "attack") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.prependMove("ships_fire\t" + attacker + "\t" + defender + "\t" + sector);
      imperium_self.endTurn();
    }

    if (action2 == "retreat") {
      if (imperium_self.canPlayerRetreat(imperium_self.game.player, attacker, defender, sector)) {
        let retreat_options = imperium_self.returnSectorsWherePlayerCanRetreat(imperium_self.game.player, sector);

        let html = '<div clss="sf-readable">Retreat into which Sector? </div><ul>';
        for (let i = 0; i < retreat_options.length; i++) {
	  let sys = imperium_self.returnSectorAndPlanets(retreat_options[i]);
          html += '<li class="option" id="' + i + '">' + sys.s.name + '</li>';
        }
        html += '</ul>';

        imperium_self.updateStatus(html);

        $('.option').off();
        $('.option').on('click', function () {

          let opt = $(this).attr("id");
          let retreat_to_sector = retreat_options[opt];

          imperium_self.addMove("announce_retreat\t" + imperium_self.game.player + "\t" + opponent + "\t" + sector + "\t" + retreat_to_sector);
          imperium_self.endTurn();
          return 0;
        });


      } else {
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }
    }

  });
}




playerRespondToRetreat(player, opponent, from, to) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(to);
  let relevant_action_cards = ["retreat"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);

  let html = '<div class="sf-readable">Your opponent has announced a retreat into ' + sys.s.name + ' at the end of this round of combat: </div><p></p><ul>';
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  html += '<li class="option" id="permit">permit retreat</li>';
  html += '</ul>';

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "retreat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "retreat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';


  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerRespondToRetreat(player, opponent, from, to);
      }, function () {
        imperium_self.playerRespondToRetreat(player, opponent, from, to);
      }.relevant_action_cards);
    }


    if (action2 == "permit") {
      imperium_self.endTurn();
    }
  });
}






//
// ground combat is over -- provide options for scoring cards, action cards
//
playerPlayGroundCombatOver(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let relevant_action_cards = ["ground_combat_victory", "ground_combat_over", "ground_combat_loss"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);

  let html = '';
  let win = 0;

  if (player == sys.p[planet_idx].owner) {
    html = '<div class="sf-readable">Ground Combat is Over (you win): </div><ul>';
    win = 1;
  } else {
    html = '<div class="sf-readable">Space Combat is Over (you lose): </div><ul>';
  }

  if (ac.length > 0) {
    html += '<li class="option" id="ok">acknowledge</li>';
    html += '<li class="option" id="action">action card</li>';
  } else {
    html += '<li class="option" id="ok">acknowledge</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "ground_combat_over", this.game.player) == 1) {
      let x = z[i].menuOption(this, "ground_combat_over", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 === "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayGroundCombatOver(player, sector, planet_idx);
      }, function () {
        imperium_self.playerPlayGroundCombatOver(player, sector, planet_idx);
      });
    }

    if (action2 === "ok") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.endTurn();
    }

  });
}




//
// space combat is over -- provide options for scoring cards, action cards
//
playerPlaySpaceCombatOver(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let relevant_action_cards = ["space_combat_victory", "space_combat_over", "space_combat_loss"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);
  let html = '';
  let win = 0;

  if (this.doesPlayerHaveShipsInSector(player, sector)) {
    html = '<div class="sf-readable">Space Combat is Over (you win): </div><ul>';
    win = 1;
  } else {
    html = '<div class="sf-readable">Space Combat is Over (you lose): </div><ul>';
  }

  if (ac.length > 0) {
    html += '<li class="option" id="ok">acknowledge</li>';
    html += '<li class="option" id="action">action card</li>';
  } else {
    html += '<li class="option" id="ok">acknowledge</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "space_combat_over", this.game.player) == 1) {
      let x = z[i].menuOption(this, "space_combat_over", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat_over", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlaySpaceCombatOver(player, sector, planet_idx);
      }, function () {
        imperium_self.playerPlaySpaceCombatOver(player, sector, planet_idx);
      });
    }

    if (action2 === "ok") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.endTurn();
    }

  });
}







//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayGroundCombat(attacker, defender, sector, planet_idx) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let html = '';

  this.game.state.ground_combat_sector = sector;
  this.game.state.ground_combat_planet_idx = planet_idx;

  let attacker_forces = this.returnNumberOfGroundForcesOnPlanet(attacker, sector, planet_idx);
  let defender_forces = this.returnNumberOfGroundForcesOnPlanet(defender, sector, planet_idx);

  if (sys.p[planet_idx].owner != attacker) {
    html = '<div class="sf-readable">'+this.returnFactionNickname(attacker)+' are invading ' + sys.p[planet_idx].name + ' with ' + attacker_forces + ' infantry. ' + this.returnFactionNickname(defender) + ' is defending with ' + defender_forces + ' infantry. This is round ' + this.game.state.ground_combat_round + ' of ground combat. </div><ul>';
  } else {
    html = '<div class="sf-readable">' + this.returnFactionNickname(defender) + ' are invading ' + sys.p[planet_idx].name + ' with ' + defender_forces + ' infantry. You have ' + attacker_forces + ' infantry remaining. This is round ' + this.game.state.ground_combat_round + ' of ground combat. </div><ul>';
  }

  let ac = this.returnPlayerActionCards(this.game.player, ["combat", "ground_combat"])
  if (ac.length > 0) {
    html += '<li class="option" id="attack">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="attack">continue</li>';
  }


  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "ground_combat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "ground_combat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "ground_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayGroundCombat(attacker, defender, sector, planet_idx);
      }, function () {
        imperium_self.playerPlayGroundCombat(attacker, defender, sector, planet_idx);
      });
    }

    if (action2 == "attack") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.prependMove("infantry_fire\t" + attacker + "\t" + defender + "\t" + sector + "\t" + planet_idx);
      imperium_self.endTurn();
    }

  });
}







//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPDSAttack(player, attacker, sector) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_pds"];
  let can_target_with_pds_fire = 1;

  let defender = -1;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  for (let i = 0; i < sys.s.units.length; i++) {
    if ((i + 1) != attacker) {
      if (sys.s.units[i].length > 0) {
        defender = (i + 1);
      }
    }
  }

  html = '<div class="sf-readable">Do you wish to fire your PDS before moving into the sector?</div><ul>';

  //
  // skip if attacker is immune
  //
  if (defender != -1) {
    if (imperium_self.game.players_info[defender - 1].temporary_immune_to_pds_fire) {
      html = '<div class="sf-readable">' + imperium_self.returnFaction(defender) + ' cannot be targeted by PDS fire during this invasion:</div><ul>';
      can_target_with_pds_fire = 0;
    }
  } else {
    html = '<div class="sf-readable">You cannot target any ships with PDS fire and must skip firing:</div><ul>';
    can_target_with_pds_fire = 0;
  }


  let ac = this.returnPlayerActionCards(player, relevant_action_cards);
  if (1 == 1) {
    html += '<li class="option" id="skip">skip PDS</li>';
  }
  if (can_target_with_pds_fire == 1) {
    html += '<li class="option" id="fire">fire PDS</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pds", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pds", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pds", imperium_self.game.player);
        }
      }
    }


    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPDSAttack(player, attacker, sector);
      }, function () {
        imperium_self.playerPlayPDSAttack(player, attacker, sector);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

    if (action2 == "fire") {
      // prepend so it happens after the modifiers -- defender instead of attacker here
      imperium_self.prependMove("pds_fire\t" + imperium_self.game.player + "\t" + defender + "\t" + sector);
      imperium_self.endTurn();
    };

  });

}


//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPDSDefense(player, attacker, sector) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_pds"];
  let can_target_with_pds_fire = 1;

  html = '<div class="sf-readable">Do you wish to fire your PDS?</div><ul>';

  //
  // skip if attacker is immune
  //
  if (imperium_self.game.players_info[attacker - 1].temporary_immune_to_pds_fire) {
    html = '<div class="sf-readable">Your attacker cannot be targeted by PDS fire during this invasion:</div><ul>';
    can_target_with_pds_fire = 0;
  }


  let ac = this.returnPlayerActionCards(player, relevant_action_cards);
  if (1 == 1) {
    html += '<li class="option" id="skip">skip PDS</li>';
  }
  if (can_target_with_pds_fire == 1) {
    html += '<li class="option" id="fire">fire PDS</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pds", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pds", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pds", imperium_self.game.player);
        }
      }
    }


    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPDSDefense(player, attacker, sector);
      }, function () {
        imperium_self.playerPlayPDSDefense(player, attacker, sector);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

    if (action2 == "fire") {
      // prepend so it happens after the modifiers
      imperium_self.prependMove("pds_fire\t" + imperium_self.game.player + "\t" + attacker + "\t" + sector);
      imperium_self.endTurn();
    };

  });

}


//
// reaching this implies that the player can choose to fire / not-fire
//
playerResolveDeadlockedAgenda(agenda, choices) {

  let imperium_self = this;
  let html = '';

  html = '<div class="sf-readable">The agenda has become deadlocked in the Senate. You - the Speaker - must resolve it: </div><ul>';
  for (let i = 0; i < choices.length; i++) {
    html += '<li class="option" id="' + i + '">' + this.returnNameFromIndex(choices[i]) + '</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    imperium_self.addMove("resolve_agenda\t" + agenda + "\tspeaker\t" + choices[action2]);
    imperium_self.endTurn();
    return 0;

  });
}




//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPreAgendaStage(player, agenda, agenda_idx) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_agenda", "rider"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  if (this.doesPlayerHaveRider(imperium_self.game.player)) {
    html = '<div class="sf-readable">With your riders depending on how the other factions vote, your emissaries track the mood in the Senate closely...:</div><ul>';
  } else {
    html = '<div class="sf-readable">As the Senators gather to vote on ' + this.agenda_cards[agenda].name + ', your emissaries nervously tally the votes in their head:</div><ul>';
  }

  if (1 == 1) {
    html += '<li class="option" id="skip">proceed into Senate</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pre_agenda", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pre_agenda", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "agenda", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPreAgendaStage(player, agenda, agenda_idx);
      }, function () {
        imperium_self.playerPlayPreAgendaStage(player, agenda, agenda_idx);
      }, ["pre_agenda", "rider"]);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

  });

}
playerPlayPostAgendaStage(player, agenda, array_of_winning_options) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["post_agenda"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  if (array_of_winning_options.length > 0) {
    html = '<div class="sf-readable">The Senate has apparently voted for "' + this.returnNameFromIndex(array_of_winning_options[0]) + '". As the Speaker confirms the final tally, you get the feeling the issue may not be fully settled:</div><ul>';
  } else {
    html = '<div class="sf-readable">No-one in the Senate bothered to show-up and vote, leaving the matter to be decided by the Speaker:</div><ul>';
  }
  if (array_of_winning_options.length > 1) {
    html = '<div class="sf-readable">The voting has concluded in deadlock. The Speaker must resolve the agenda:</div><ul>';
  }

  if (1 == 1) {
    html += '<li class="option" id="skip">await results</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "post_agenda", this.game.player) == 1) {
      let x = z[i].menuOption(this, "post_agenda", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "post_agenda", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPostAgendaStage(player, agenda, array_of_winning_options);
      }, function () {
        imperium_self.playerPlayPostAgendaStage(player, agenda, array_of_winning_options);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

  });

}



playerContinueTurn(player, sector) {

  let imperium_self = this;
  let options_available = 0;

  if (this.game.tracker.invasion == undefined) { this.game.tracker = this.returnPlayerTurnTracker(); this.game.tracker.activate_system = 1; }

  //
  // check to see if any ships survived....
  //
  let playercol = "player_color_" + this.game.player;
  let html = "<div class='sf-readable'><div class='player_color_box " + playercol + "'></div>" + this.returnFaction(player) + ": </div><ul>";

  if (this.canPlayerScoreActionStageVictoryPoints(player) != "") {
    html += '<li class="option" id="score">score secret objective</li>';
    options_available++;
  }
  if (this.canPlayerProduceInSector(player, sector) && this.game.tracker.production == 0) {
    html += '<li class="option" id="produce">produce units</li>';
    options_available++;
  }

  if (this.canPlayerInvadePlanet(player, sector) && this.game.tracker.invasion == 0) {
    if (sector == "new-byzantium" || sector == "4_4") {
      if ((imperium_self.game.planets['new-byzantium'].owner != -1) || (imperium_self.returnAvailableInfluence(imperium_self.game.player) + imperium_self.game.players_info[imperium_self.game.player - 1].goods) >= 6) {
        html += '<li class="option" id="invade">invade planet</li>';
        options_available++;
      }
    } else {
      html += '<li class="option" id="invade">invade planet</li>';
      options_available++;
    }
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">reassign infantry</li>';
    options_available++;
  }
  if (this.game.tracker.trade == 0 && this.canPlayerTrade(this.game.player) == 1) {
    html += '<li class="option" id="trade">trade</li>';
  }

  //if (this.canPlayerPlayActionCard(player) && this.game.tracker.action_card == 0) {
  //  html += '<li class="option" id="action">action card</li>';
  //  options_available++;
  //}

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "continue", this.game.player) == 1) {
      let x = z[i].menuOption(this, "continue", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }

  html += '<li class="option" id="endturn">end turn</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "continue", imperium_self.game.player);
        }
      }
    }

    if (action2 == "endturn") {
      imperium_self.addMove("resolve\tplay");
      imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
      imperium_self.endTurn();
      return 0;
    }

    if (action2 == "trade") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerTurn();
      return 0;
    }

    if (action2 == "land") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerSelectInfantryToLand(sector);
      return 0;
    }

    if (action2 == "produce") {

      //
      // check the fleet supply and NOTIFY users if they are about to surpass it
      //
      let fleet_supply_in_sector = imperium_self.returnSpareFleetSupplyInSector(imperium_self.game.player, sector);
      if (fleet_supply_in_sector <= 1) {
        let notice = "You have no spare fleet supply in this sector. Do you still wish to produce more ships?";
        if (fleet_supply_in_sector == 1) {
          notice = "You have fleet supply for 1 additional capital ship in this sector. Do you still wish to produce more ships?";
        }
        let c = sconfirm(notice);
        if (c) {
          imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
          imperium_self.playerProduceUnits(sector);
        }
        return;
      }
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerProduceUnits(sector);
    }

    if (action2 == "invade") {

      //
      // New Byzantium requires 6 influence to conquer
      //
      if (sector === "new-byzantium" || sector == "4_4") {
        if (imperium_self.game.planets['new-byzantium'].owner == -1) {
          if (imperium_self.returnAvailableInfluence(imperium_self.game.player) >= 6) {
            imperium_self.playerSelectInfluence(6, function (success) {
              imperium_self.game.tracker.invasion = 1;
              imperium_self.playerInvadePlanet(player, sector);
            });
          } else {
            salert("The first conquest of New Byzantium requires spending 6 influence, which you lack.");
            return;
          }
          return;
        }
      }

      imperium_self.game.tracker.invasion = 1;
      imperium_self.playerInvadePlanet(player, sector);
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.game.tracker.action_card = 1;
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
      }, function () {
        imperium_self.playerContinueTurn(player, sector);
        return;
      });
    }

    if (action2 == "score") {
      imperium_self.playerScoreActionStageVictoryPoints(imperium_self, function (imperium_self, vp, objective) {
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
        if (vp > 0) { imperium_self.addMove("score\t" + imperium_self.game.player + "\t" + vp + "\t" + objective); }
        imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.push(objective);
        imperium_self.endTurn();
        return;
      });
    }
  });
}





////////////////
// Production //
////////////////
playerBuyTokens(stage = 0, resolve = 1) {

  let imperium_self = this;

  if (this.returnAvailableInfluence(this.game.player) <= 2) {
    this.updateLog("You skip the initiative secondary, as you lack adequate influence...");
    this.updateStatus("Skipping purchase of tokens as insufficient influence...");
    if (resolve == 1) {
      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
    }
    this.endTurn();
    return 0;
  }

  let html = '<div class="sf-readable">Do you wish to purchase any command or strategy tokens, or increase your fleet supply?</div><ul>';

  if (stage == 2) {
    html = '<div class="sf-readable">Leadership has been played. Do you wish to purchase any additional command or strategy tokens, or increase your fleet supply?</div><ul>';
    if (imperium_self.game.state.round == 1)  {
      html = `The Leadership strategy card has been played. This lets you spend 3 influence to purchase additional command tokens, strategy tokens or fleet supply. Do you wish to purchase any additional tokens: </p><ul>`;
    }
  }

  html += '<li class="buildchoice textchoice" id="skip">Do Not Purchase</li>';
  html += '<li class="buildchoice textchoice" id="command">Command Tokens  +<span class="command_total">0</span></li>';
  html += '<li class="buildchoice textchoice" id="strategy">Strategy Tokens +<span class="strategy_total">0</span></li>';
  html += '<li class="buildchoice textchoice" id="fleet">Fleet Supply  +<span class="fleet_total">0</span></li>';
  html += '</ul></p>';
  html += '';
  html += '<div id="buildcost" class="buildcost"><span class="buildcost_total">0</span> influence</div>';
  html += '<div id="confirm" class="buildchoice">click here to finish</div>';

  this.updateStatus(html);


  let command_tokens = 0;
  let strategy_tokens = 0;
  let fleet_supply = 0;
  let total_cost = 0;

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let id = $(this).attr("id");

    if (id == "skip") {
      if (resolve == 1) {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      }
      imperium_self.endTurn();
      return;
    }

    if (id == "confirm") {

      total_cost = 3 * (fleet_supply + command_tokens + strategy_tokens);

      if (resolve == 1) {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
        imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      }

      imperium_self.playerSelectInfluence(total_cost, function (success) {

        if (success == 1) {
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tcommand\t" + command_tokens);
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tcommand\t" + strategy_tokens);
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tfleetsupply\t" + fleet_supply);
          imperium_self.endTurn();
          return;
        } else {
          imperium_self.endTurn();
        }
      });
    };

    //
    //  figure out if we need to load infantry / fighters
    //
    if (id == "command") { command_tokens++; }
    if (id == "strategy") { strategy_tokens++; }
    if (id == "fleet") { fleet_supply++; }

    let divtotal = "." + id + "_total";
    let x = parseInt($(divtotal).html());
    x++;
    $(divtotal).html(x);

    total_cost = 3 * (command_tokens + strategy_tokens + fleet_supply);
    $('.buildcost_total').html(total_cost);


    let return_to_zero = 0;
    if (total_cost > imperium_self.returnAvailableInfluence(imperium_self.game.player)) {
      salert("You cannot buy more tokens than you have influence available to pay");
      return_to_zero = 1;
    }
    if (return_to_zero == 1) {
      total_cost = 0;
      command_tokens = 0;
      strategy_tokens = 0;
      fleet_supply = 0;
      $('.command_total').html(0);
      $('.strategy_total').html(0);
      $('.fleet_total').html(0);
      return;
    }

  });
}





 playerBuyActionCards(stage = 0, resolve = 1) {

  let imperium_self = this;

  let html = '<div class="sf-readable">Do you wish to spend 1 strategy token to purchase 2 action cards?</div><ul>';
  if (stage == 2) {
    html = '<div class="sf-readable">Politics has been played: do you wish to spend 1 strategy token to purchase 2 action cards?</div><ul>';
    if (imperium_self.game.state.round == 1) {
      html = `${imperium_self.returnFaction(imperium_self.game.player)} has played the Politics strategy card. This lets you to spend 1 strategy token to purchase 2 action cards, which provide special one-time abilities. You have ${imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens} strategy tokens. Purchase action cards: </p><ul>`;
    }
  }
  html += '<li class="buildchoice textchoice" id="yes">Purchase Action Cards</li>';
  html += '<li class="buildchoice textchoice" id="no">Do Not Purchase Action Cards</li>';
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let id = $(this).attr("id");

    if (id == "yes") {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " gets action cards");
      imperium_self.addMove("gain\t" + imperium_self.game.player + "\taction_cards\t2");
      imperium_self.addMove("DEAL\t2\t" + imperium_self.game.player + "\t2");
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    } else {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    }
  });

 }




 playerBuySecretObjective(stage = 0, resolve = 1) {

  let imperium_self = this;

  let html = '<div class="sf-readable">Do you wish to spend 1 strategy token to purchase a Secret Objective?</div><ul>';
  if (stage == 2) {
    html = '<div class="sf-readable">The Imperial Strategy card has been played: do you wish to spend 1 strategy token to purchase a Secret Objective?</div><ul>';
    if (imperium_self.game.state.round == 1) {
      html = `${imperium_self.returnFaction(imperium_self.game.player)} has played the Imperial strategy card. This lets you to spend 1 strategy token to purchase an additional secret bjective. You have ${imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens} strategy tokens. Purchase secret objective: </p><ul>`;
    }
  }
  html += '<li class="buildchoice textchoice" id="yes">Purchase Secret Objective</li>';
  html += '<li class="buildchoice textchoice" id="no">Do Not Purchase</li>';
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let id = $(this).attr("id");

    if (id == "yes") {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.addMove("gain\t" + imperium_self.game.player + "\tsecret_objective\t1");
      imperium_self.addMove("DEAL\t6\t" + imperium_self.game.player + "\t1");
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    } else {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    }
  });

}





playerResearchTechnology(mycallback) {

  let imperium_self = this;
  let html = '<div class="sf-readable">You are eligible to upgrade to the following technologies: </div><ul>';

  for (var i in this.tech) {
    if (this.canPlayerResearchTechnology(i)) {
      html += '<li class="option" id="' + i + '">' + this.tech[i].name + '</li>';
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showTechCard(s); });
  $('.option').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideTechCard(s); });
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let i = $(this).attr("id");
    imperium_self.hideTechCard(i);

    //
    // handle prerequisites
    //
    imperium_self.exhaustPlayerResearchTechnologyPrerequisites(i);
    mycallback($(this).attr("id"));

  });

}


//
// return string if YES, empty string if NO
//
canPlayerScoreActionStageVictoryPoints(player) {

  let imperium_self = this;
  let html = "";

  //
  // Secret Objectives - Action Phase
  //
  for (let i = 0; i < imperium_self.game.deck[5].hand.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (imperium_self.secret_objectives[imperium_self.game.deck[5].hand[i]].phase === "action") {
          html += '<li class="option secret3" id="' + imperium_self.game.deck[5].hand[i] + '">' + imperium_self.secret_objectives[imperium_self.game.deck[5].hand[i]].name + '</li>';
        }
      }
    }
  }

  return html;

}




playerScoreActionStageVictoryPoints(imperium_self, mycallback, stage = 0) {

  let html = '';
  let player = imperium_self.game.player;

  html += '<div class="sf-readable">Do you wish to score a secret objective? </div><ul>';

  html += this.canPlayerScoreActionStageVictoryPoints(player);
  html += '<li class="option cancel" id="cancel">cancel</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);
  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    let objective_type = 3;

    if ($(this).hasClass("stage1")) { objective_type = 1; }
    if ($(this).hasClass("stage2")) { objective_type = 2; }
    if ($(this).hasClass("secret3")) { objective_type = 3; }

    if (action === "no") {
      mycallback(imperium_self, 0, "");

    } else {

      let objective = action;
      let vp = 1;
      if (imperium_self.secret_objectives[objective]) {
        if (imperium_self.secret_objectives[objective].vp > 1) { vp = imperium_self.stage_ii_objectives[objective].vp; }
      }

      mycallback(imperium_self, vp, objective);

    }
  });
}



canPlayerScoreVictoryPoints(player, card = "", deck = 1) {

  if (card == "") { return 0; }

  let imperium_self = this;

  // deck 1 = primary
  // deck 2 = secondary
  // deck 3 = secret

  if (deck == 1) {
    let objectives = this.returnStageIPublicObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  if (deck == 2) {
    let objectives = this.returnStageIIPublicObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  if (deck == 3) {
    let objectives = this.returnSecretObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  return 0;

}




playerScoreSecretObjective(imperium_self, mycallback, stage = 0) {

  let html = '';
  let can_score = 0;

  html += '<div class="sf-readable">Do you wish to score any Secret Objectives? </div><ul>';

  // Secret Objectives
  for (let i = 0; i < imperium_self.game.deck[5].hand.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.deck[5].hand[i])) {
          can_score = 1;
          html += '1 VP Secret Objective: <li class="option secret3" id="' + imperium_self.game.deck[5].hand[i] + '">' + imperium_self.game.deck[5].cards[imperium_self.game.deck[5].hand[i]].name + '</li>';
        }
      }
    }
  }

  html += '<li class="option" id="no">I choose not to score...</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);

  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    if (action == "no") {
      mycallback(imperium_self, 0, "");
    } else {
      let objective = action;
      let vp = 1;
      if (imperium_self.secret_objectives[objective]) {
        if (imperium_self.secret_objectives[objective].vp > 1) { vp = imperium_self.secret_objectives[objective].vp; }
      }
      mycallback(imperium_self, vp, objective);
    }
  });
}


playerScoreVictoryPoints(imperium_self, mycallback, stage = 0) {

  let html = '';
  html += '<div class="sf-readable">Do you wish to score any public objectives? </div><ul>';

  // Stage I Public Objectives
  for (let i = 0; i < imperium_self.game.state.stage_i_objectives.length; i++) {

    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.state.stage_i_objectives[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.state.stage_i_objectives[i], 1)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.state.stage_i_objectives[i])) {
          html += '1 VP Public Objective: <li class="option stage1" id="' + imperium_self.game.state.stage_i_objectives[i] + '">' + imperium_self.game.deck[3].cards[imperium_self.game.state.stage_i_objectives[i]].name + '</li>';
        }
      }
    }
  }

  // Stage II Public Objectives
  for (let i = 0; i < imperium_self.game.state.stage_ii_objectives.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.state.stage_ii_objectives[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.state.stage_ii_objectives[i], 2)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.state.stage_ii_objectives[i])) {
          html += '2 VP Public Objective: <li class="option stage2" id="' + imperium_self.game.state.stage_ii_objectives[i] + '">' + imperium_self.game.deck[4].cards[imperium_self.game.state.stage_ii_objectives[i]].name + '</li>';
        }
      }
    }
  }

  /***
      // Secret Objectives
      for (let i = 0 ; i < imperium_self.game.deck[5].hand.length; i++) {
        if (!imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
          if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (!imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.includes(imperium_self.game.deck[5].hand[i])) {
              html += '1 VP Secret Objective: <li class="option secret3" id="'+imperium_self.game.deck[5].hand[i]+'">'+imperium_self.game.deck[5].cards[imperium_self.game.deck[5].hand[i]].name+'</li>';
            }
          }
        }
      }
  ***/

  html += '<li class="option" id="no">I choose not to score...</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);
  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    let objective_type = 3;

    if ($(this).hasClass("stage1")) { objective_type = 1; }
    if ($(this).hasClass("stage2")) { objective_type = 2; }
    if ($(this).hasClass("secret3")) { objective_type = 3; }

    if (action === "no") {
      mycallback(imperium_self, 0, "");
    } else {
      let objective = action;
      let vp = 1;
      if (imperium_self.stage_ii_objectives[objective]) {
        if (imperium_self.stage_ii_objectives[objective].vp > 1) { vp = imperium_self.stage_ii_objectives[objective].vp; }
      }
      mycallback(imperium_self, vp, objective);

    }
  });
}




 playerBuildInfrastructure(mycallback, stage = 1) {

  let imperium_self = this;

  let html = '';

  if (stage == 1) { html += "<div class='sf-readable'>Which would you like to build: </div><ul>"; }
  else { html += "<div class='sf_readable'>You may also build an additional PDS: </div><ul>"; }

  html += '<li class="buildchoice" id="pds">Planetary Defense System</li>';
  if (stage == 1) {
    html += '<li class="buildchoice" id="spacedock">Space Dock</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  let stuff_to_build = [];

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showUnit(s); });
  $('.buildchoice').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideUnit(s); });
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();
    $('.buildchoice').off();

    let id = $(this).attr("id");

    imperium_self.playerSelectPlanetWithFilter(
      "Select a planet on which to build: ",
      function (planet) {
        let existing_units = 0;
        if (imperium_self.game.planets[planet].owner == imperium_self.game.player) {
          for (let i = 0; i < imperium_self.game.planets[planet].units[imperium_self.game.player - 1].length; i++) {
            if (imperium_self.game.planets[planet].units[imperium_self.game.player - 1][i].type == id) {
              existing_units++;
            }
          }
          if (id === "pds") {
            if (existing_units >= imperium_self.game.state_pds_limit_per_planet) { return 0; }
          }
          if (id === "spacedock") {
            if (existing_units >= 1) { return 0; }
          }
          return 1;
        }
        return 0;
      },
      function (planet) {
        if (id == "pds") {
          imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + imperium_self.game.planets[planet].idx + "\tpds\t" + imperium_self.game.planets[planet].sector);
          mycallback(imperium_self.game.planets[planet].sector);
        }
        if (id == "spacedock") {
          imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + imperium_self.game.planets[planet].idx + "\tspacedock\t" + imperium_self.game.planets[planet].sector);
          mycallback(imperium_self.game.planets[planet].sector);
        }
      },
      function() {
        imperium_self.unlockInterface();
        imperium_self.playerBuildInfrastructure(mycallback, stage);
      },
    );
  });

}


 playerProduceUnits(sector, production_limit = 0, cost_limit = 0, stage = 0, warfare = 0) {

  let imperium_self = this;

  let player_fleet = this.returnPlayerFleet(imperium_self.game.player);
  let player_build = {};
  player_build.infantry = 0;
  player_build.fighters = 0;
  player_build.carriers = 0;
  player_build.cruisers = 0;
  player_build.dreadnaughts = 0;
  player_build.destroyers = 0;
  player_build.flagships = 0;
  player_build.warsuns = 0;

  //
  // determine production_limit from sector
  //
  let sys = this.returnSectorAndPlanets(sector);
  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
  available_resources += imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;

  let calculated_production_limit = 0;
  for (let i = 0; i < sys.s.units[this.game.player - 1].length; i++) {
    calculated_production_limit += sys.s.units[this.game.player - 1][i].production;
  }
  for (let p = 0; p < sys.p.length; p++) {
    for (let i = 0; i < sys.p[p].units[this.game.player - 1].length; i++) {
      calculated_production_limit += sys.p[p].units[this.game.player - 1][i].production;
      if (sys.p[p].units[this.game.player - 1][i].type === "spacedock") {
        calculated_production_limit += sys.p[p].resources;
      }
    }
  }

  if (this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock == 1) {
    if (production_limit == 0 && this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_production_limit >= 0) { production_limit = this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_production_limit; }
    if (cost_limit == 0 && this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_cost_limit >= 0) { cost_limit = this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_cost_limit; }
  };

  if (calculated_production_limit > production_limit) { production_limit = calculated_production_limit; }


  let html = '<div class="sf-readable">Produce Units in this Sector: ';
  if (production_limit != 0) { html += '(' + production_limit + ' units max)'; }
  if (cost_limit != 0) { html += '(' + cost_limit + ' cost max)'; }
  html += '</div><ul>';
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="infantry">Infantry - <span class="infantry_total">0</span></li>';
  }
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="fighter">Fighter - <span class="fighter_total">0</span></li>';
  }
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="destroyer">Destroyer - <span class="destroyer_total">0</span></li>';
  }
  if (available_resources >= 3) {
    html += '<li class="buildchoice" id="carrier">Carrier - <span class="carrier_total">0</span></li>';
  }
  if (available_resources >= 2) {
    html += '<li class="buildchoice" id="cruiser">Cruiser - <span class="cruiser_total">0</span></li>';
  }
  if (available_resources >= 4) {
    html += '<li class="buildchoice" id="dreadnaught">Dreadnaught - <span class="dreadnaught_total">0</span></li>';
  }
  if (available_resources >= 8 && this.canPlayerProduceFlagship(imperium_self.game.player)) {
    html += '<li class="buildchoice" id="flagship">Flagship - <span class="flagship_total">0</span></li>';
  }
  if (imperium_self.game.players_info[imperium_self.game.player - 1].may_produce_warsuns == 1) {
    if (available_resources >= 12) {
      html += '<li class="buildchoice" id="warsun">War Sun - <span class="warsun_total">0</span></li>';
    }
  }
  html += '</ul>';
  html += '</p>';
  html += '<div id="buildcost" class="buildcost"><span class="buildcost_total">0 resources</span></div>';
  html += '<div id="confirm" class="buildchoice">click here to build</div>';

  this.updateStatus(html);

  let stuff_to_build = [];

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showUnit(s); });
  $('.buildchoice').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideUnit(s); });
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let id = $(this).attr("id");

    //
    // submit when done
    //
    if (id == "confirm") {

      $('.buildchoice').off();

      let total_cost = 0;
      for (let i = 0; i < stuff_to_build.length; i++) {
        total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
      }

      if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
        total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
      }

      if (warfare == 0) {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      } else {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
        imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      }

      imperium_self.playerSelectResources(total_cost, function (success) {

        if (success == 1) {
          imperium_self.addMove("post_production\t" + imperium_self.game.player + "\t" + sector + "\t" + JSON.stringify(stuff_to_build));
          for (let y = 0; y < stuff_to_build.length; y++) {
            let planet_idx = imperium_self.returnPlayersLeastDefendedPlanetInSector(imperium_self.game.player, sector);
            if (stuff_to_build[y] != "infantry") { planet_idx = -1; }
            imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + planet_idx + "\t" + stuff_to_build[y] + "\t" + sector);
            imperium_self.addMove("setvar"+"\t"+"state"+"\t"+"0"+"\t"+"active_player_has_produced"+"\t"+1)
            imperium_self.game.tracker.production = 1;
          }
          imperium_self.endTurn();
          return;
        } else {
          salert("failure to find appropriate influence");
        }
      });

      return;
    };


    let calculated_total_cost = 0;
    for (let i = 0; i < stuff_to_build.length; i++) {
      calculated_total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
    }
    calculated_total_cost += imperium_self.returnUnitCost(id, imperium_self.game.player);

    //
    // reduce production costs if needed
    //
    if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
      calculated_total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
    }




    //
    // respect production / cost limits
    //
    let return_to_zero = 0;
    if (id == "fighter" && (player_build.fighters + player_fleet.fighters) > imperium_self.game.players_info[imperium_self.game.player - 1].fighter_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].fighter_limit + " fighters on the board");
      return_to_zero = 1;
    }
    if (id == "infantry" && (player_build.infantry + player_fleet.infantry) > imperium_self.game.players_info[imperium_self.game.player - 1].infantry_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].infantry_limit + " infantry on the board");
      return_to_zero = 1;
    }
    if (id == "destroyer" && (player_build.destroyers + player_fleet.destroyers) > imperium_self.game.players_info[imperium_self.game.player - 1].destroyer_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].destroyer_limit + " destroyers on the board");
      return_to_zero = 1;
    }
    if (id == "carrier" && (player_build.carriers + player_fleet.carriers) > imperium_self.game.players_info[imperium_self.game.player - 1].carrier_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].carrier_limit + " carriers on the board");
      return_to_zero = 1;
    }
    if (id == "cruiser" && (player_build.cruisers + player_fleet.cruisers) > imperium_self.game.players_info[imperium_self.game.player - 1].cruiser_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].cruiser_limit + " cruisers on the board");
      return_to_zero = 1;
    }
    if (id == "dreadnaught" && (player_build.dreadnaughts + player_fleet.dreadnaughts) > imperium_self.game.players_info[imperium_self.game.player - 1].dreadnaught_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].dreadnaught_limit + " dreadnaughts on the board");
      return_to_zero = 1;
    }
    if (id == "flagship" && (player_build.flagships + player_fleet.flagships) > imperium_self.game.players_info[imperium_self.game.player - 1].flagships_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].flagship_limit + " flagships on the board");
      return_to_zero = 1;
    }
    if (id == "warsun" && (player_build.warsuns + player_fleet.warsuns) > imperium_self.game.players_info[imperium_self.game.player - 1].warsun_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].warsun_limit + " warsuns on the board");
      return_to_zero = 1;
    }
    if (calculated_total_cost > imperium_self.returnAvailableResources(imperium_self.game.player)) {
      salert("You cannot build more than you have available to pay for it.");
      return_to_zero = 1;
    }
    if (production_limit < stuff_to_build.length && production_limit > 0) {
      salert("You cannot build more units than your production limit");
      return_to_zero = 1;
    }
    if (cost_limit < calculated_total_cost && cost_limit > 0) {
      salert("You cannot build units that cost more than your cost limit");
      return_to_zero = 1;
    }
    if ((stuff_to_build.length + 1) > calculated_production_limit) {
      salert("You cannot build more units than your production limit");
      return_to_zero = 1;
    }
    if (return_to_zero == 1) {
      stuff_to_build = [];
      $('.infantry_total').html(0);
      $('.fighter_total').html(0);
      $('.destroyer_total').html(0);
      $('.carrier_total').html(0);
      $('.cruiser_total').html(0);
      $('.dreadnaught_total').html(0);
      $('.flagship_total').html(0);
      $('.warsun_total').html(0);
      player_build = {};
      player_build.infantry = 0;
      player_build.fighters = 0;
      player_build.carriers = 0;
      player_build.cruisers = 0;
      player_build.dreadnaughts = 0;
      player_build.destroyers = 0;
      player_build.flagships = 0;
      player_build.warsuns = 0;
      return;
    }

    //
    //  figure out if we need to load infantry / fighters
    //
    stuff_to_build.push(id);

    let total_cost = 0;
    for (let i = 0; i < stuff_to_build.length; i++) {
      total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
    }

    let divtotal = "." + id + "_total";
    let x = parseInt($(divtotal).html());
    x++;
    $(divtotal).html(x);

    //
    // reduce production costs if needed
    //
    if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
      total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
      imperium_self.updateLog("Production Costs reduced by 1");
    }

    let resourcetxt = " resources";
    if (total_cost == 1) { resourcetxt = " resource"; }
    $('.buildcost_total').html(total_cost + resourcetxt);

  });

}


playerHandleTradeOffer(faction_offering, their_offer, my_offer, offer_log) {

  let imperium_self = this;

  let goods_offered = 0;
  let goods_received = 0;
  let promissaries_offered = "";
  let promissaries_received = "";

  if (their_offer.promissaries) {
    if (their_offer.promissaries.length > 0) {
      for (let i = 0; i < their_offer.promissaries.length; i++) {
        let pm = their_offer.promissaries[i].promissary;
	let tmpar = pm.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
        if (i > 0) { promissaries_received += ', '; }
        promissaries_received += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }
    }
  }

  if (my_offer.promissaries) {
    if (my_offer.promissaries.length > 0) {
      for (let i = 0; i < my_offer.promissaries.length; i++) {
        let pm = my_offer.promissaries[i].promissary;
	let tmpar = pm.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
        if (i > 0) { promissaries_offered += ', '; }
        promissaries_offered += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }
    }
  }

  let html = '<div class="sf-readable">You have received a trade offer from ' + imperium_self.returnFaction(faction_offering) + '. ';
  html += offer_log;
  html += ': </div><ul>';
  html += `  <li class="option" id="yes">accept trade</li>`;
  html += `  <li class="option" id="no">refuse trade</li>`;
  html += '</ul>';

  imperium_self.updateStatus(html);


  $('.option').off();
  $('.option').on('click', function () {

    let action = $(this).attr("id");

    if (action == "no") {
      imperium_self.addMove("refuse_offer\t" + imperium_self.game.player + "\t" + faction_offering);
      imperium_self.endTurn();
      return 0;
    }

    if (action == "yes") {
      imperium_self.addMove("trade\t" + faction_offering + "\t" + imperium_self.game.player + "\t" + JSON.stringify(their_offer) + "\t" + JSON.stringify(my_offer));
      imperium_self.endTurn();
      return 0;
    }

  });


}


  playerTrade() {

    let imperium_self = this;
    let factions = this.returnFactions();

    let offer_selected = 0;
    let receive_selected = 0;
    let offer_promissaries = [];
    let receive_promissaries = [];
    let max_offer = 0;
    let max_receipt = 0;


    let goodsTradeInterface = function (imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      let receive_promissary_text = 'no promissaries';
      for (let i = 0; i < receive_promissaries.length; i++) {
        if (i == 0) { receive_promissary_text = ''; }
        let pm = receive_promissaries[i];
	let tmpar = pm.promissary.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	if (i > 0) { receive_promissary_text += ', '; }
        receive_promissary_text += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }

      let offer_promissary_text = 'no promissaries';
      for (let i = 0; i < offer_promissaries.length; i++) {
        if (i == 0) { offer_promissary_text = ''; }
        let pm = offer_promissaries[i];
	let tmpar = pm.promissary.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	if (i > 0) { offer_promissary_text += ', '; }
        offer_promissary_text += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }

      let html = "<div class='sf-readable'>Make an Offer: </div><ul>";
      html += '<li id="to_offer" class="option">you give <span class="offer_total">'+offer_selected+'</span> trade goods</li>';
      html += '<li id="to_receive" class="option">you receive <span class="receive_total">'+receive_selected+'</span> trade goods</li>';
      html += '<li id="promissary_offer" class="option">you give <span class="give_promissary">'+offer_promissary_text+'</span></li>';
      html += '<li id="promissary_receive" class="option">you receive <span class="receive_promissary">'+receive_promissary_text+'</span></li>';
      html += '<li id="confirm" class="option">submit offer</li>';
      html += '<li id="cancel" class="option">cancel</li>';
      html += '</ul>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let selected = $(this).attr("id");

        if (selected == "to_offer") { offer_selected++; if (offer_selected > max_offer) { offer_selected = 0; } }
        if (selected == "to_receive") { receive_selected++; if (receive_selected > max_receipt) { receive_selected = 0; } }

	if (selected == "cancel") {
	  imperium_self.playerTurn();
	  return;
	}
	if (selected == "promissary_offer") {
	  promissaryTradeInterface(imperium_self, player, 1, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;
	}
	if (selected == "promissary_receive") {
	  promissaryTradeInterface(imperium_self, player, 2, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;
	}

        if (selected == "confirm") {

          let my_offer = {};
          my_offer.goods = $('.offer_total').html();
	  my_offer.promissaries = offer_promissaries;
          let my_receive = {};
          my_receive.goods = $('.receive_total').html();
	  my_receive.promissaries = receive_promissaries;

          imperium_self.addMove("offer\t" + imperium_self.game.player + "\t" + player + "\t" + JSON.stringify(my_offer) + "\t" + JSON.stringify(my_receive));
          imperium_self.updateStatus("trade offer submitted");
          imperium_self.endTurn();

        }

        $('.offer_total').html(offer_selected);
        $('.receive_total').html(receive_selected);

      });
    }
    //
    // mode = 1 // offer
	      2 // receive
    //
    let promissaryTradeInterface = function (imperium_self, player, mode, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      // offer mine to them
      if (mode == 1) {

        let html = '<div class="sf-readable">Add Promissary to YOUR Offer: </div><ul>';
        for (let i = 0; i < imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes.length; i++) {

	  let pm = imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes[i];
	  let tmpar = pm.split("-");
          let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	  let already_offered = 0;
	  for (let b = 0; b < offer_promissaries.length; b++) {
	    if (offer_promissaries[b].promissary === pm) {
	      already_offered = 1;
	    }
	  }
	  if (already_offered == 0) {
            html += `  <li class="option" id="${i}">${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
        }
        html += `  <li class="option" id="cancel">cancel</li>`;

	imperium_self.updateStatus(html);
        $('.option').off();
        $('.option').on('click', function () {

          let prom = $(this).attr("id");

          if (prom == "cancel") {
            goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
            return 0;
          }
	  
	  let promobj = { player : imperium_self.game.player , promissary : imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes[prom] }
	  offer_promissaries.push(promobj);
          goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;

	});
      }



      // request theirs
      if (mode == 2) {

        let html = '<div class="sf-readable">Request Promissary FROM them: </div><ul>';
        for (let i = 0; i < imperium_self.game.players_info[player-1].promissary_notes.length; i++) {
	  let pm = imperium_self.game.players_info[player-1].promissary_notes[i];
	  let tmpar = pm.split("-");
          let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	  let already_offered = 0;
	  for (let b = 0; b < receive_promissaries.length; b++) {
	    if (receive_promissaries[b].promissary === pm) {
	      already_offered = 1;
	    }
	  }
	  if (already_offered == 0) {
            html += `  <li class="option" id="${i}">${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
        }
        html += `  <li class="option" id="cancel">cancel</li>`;

	imperium_self.updateStatus(html);
        $('.option').off();
        $('.option').on('click', function () {

          let prom = $(this).attr("id");

          if (prom == "cancel") {
            goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
            return 0;
          }
	  
	  let promobj = { player : player , promissary : imperium_self.game.players_info[player-1].promissary_notes[prom] }
	  receive_promissaries.push(promobj);
          goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;

	});


      }

    }
    let mainTradeInterface = function (imperium_self, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      let html = '<div class="sf-readable">Make Trade Offer to Faction: </div><ul>';
      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
        if (imperium_self.game.players_info[i].traded_this_turn == 0 && (i + 1) != imperium_self.game.player) {
          if (imperium_self.arePlayersAdjacent(imperium_self.game.player, (i + 1))) {
            html += `  <li class="option" id="${i}">${factions[imperium_self.game.players_info[i].faction].name}</li>`;
          }
        }
      }
      html += `  <li class="option" id="cancel">cancel</li>`;
      html += '</ul>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let faction = $(this).attr("id");

        if (faction == "cancel") {
          imperium_self.playerTurn();
          return 0;
        }

        max_offer = imperium_self.game.players_info[imperium_self.game.player - 1].commodities + imperium_self.game.players_info[imperium_self.game.player - 1].goods;
        max_receipt = imperium_self.game.players_info[parseInt(faction)].commodities + imperium_self.game.players_info[parseInt(faction)].goods;

	goodsTradeInterface(imperium_self, (parseInt(faction)+1), mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);

      });
    }

    //
    // start with the main interface
    //
    mainTradeInterface(imperium_self, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);

  }




playerSelectSector(mycallback, mode = 0) {

  //
  // mode
  //
  // 0 = any sector
  // 1 = activated actor
  //
  let imperium_self = this;

  $('.sector').off();
  $('.sector').on('click', function () {
    $('.sector').off();
    let pid = $(this).attr("id");
    mycallback(pid);
  });

}




playerSelectPlanet(mycallback, mode = 0) {

  //
  // mode
  //
  // 0 = in any sector
  // 1 = in unactivated actor
  // 2 = controlled by me
  //

  let imperium_self = this;

  let html = "Select a system in which to select a planet: ";
  this.updateStatus(html);

  $('.sector').on('click', function () {

    let sector = $(this).attr("id");
    let sys = imperium_self.returnSectorAndPlanets(sector);

    //
    // exit if no planets are controlled
    //
    if (mode == 2) {
      let exist_controlled_planets = 0;
      for (let i = 0; i < sys.p.length; i++) {
        if (sys.p[i].owner == imperium_self.game.player) {
          exist_controlled_planets = 1;
        }
      }
      if (exist_controlled_planets == 0) {
        salert("Invalid Choice: you do not control planets in that sector");
        return;
      }
    }


    html = '<div class="sf-readable">Select a planet in this system: </div><ul>';
    for (let i = 0; i < sys.p.length; i++) {
      if (mode == 0) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
      }
      if (mode == 1) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
      }
      if (mode == 2 && sys.p[i].owner == imperium_self.game.player) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + '</li>';
      }
    }
    html += '</ul>';


    imperium_self.updateStatus(html);

    $('.option').off();
    $('.option').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showPlanetCard(sector, s); imperium_self.showSectorHighlight(sector); });
    $('.option').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hidePlanetCard(sector, s); imperium_self.hideSectorHighlight(sector); });
    $('.option').on('click', function () {
      let pid = $(this).attr("id");
      imperium_self.hidePlanetCard(sector, pid);
      mycallback(sector, pid);
    });

  });

}



playerSelectInfluence(cost, mycallback) {

  if (cost == 0) { mycallback(1); return; }

  let imperium_self = this;
  let array_of_cards = this.returnPlayerUnexhaustedPlanetCards(this.game.player); // unexhausted
  let array_of_cards_to_exhaust = [];
  let selected_cost = 0;
  let total_trade_goods = imperium_self.game.players_info[imperium_self.game.player - 1].goods;


  let html = "<div class='sf-readable'>Select " + cost + " in influence: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    html += '<li class="cardchoice cardchoice-card" id="cardchoice_' + array_of_cards[z] + '">' + this.returnPlanetCard(array_of_cards[z]) + '</li>';
  }
  if (1 == imperium_self.game.players_info[imperium_self.game.player - 1].goods) {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade good</li>';
  } else {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade goods</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.cardchoice , .textchoice').on('click', function () {

    let action2 = $(this).attr("id");
    let tmpx = action2.split("_");

    let divid = "#" + action2;
    let y = tmpx[1];
    let idx = 0;
    for (let i = 0; i < array_of_cards.length; i++) {
      if (array_of_cards[i] === y) {
        idx = i;
      }
    }



    //
    // handle spending trade goods
    //
    if (action2 == "trade_goods") {
      if (total_trade_goods > 0) {
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tgoods\t1");
        total_trade_goods--;
        selected_cost += 1;

        if (1 == total_trade_goods) {
          $('#trade_goods').html(('' + total_trade_goods + ' trade good'));
        } else {
          $('#trade_goods').html(('' + total_trade_goods + ' trade goods'));
        }
      }
    } else {
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tplanet\t" + array_of_cards[idx]);
      array_of_cards_to_exhaust.push(array_of_cards[idx]);
      $(divid).off();
      $(divid).css('opacity', '0.2');
      selected_cost += imperium_self.game.planets[array_of_cards[idx]].influence;
    }

    if (cost <= selected_cost) {

      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.cardchoice , .textchoice').off();

      mycallback(1);
    }

  });
}






playerSelectStrategyAndCommandTokens(cost, mycallback) {

  if (cost == 0) { mycallback(1); }

  let imperium_self = this;
  let selected_cost = 0;

  let html = "<div class='sf-readable'>Select " + cost + " in Strategy and Command Tokens: </div><ul>";
  html += '<li class="textchoice" id="strategy">strategy tokens - <span class="available_strategy_tokens">'+imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens+'</span></li>';
  html += '<li class="textchoice" id="command">command tokens - <span class="available_command_tokens">'+imperium_self.game.players_info[imperium_self.game.player-1].command_tokens+'</span></li>';
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();

  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "strategy") {
      let x = parseInt($('.available_strategy_tokens').html());
      if (x > 0) {
        selected_cost++;
        $('.available_strategy_tokens').html((x-1));
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      }
    }
    if (action2 == "command") {
      let x = parseInt($('.available_command_tokens').html());
      if (x > 0) {
        selected_cost++;
        $('.available_command_tokens').html((x-1));
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tcommand\t1");
      }
    }

    if (cost <= selected_cost) { 
      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.textchoice').off();
      mycallback(1); 
    }

  });

}



playerSelectResources(cost, mycallback) {

  if (cost == 0) { mycallback(1); return; }

  let imperium_self = this;
  let array_of_cards = this.returnPlayerUnexhaustedPlanetCards(this.game.player); // unexhausted
  let array_of_cards_to_exhaust = [];
  let selected_cost = 0;
  let total_trade_goods = imperium_self.game.players_info[imperium_self.game.player - 1].goods;

  let html = "<div class='sf-readable'>Select " + cost + " in resources: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    html += '<li class="cardchoice cardchoice-card" id="cardchoice_' + array_of_cards[z] + '">' + this.returnPlanetCard(array_of_cards[z]) + '</li>';
  }
  if (1 == imperium_self.game.players_info[imperium_self.game.player - 1].goods) {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade good</li>';
  } else {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade goods</li>';
  }
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();

  $('.cardchoice , .textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    let tmpx = action2.split("_");

    let divid = "#" + action2;
    let y = tmpx[1];
    let idx = 0;
    for (let i = 0; i < array_of_cards.length; i++) {
      if (array_of_cards[i] === y) {
        idx = i;
      }
    }

    //
    // handle spending trade goods
    //
    if (action2 == "trade_goods") {
      if (total_trade_goods > 0) {
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tgoods\t1");
        total_trade_goods--;
        selected_cost += 1;

        if (1 == total_trade_goods) {
          $('#trade_goods').html(('' + total_trade_goods + ' trade good'));
        } else {
          $('#trade_goods').html(('' + total_trade_goods + ' trade goods'));
        }
      }
    } else {
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tplanet\t" + array_of_cards[idx]);
      array_of_cards_to_exhaust.push(array_of_cards[idx]);
      $(divid).off();
      $(divid).css('opacity', '0.2');
      selected_cost += parseInt(imperium_self.game.planets[array_of_cards[idx]].resources);
    }

    if (cost <= selected_cost) { 

      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.cardchoice , .textchoice').off();

      mycallback(1); 

    }

  });

}








playerSelectActionCard(mycallback, cancel_callback, types = []) {

  let imperium_self = this;
  let array_of_cards = this.returnPlayerActionCards(this.game.player, types);
  if (array_of_cards.length == 0) {
    this.playerAcknowledgeNotice("You do not have any action cards that can be played now", function () {
      if (cancel_callback != null) { cancel_callback(); return 0; }
      imperium_self.playerTurn();
      return 0;
    });
    return 0;
  }

  let html = '';

  html += "<div class='sf-readable'>Select an action card: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    if (!this.game.players_info[this.game.player - 1].action_cards_played.includes(array_of_cards[z])) {
      let thiscard = imperium_self.action_cards[array_of_cards[z]];
      html += '<li class="textchoice pointer" id="' + array_of_cards[z] + '">' + thiscard.name + '</li>';
    }
  }
  html += '<li class="textchoice pointer" id="cancel">cancel</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showActionCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideActionCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 != "cancel") { imperium_self.hideActionCard(action2); }
    if (action2 === "cancel") { cancel_callback(); return 0; }

    if (imperium_self.game.tracker) { imperium_self.game.tracker.action_card = 1; }
    if (imperium_self.action_cards[action2].type == "action") { imperium_self.game.state.active_player_moved = 1; }

    imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(action2);

    mycallback(action2);

  });

}


//
// this is when players are choosing to play the cards that they have 
// already chosen.
//
playerSelectStrategyCard(mycallback, mode = 0) {

  let array_of_cards = this.game.players_info[this.game.player - 1].strategy;
  let strategy_cards = this.returnStrategyCards();
  let imperium_self = this;

  let html = "";

  html += "<div class='sf-readable'>Select a strategy card: </div><ul>";
  for (let z in array_of_cards) {
    if (!this.game.players_info[this.game.player - 1].strategy_cards_played.includes(array_of_cards[z])) {
      html += '<li class="textchoice" id="' + array_of_cards[z] + '">' + strategy_cards[array_of_cards[z]].name + '</li>';
    }
  }
  html += '<li class="textchoice pointer" id="cancel">cancel</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showStrategyCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideStrategyCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 != "cancel") { imperium_self.hideStrategyCard(action2); }

    if (action2 === "cancel") {
      imperium_self.playerTurn();
      return;
    }

    mycallback(action2);

  });
}




//
// this is when players select at the begining of the round, not when they 
// are chosing to play the cards that they have already selected
//
playerSelectStrategyCards(mycallback) {

  let imperium_self = this;
  let cards = this.returnStrategyCards();
  let playercol = "player_color_" + this.game.player;
  let relevant_action_cards = ["strategy"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);


  let html = "<div class='terminal_header'><div class='player_color_box " + playercol + "'></div>" + this.returnFaction(this.game.player) + ": select your strategy card:</div><ul>";
  if (this.game.state.round > 1) {
    html = "<div class='terminal_header'>" + this.returnFaction(this.game.player) + ": select your strategy card:</div><ul>";
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  let scards = [];

  for (let z in this.strategy_cards) {
    scards.push("");
  }

  for (let z = 0; z < this.game.state.strategy_cards.length; z++) {
    let rank = parseInt(this.strategy_cards[this.game.state.strategy_cards[z]].rank);
    while (scards[rank - 1] != "") { rank++; }
    scards[rank - 1] = '<li class="textchoice" id="' + this.game.state.strategy_cards[z] + '">' + cards[this.game.state.strategy_cards[z]].name + '</li>';
  }

  for (let z = 0; z < scards.length; z++) {
    if (scards[z] != "") {
      html += scards[z];
    }
  }

  html += '</ul></p>';
  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showStrategyCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideStrategyCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("pickstrategy\t" + imperium_self.game.player);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
        return 0;
      }, function () {
        imperium_self.playerSelectActionCards(action_card_player, card);
      }, ["action"]);
      return 0;
    }

    imperium_self.hideStrategyCard(action2);
    mycallback(action2);
  });

}



playerRemoveInfantryFromPlanets(player, total = 1, mycallback) {

  let imperium_self = this;

  let html = '';
  html += '<div class="sf-readable">Remove ' + total + ' infantry from planets you control:</div>';
  html += '<ul>';

  let infantry_to_remove = [];

  for (let s in this.game.planets) {
    let planet = this.game.planets[s];
    if (planet.owner == player) {
      let infantry_available_here = 0;
      for (let ss = 0; ss < planet.units[player - 1].length; ss++) {
        if (planet.units[player - 1][ss].type == "infantry") { infantry_available_here++; }
      }
      if (infantry_available_here > 0) {
        html += '<li class="option textchoice" id="' + s + '">' + planet.name + ' - <div style="display:inline" id="' + s + '_infantry">' + infantry_available_here + '</div></li>';
      }
    }
  }
  html += '<li class="option textchoice" id="end"></li>';
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "end") {

      for (let i = 0; i < infantry_to_remove.length; i++) {

        let planet_in_question = imperium_self.game.planets[infantry_to_remove[i].planet];

        let total_units_on_planet = planet_in_question.units[player - 1].length;
        for (let ii = 0; ii < total_units_on_planet; ii++) {
          let thisunit = planet_in_question.units[player - 1][ii];
          if (thisunit.type == "infantry") {
            planet_in_question.units[player - 1].splice(ii, 1);
            ii = total_units_on_planet + 2; // 0 as player_moves below because we have removed above
            imperium_self.addMove("remove_infantry_from_planet\t" + player + "\t" + infantry_to_remove[i].planet + "\t" + "0");
            imperium_self.addMove("NOTIFY\tREMOVING INFANTRY FROM PLANET: " + infantry_to_remove[i].planet);
          }
        }
      }
      mycallback(infantry_to_remove.length);
      return;
    }

    infantry_to_remove.push({ infantry: 1, planet: action2 });
    let divname = "#" + action2 + "_infantry";
    let existing_infantry = $(divname).html();
    let updated_infantry = parseInt(existing_infantry) - 1;
    if (updated_infantry < 0) { updated_infantry = 0; }

    $(divname).html(updated_infantry);

    if (updated_infantry == 0) {
      $(this).remove();
    }

    if (infantry_to_remove.length >= total) {
      $('#end').click();
    }

  });

}

playerAddInfantryToPlanets(player, total = 1, mycallback) {

  let imperium_self = this;

  let html = '';
  html += '<div class="sf-readable">Add ' + total + ' infantry to planets you control:</div>';
  html += '<ul>';

  let infantry_to_add = [];

  for (let s in this.game.planets) {
    let planet = this.game.planets[s];
    if (planet.owner == player) {
      let infantry_available_here = 0;
      for (let ss = 0; ss < planet.units[player - 1].length; ss++) {
        if (planet.units[player - 1][ss].type == "infantry") { infantry_available_here++; }
      }
      html += '<li class="option textchoice" id="' + s + '">' + planet.name + ' - <div style="display:inline" id="' + s + '_infantry">' + infantry_available_here + '</div></li>';
    }
  }
  html += '<li class="option textchoice" id="end"></li>';
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "end") {
      for (let i = 0; i < infantry_to_add.length; i++) {
        imperium_self.addMove("add_infantry_to_planet\t" + player + "\t" + infantry_to_add[i].planet + "\t" + "1");
      }
      mycallback(infantry_to_add.length);
      return;
    }

    infantry_to_add.push({ infantry: 1, planet: action2 });
    let divname = "#" + action2 + "_infantry";
    let existing_infantry = $(divname).html();
    let updated_infantry = parseInt(existing_infantry) + 1;

    $(divname).html(updated_infantry);

    if (infantry_to_add.length >= total) {
      $('#end').click();
    }

  });

}


//////////////////////////
// Select Units to Move //
//////////////////////////
playerSelectUnitsToMove(destination) {

  let imperium_self = this;
  let html = '';
  let hops = 3;
  let sectors = [];
  let distance = [];
  let hazards = [];
  let hoppable = [];
  let fighters_loaded = 0;
  let infantry_loaded = 0;

  let obj = {};
  obj.max_hops = 2;
  obj.ship_move_bonus = this.game.players_info[this.game.player - 1].ship_move_bonus + this.game.players_info[this.game.player - 1].temporary_ship_move_bonus;
  obj.fleet_move_bonus = this.game.players_info[this.game.player - 1].fleet_move_bonus + this.game.players_info[this.game.player - 1].temporary_fleet_move_bonus;
  obj.ships_and_sectors = [];
  obj.stuff_to_move = [];
  obj.stuff_to_load = [];
  obj.distance_adjustment = 0;

  obj.max_hops += obj.ship_move_bonus;
  obj.max_hops += obj.fleet_move_bonus;

  let x = imperium_self.returnSectorsWithinHopDistance(destination, obj.max_hops, imperium_self.game.player);
  sectors = x.sectors;
  distance = x.distance;
  hazards = x.hazards;
  hoppable = x.hoppable;

  for (let i = 0; i < distance.length; i++) {
    if (obj.ship_move_bonus > 0) {
      distance[i]--;
    }
    if (obj.fleet_move_bonus > 0) {
      distance[i]--;
    }
  }

  if (obj.ship_move_bonus > 0) {
    obj.distance_adjustment += obj.ship_move_bonus;
  }
  if (obj.fleet_move_bonus > 0) {
    obj.distance_adjustment += obj.fleet_move_bonus;
  }

  obj.ships_and_sectors = imperium_self.returnShipsMovableToDestinationFromSectors(destination, sectors, distance, hazards, hoppable);

  let updateInterface = function (imperium_self, obj, updateInterface) {

    let subjective_distance_adjustment = 0;
    if (obj.ship_move_bonus > 0) {
      subjective_distance_adjustment += obj.ship_move_bonus;
    }
    if (obj.fleet_move_bonus > 0) {
      subjective_distance_adjustment += obj.fleet_move_bonus;
    }
    let spent_distance_boost = (obj.distance_adjustment - subjective_distance_adjustment);

    let playercol = "player_color_" + imperium_self.game.player;
    let html = "<div class='player_color_box " + playercol + "'></div> " + imperium_self.returnFaction(imperium_self.game.player) + ': select ships to move<ul>';

    //
    // select ships
    //
    for (let i = 0; i < obj.ships_and_sectors.length; i++) {

      let sys = imperium_self.returnSectorAndPlanets(obj.ships_and_sectors[i].sector);
      html += '<b class="sector_name" id="' + obj.ships_and_sectors[i].sector + '" style="margin-top:10px">' + sys.s.name + '</b>';
      html += '<ul class="ship_selector">';
      for (let ii = 0; ii < obj.ships_and_sectors[i].ships.length; ii++) {

        //
        // figure out if we can still move this ship
        //
        let already_moved = 0;
        for (let z = 0; z < obj.stuff_to_move.length; z++) {
          if (obj.stuff_to_move[z].already_moved == 1) {
            already_moved = 1;
          }
          if (obj.stuff_to_move[z].sector == obj.ships_and_sectors[i].sector) {
            if (obj.stuff_to_move[z].i == i) {
              if (obj.stuff_to_move[z].ii == ii) {
                already_moved = 1;
              }
            }
          }
        }

	let rift_passage = 0;
	if (obj.ships_and_sectors[i].hazards[ii] === "rift") { rift_passage = 1; }

        if (already_moved == 1) {
          if (rift_passage == 0) {
            html += `<li id="sector_${i}_${ii}" class=""><b>${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</b></li>`;
	  } else {
            html += `<li id="sector_${i}_${ii}" class=""><b>${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</b> - rift</li>`;
	  }
        } else {
          if (obj.ships_and_sectors[i].ships[ii].move - (obj.ships_and_sectors[i].adjusted_distance[ii] + spent_distance_boost) >= 0) {
            if (rift_passage == 0) {
	      html += `<li id="sector_${i}_${ii}" class="option">${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</li>`;
            } else {
	      html += `<li id="sector_${i}_${ii}" class="option">${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])} - rift</li>`;
	    }
          }
        }
      }

      html += '</ul>';
    }
    html += '<hr />';
    html += '<div id="confirm" class="option">click here to move</div>';
//    html += '<hr />';
//    html += '<div id="clear" class="option">clear selected</div>';
    html += '<hr />';
    imperium_self.updateStatus(html);

    //
    // add hover / mouseover to sector names
    //
    let adddiv = ".sector_name";
    $(adddiv).on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.addSectorHighlight(s); });
    $(adddiv).on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.removeSectorHighlight(s); });


    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");

      //
      // submit when done
      //
      if (id == "confirm") {

        imperium_self.addMove("resolve\tplay");
        // source should be OK as moving out does not add units
        imperium_self.addMove("space_invasion\t" + imperium_self.game.player + "\t" + destination);
        imperium_self.addMove("check_fleet_supply\t" + imperium_self.game.player + "\t" + destination);
        for (let y = 0; y < obj.stuff_to_move.length; y++) {

	  let this_ship_i = obj.stuff_to_move[y].i;
	  let this_ship_ii = obj.stuff_to_move[y].ii;
	  let this_ship_hazard = obj.ships_and_sectors[this_ship_i].hazards[this_ship_ii];

          imperium_self.addMove("move\t" + imperium_self.game.player + "\t" + 1 + "\t" + obj.ships_and_sectors[obj.stuff_to_move[y].i].sector + "\t" + destination + "\t" + JSON.stringify(obj.ships_and_sectors[obj.stuff_to_move[y].i].ships[obj.stuff_to_move[y].ii]) + "\t" + this_ship_hazard);
        }
        for (let y = obj.stuff_to_load.length - 1; y >= 0; y--) {
          imperium_self.addMove("load\t" + imperium_self.game.player + "\t" + 0 + "\t" + obj.stuff_to_load[y].sector + "\t" + obj.stuff_to_load[y].source + "\t" + obj.stuff_to_load[y].source_idx + "\t" + obj.stuff_to_load[y].unitjson + "\t" + obj.stuff_to_load[y].shipjson);
        }

        imperium_self.endTurn();
        return;
      };

      //
      // clear the list to start again
      //
      if (id == "clear") {
        salert("To change movement options, please reload!");
	window.location.reload(true);
        return;
      }


      //
      // highlight ship on menu
      //
      $(this).css("font-weight", "bold");
      this.classList.add("ship_selected");

      //
      //  figure out if we need to load infantry / fighters
      //
      let tmpx = id.split("_");
      let i = tmpx[1];
      let ii = tmpx[2];
      let calcdist = obj.ships_and_sectors[i].distance;
      let sector = obj.ships_and_sectors[i].sector;
      let sys = imperium_self.returnSectorAndPlanets(sector);
      let ship = obj.ships_and_sectors[i].ships[ii];
      let total_ship_capacity = imperium_self.returnRemainingCapacity(ship);
      let x = { i: i, ii: ii, sector: sector };


      //
      // calculate actual distance
      //
      let real_distance = calcdist + obj.distance_adjustment;
      let free_distance = ship.move + obj.fleet_move_bonus;

      if (real_distance > free_distance) {
        //
        // 
        //
        obj.ship_move_bonus--;
      }


      //
      // if this is a fighter, remove it from the underlying
      // list of units we can move, so that it is not double-added
      //
      if (ship.type == "fighter") {
        obj.ships_and_sectors[i].ships[ii].already_moved = 1;
      }




      obj.stuff_to_move.push(x);
      updateInterface(imperium_self, obj, updateInterface);


      //
      // is there stuff left to move?
      //
      let stuff_available_to_move = 0;
      for (let i = 0; i < sys.p.length; i++) {
        let planetary_units = sys.p[i].units[imperium_self.game.player - 1];
        for (let k = 0; k < planetary_units.length; k++) {
          if (planetary_units[k].type == "infantry") {
            stuff_available_to_move++;
          }
        }
      }
      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].type == "fighter") {
          stuff_available_to_move++;
        }
      }


      //
      // remove already-moved fighters from stuff-available-to-move
      // 
      let fighters_available_to_move = 0;
      for (let iii = 0; iii < sys.s.units[imperium_self.game.player - 1].length; iii++) {
        if (sys.s.units[imperium_self.game.player - 1][iii].type == "fighter") {
          let fighter_already_moved = 0;
          for (let z = 0; z < obj.stuff_to_move.length; z++) {
            if (obj.stuff_to_move[z].sector == sector) {
              if (obj.stuff_to_move[z].ii == iii) {
                fighter_already_moved = 1;
              }
            }
          }
          if (fighter_already_moved == 1) {
            stuff_available_to_move--;
          }
        }
      }


      if (total_ship_capacity > 0 && stuff_available_to_move > 0) {
        let remove_what_capacity = 0;
        for (let z = 0; z < obj.stuff_to_load.length; z++) {
          let x = obj.stuff_to_load[z];
          if (x.i == i && x.ii == ii) {
            let thisunit = JSON.parse(obj.stuff_to_load[z].unitjson);
            remove_what_capacity += thisunit.capacity_required;
          }
        }


        let user_message = `<div class="sf-readable">This ship has <span class="capacity_remaining">${total_ship_capacity}</span> capacity. Infantry can capture planets and fighters can protect your fleet. Do you wish to add them? </div><ul>`;

        for (let i = 0; i < sys.p.length; i++) {
          let planetary_units = sys.p[i].units[imperium_self.game.player - 1];
          let infantry_available_to_move = 0;
          for (let k = 0; k < planetary_units.length; k++) {
            if (planetary_units[k].type == "infantry") {
              infantry_available_to_move++;
            }
          }
          if (infantry_available_to_move > 0) {
            user_message += '<li class="option textchoice" id="addinfantry_p_' + i + '">add infantry from ' + sys.p[i].name + ' - <span class="add_infantry_remaining_' + i + '">' + infantry_available_to_move + '</span></li>';
          }
        }

        let fighters_available_to_move = 0;
        for (let iii = 0; iii < sys.s.units[imperium_self.game.player - 1].length; iii++) {
          if (sys.s.units[imperium_self.game.player - 1][iii].type == "fighter") {
            let fighter_already_moved = 0;
            for (let z = 0; z < obj.stuff_to_move.length; z++) {
              if (obj.stuff_to_move[z].sector == sector) {
                if (obj.stuff_to_move[z].ii == iii) {
                  fighter_already_moved = 1;
                }
              }
            }
            if (fighter_already_moved == 0) {
              fighters_available_to_move++;
            }
          }
        }
        user_message += '<li class="option textchoice" id="addfighter_s_s">add fighter - <span class="add_fighters_remaining">' + fighters_available_to_move + '</span></li>';
        user_message += '<li class="option textchoice" id="skip">finish</li>';
        user_message += '</ul></div>';


        //
        // choice
        //
        $('.status-overlay').html(user_message);
        $('.status-overlay').show();
        $('.status').hide();
        $('.textchoice').off();

        //
        // add hover / mouseover to message
        //
        for (let i = 0; i < sys.p.length; i++) {
          adddiv = "#addinfantry_p_" + i;
          $(adddiv).on('mouseenter', function () { imperium_self.addPlanetHighlight(sector, i); });
          $(adddiv).on('mouseleave', function () { imperium_self.removePlanetHighlight(sector, i); });
        }
        adddiv = "#addfighter_s_s";
        $(adddiv).on('mouseenter', function () { imperium_self.addSectorHighlight(sector); });
        $(adddiv).on('mouseleave', function () { imperium_self.removeSectorHighlight(sector); });


        // leave action enabled on other panels
        $('.textchoice').on('click', function () {

          let id = $(this).attr("id");
          let tmpx = id.split("_");
          let action2 = tmpx[0];

          if (total_ship_capacity > 0) {

            if (action2 === "addinfantry") {

              let planet_idx = tmpx[2];
              let irdiv = '.add_infantry_remaining_' + planet_idx;
              let ir = parseInt($(irdiv).html());
              let ic = parseInt($('.capacity_remaining').html());

              //
              // we have to load prematurely. so JSON will be accurate when we move the ship, so player_move is 0 for load
              //
              let unitjson = imperium_self.unloadUnitFromPlanet(imperium_self.game.player, sector, planet_idx, "infantry");
              let shipjson_preload = JSON.stringify(sys.s.units[imperium_self.game.player - 1][obj.ships_and_sectors[i].ship_idxs[ii]]);
              imperium_self.loadUnitByJSONOntoShip(imperium_self.game.player, sector, obj.ships_and_sectors[i].ship_idxs[ii], unitjson);

              $(irdiv).html((ir - 1));
              $('.capacity_remaining').html((ic - 1));

              let loading = {};
              loading.sector = sector;
              loading.source = "planet";
              loading.source_idx = planet_idx;
              loading.unitjson = unitjson;
              loading.ship_idx = obj.ships_and_sectors[i].ship_idxs[ii];
              loading.shipjson = shipjson_preload;
              loading.i = i;
              loading.ii = ii;

              total_ship_capacity--;

              obj.stuff_to_load.push(loading);

              if (ic === 1 && total_ship_capacity == 0) {
                $('.status').show();
                $('.status-overlay').hide();
              }

            }


            if (action2 === "addfighter") {

              if (fighters_available_to_move <= 0) { return; }

              let ir = parseInt($('.add_fighters_remaining').html());
              let ic = parseInt($('.capacity_remaining').html());
              $('.add_fighters_remaining').html((ir - 1));
              fighters_available_to_move--;
              $('.capacity_remaining').html((ic - 1));

              //
              // remove this fighter ...
              //
              let secs_to_check = obj.ships_and_sectors.length;
              for (let sec = 0; sec < obj.ships_and_sectors.length; sec++) {
                if (obj.ships_and_sectors[sec].sector === sector) {
                  let ships_to_check = obj.ships_and_sectors[sec].ships.length;
                  for (let f = 0; f < ships_to_check; f++) {
                    if (obj.ships_and_sectors[sec].ships[f].already_moved == 1) { } else {
                      if (obj.ships_and_sectors[sec].ships[f].type == "fighter") {

                        // remove fighter from status menu
                        let status_div = '#sector_' + sec + '_' + f;
                        $(status_div).remove();

                        // remove from arrays (as loaded)
                        // removed fri june 12
                        //obj.ships_and_sectors[sec].ships.splice(f, 1);
                        //obj.ships_and_sectors[sec].adjusted_distance.splice(f, 1);
                        obj.ships_and_sectors[sec].ships[f] = {};
                        obj.ships_and_sectors[sec].adjusted_distance[f] = 0;
                        f = ships_to_check + 2;
                        sec = secs_to_check + 2;

                      }
                    }
                  }
                }
              }

              let unitjson = imperium_self.removeSpaceUnit(imperium_self.game.player, sector, "fighter");
              let shipjson_preload = JSON.stringify(sys.s.units[imperium_self.game.player - 1][obj.ships_and_sectors[i].ship_idxs[ii]]);

              imperium_self.loadUnitByJSONOntoShip(imperium_self.game.player, sector, obj.ships_and_sectors[i].ship_idxs[ii], unitjson);

              let loading = {};
              obj.stuff_to_load.push(loading);

              loading.sector = sector;
              loading.source = "ship";
              loading.source_idx = "";
              loading.unitjson = unitjson;
              loading.ship_idx = obj.ships_and_sectors[i].ship_idxs[ii];
              loading.shipjson = shipjson_preload;
              loading.i = i;
              loading.ii = ii;

              total_ship_capacity--;

              if (ic == 1 && total_ship_capacity == 0) {
                $('.status').show();
                $('.status-overlay').hide();
              }
            }
          } // total ship capacity

          if (action2 === "skip") {
            $('.status-overlay').hide();
            $('.status').show();
          }

        });
      }
    });
  };

  updateInterface(imperium_self, obj, updateInterface);

  return;

}

//////////////////////////
// Select Units to Move //
//////////////////////////
playerSelectInfantryToLand(sector) {

  let imperium_self = this;
  let html = '<div id="status-message" class="imperial-status-message">Unload Infantry (source): <ul>';
  let sys = imperium_self.returnSectorAndPlanets(sector);

  let space_infantry = [];
  let ground_infantry = [];

  for (let i = 0; i < sys.s.units[this.game.player-1].length; i++) {
    let unit = sys.s.units[this.game.player-1][i];
    if (imperium_self.returnInfantryInUnit(unit) > 0) { 
      html += `<li class="option textchoice" id="addinfantry_s_${i}">remove infantry from ${unit.name} - <span class="add_infantry_remaining_s_${i}">${imperium_self.returnInfantryInUnit(unit)}</span></li>`;
    }
  }

  for (let p = 0; p < sys.p.length; p++) {
    let planet = sys.p[p];
    if (imperium_self.returnInfantryOnPlanet(planet) > 0) { 
      html += `<li class="option textchoice" id="addinfantry_p_${p}">remove infantry from ${planet.name} - <span class="add_infantry_remaining_p_${p}">${imperium_self.returnInfantryOnPlanet(planet)}</span></li>`;
    }
  }

  html += '</ul>';
  html += '</div>';

  html += '<div id="confirm" class="option">click here to move</div>';
//  html += '<hr />';
//  html += '<div id="clear" class="option">clear selected</div>';
  imperium_self.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let id = $(this).attr("id");
    let assigned_planets = [];
    let infantry_available_for_reassignment = 0;
    for (let i = 0; i < sys.p.length; i++) {
      assigned_planets.push(0);
    }

    //
    // submit when done
    //
    if (id == "confirm") {

      for (let i = 0; i < space_infantry.length; i++) {
	imperium_self.addMove("unload_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"ship"+"\t"+space_infantry[i].ship_idx);
        infantry_available_for_reassignment++;
      }
      for (let i = 0; i < ground_infantry.length; i++) {
	imperium_self.addMove("unload_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"planet"+"\t"+ground_infantry[i].planet_idx);
        infantry_available_for_reassignment++;
      }

      let html = '<div class="sf-readable" id="status-message">Reassign Infantry to Planets: <ul>';
          for (let i = 0; i < sys.p.length; i++) {
	    let infantry_remaining_on_planet = imperium_self.returnInfantryOnPlanet(sys.p[i]);
	    for (let ii = 0; ii < ground_infantry.length; ii++) {
	      if (ground_infantry[ii].planet_idx == i) { infantry_remaining_on_planet--; }
	    }
  	    html += `<li class="option textchoice" id="${i}">${sys.p[i].name} - <span class="infantry_on_${i}">${infantry_remaining_on_planet}</span></li>`;
          }
          html += '<div id="confirm" class="option">click here to move</div>';
          html += '</ul'; 
          html += '</div>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "confirm") {
	  imperium_self.endTurn();
        }

        if (infantry_available_for_reassignment > 0)  {
          infantry_available_for_reassignment--;
          let divname = ".infantry_on_"+id;
          let v = parseInt($(divname).html());
          v++;
	  $(divname).html((v));
	  imperium_self.addMove("load_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"planet"+"\t"+id);
	}

      });
    };

    //
    // clear the list to start again
    //
    if (id == "clear") {
      salert("To change movement options, just reload!");
      window.location.reload(true);
    }


    //
    // otherwise we selected
    //
    let user_selected = id.split("_");
    if (user_selected[1] === "p") {
      let divname = ".add_infantry_remaining_p_"+user_selected[2];
      let v = parseInt($(divname).html());
      if (v > 0) {
        ground_infantry.push({ planet_idx : user_selected[2] });
	$(divname).html((v-1));
      }
    }
    if (user_selected[1] === "s") {
      let divname = ".add_infantry_remaining_s_"+user_selected[2];
      let v = parseInt($(divname).html());
      if (v > 0) {
        space_infantry.push({ ship_idx : user_selected[2] });
	$(divname).html((v-1));
      }
    }

  });

  return;

}



playerInvadePlanet(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);

  let total_available_infantry = 0;
  let space_transport_available = 0;
  let space_transport_used = 0;

  let landing_forces = [];
  let landing_on_planet_idx = [];
  let planets_invaded = [];

  html = '<div class="sf-readable">Which planet(s) do you invade: </div><ul>';
  for (let i = 0; i < sys.p.length; i++) {
    if (sys.p[i].owner != player) {
      html += '<li class="option sector_name" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
    }
  }
  html += '<li class="option" id="confirm">launch invasion(s)</li>';
  html += '</ul>';
  this.updateStatus(html);

  let populated_planet_forces = 0;
  let populated_ship_forces = 0;
  let forces_on_planets = [];
  let forces_on_ships = [];

  $('.option').off();
  let adiv = ".sector_name";
  $(adiv).on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.addPlanetHighlight(sector, s); });
  $(adiv).on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.removePlanetHighlight(sector, s); });
  $('.option').on('click', function () {

    let planet_idx = $(this).attr('id');

    if (planet_idx === "confirm") {

/***
      if (landing_forces.length == 0) {
	let sanity_check = confirm("Invade without landing forces? Are you sure -- the invasion will fail.");
	if (!sanity_check) { return; }
      }
***/

      for (let i = 0; i < planets_invaded.length; i++) {

	if (landing_on_planet_idx.includes(planets_invaded[i])) {

            let owner = sys.p[planets_invaded[i]].owner;

            imperium_self.prependMove("bombardment\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("bombardment_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("bombardment_post\t" + owner + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("planetary_defense\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("planetary_defense_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_start\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_end\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);

        }

      }

      imperium_self.prependMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.endTurn();
      return;
    }

    //
    // looks like we have selected a planet for invasion
    //
    if (!planets_invaded.includes(planet_idx)) {
      planets_invaded.push(planet_idx);
    }

    //
    // figure out available infantry and ships capacity
    //
    for (let i = 0; i < sys.s.units[player - 1].length; i++) {
      let unit = sys.s.units[player - 1][i];
      for (let k = 0; k < unit.storage.length; k++) {
        if (unit.storage[k].type == "infantry") {
          if (populated_ship_forces == 0) {
            total_available_infantry += 1;
          }
        }
      }
      if (sys.s.units[player - 1][i].capacity > 0) {
        if (populated_ship_forces == 0) {
          space_transport_available += sys.s.units[player - 1][i].capacity;
        }
      }
    }

    html = '<div class="sf-readable">Select Ground Forces for Invasion of ' + sys.p[planet_idx].name + ': </div><ul>';

    //
    // other planets in system
    //
    for (let i = 0; i < sys.p.length; i++) {
      forces_on_planets.push(0);
      if (space_transport_available > 0 && sys.p[i].units[player - 1].length > 0) {
        for (let j = 0; j < sys.p[i].units[player - 1].length; j++) {
          if (sys.p[i].units[player - 1][j].type == "infantry") {
            if (populated_planet_forces == 0) {
              forces_on_planets[i]++;;
            }
          }
        }
        html += '<li class="invadechoice textchoice option" id="invasion_planet_' + i + '">' + sys.p[i].name + ' - <span class="planet_' + i + '_infantry">' + forces_on_planets[i] + '</span></li>';
      }
    }
    populated_planet_forces = 1;



    //
    // ships in system
    //
    for (let i = 0; i < sys.s.units[player - 1].length; i++) {
      let ship = sys.s.units[player - 1][i];
      forces_on_ships.push(0);
      for (let j = 0; j < ship.storage.length; j++) {
        if (ship.storage[j].type === "infantry") {
          if (populated_ship_forces == 0) {
            forces_on_ships[i]++;
          }
        }
      }
      if (forces_on_ships[i] > 0) {
        html += '<li class="invadechoice textchoice" id="invasion_ship_' + i + '">' + ship.name + ' - <span class="ship_' + i + '_infantry">' + forces_on_ships[i] + '</span></li>';
      }
    }
    populated_ship_forces = 1;
    html += '<li class="invadechoice textchoice" id="finished_0_0">finish selecting</li>';
    html += '</ul></p>';


    //
    // choice
    //
    $('.status-overlay').html(html);
    $('.status').hide();
    $('.status-overlay').show();


    $('.invadechoice').off();
    $('.invadechoice').on('click', function () {

      let id = $(this).attr("id");
      let tmpx = id.split("_");

      let action2 = tmpx[0];
      let source = tmpx[1];
      let source_idx = tmpx[2];
      let counter_div = "." + source + "_" + source_idx + "_infantry";
      let counter = parseInt($(counter_div).html());

      if (action2 == "invasion") {

        if (source == "planet") {
          if (space_transport_available <= 0) { salert("Invalid Choice! No space transport available!"); return; }
          forces_on_planets[source_idx]--;
        } else {
          forces_on_ships[source_idx]--;
        }
        if (counter == 0) {
          salert("You cannot attack with forces you do not have available."); return;
        }

        let unitjson = JSON.stringify(imperium_self.returnUnit("infantry", imperium_self.game.player));

        let landing = {};
        landing.sector = sector;
        landing.source = source;
        landing.source_idx = source_idx;
        landing.planet_idx = planet_idx;
        landing.unitjson = unitjson;

        landing_forces.push(landing);

        let planet_counter = ".invadeplanet_" + planet_idx;
        let planet_forces = parseInt($(planet_counter).html());

        planet_forces++;
        $(planet_counter).html(planet_forces);

        counter--;
        $(counter_div).html(counter);

      }

      if (action2 === "finished") {

        for (let y = 0; y < landing_forces.length; y++) {
          imperium_self.addMove("land\t" + imperium_self.game.player + "\t" + 1 + "\t" + landing_forces[y].sector + "\t" + landing_forces[y].source + "\t" + landing_forces[y].source_idx + "\t" + landing_forces[y].planet_idx + "\t" + landing_forces[y].unitjson);
	  if (!landing_on_planet_idx.includes(landing_forces[y].planet_idx)) { landing_on_planet_idx.push(landing_forces[y].planet_idx); }
        };
        landing_forces = [];
	

        $('.status').show();
        $('.status-overlay').hide();

        return;
      }
    });
  });
}



playerActivateSystem() {

  let imperium_self = this;
  let html = "Select a sector to activate: ";
  let activated_once = 0;
  let xpos = 0;
  let ypos = 0;

  imperium_self.updateStatus(html);

  $('.sector').off();
  $('.sector').on('mousedown', function (e) {
    xpos = e.clientX;
    ypos = e.clientY;
  });
  $('.sector').on('mouseup', function (e) {

    if (Math.abs(xpos-e.clientX) > 4) { return; }
    if (Math.abs(ypos-e.clientY) > 4) { return; }

    //
    // only allowed 1 at a time
    //
    if (activated_once == 1) { return; }

    let pid = $(this).attr("id");

    if (imperium_self.canPlayerActivateSystem(pid) == 0) {
      salert("You cannot activate that system.");
    } else {

      let sys = imperium_self.returnSectorAndPlanets(pid);

      //
      // sanity check on whether we want to do this
      //
      let do_we_permit_this_activation = 1;
      if (!imperium_self.canPlayerMoveShipsIntoSector(imperium_self.game.player, pid)) {
	let c = confirm("You cannot move ships into this sector. Are you sure you wish to activate it?");
	if (c) {
        } else {
	  return;
	}
      }
 
      //
      // if this is our homeworld, it is round 1 and we haven't moved ships out, we may not 
      // understand 
      //
      if (imperium_self.returnPlayerHomeworldSector() == sys.s.sector && imperium_self.game.state.round == 1) {
	let confirm_choice = confirm("If you activate your homeworld you will not be able to move ships out of it until Round 2. Are you sure you want to do this?");
	if (!confirm_choice) { return; }
      }


      activated_once = 1;
      let divpid = '#' + pid;

      $(divpid).find('.hex_activated').css('background-color', 'var(--p' + imperium_self.game.player + ')');
      $(divpid).find('.hex_activated').css('opacity', '0.3');


      let chtml = "<div class='sf-readable'>Activate this system?</div><ul>";
          chtml += '<li class="option" id="yes">yes, do it</li>';
          chtml += '<li class="option" id="no">choose again</li>';
          chtml += '</ul>';

      imperium_self.updateStatus(chtml);
      
      $('.option').off();
      $('.option').on('click', function() {

        let action2 = $(this).attr("id");

        if (action2 === "yes") {
          sys.s.activated[imperium_self.game.player - 1] = 1;
          imperium_self.addMove("activate_system_post\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("pds_space_attack_post\t"+imperium_self.game.player+"\t"+pid);
          imperium_self.addMove("pds_space_attack\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("activate_system\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("expend\t" + imperium_self.game.player + "\t" + "command" + "\t" + 1);
          imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "1");
          imperium_self.endTurn();

        } else {

          activated_once = 0;
          $(divpid).find('.hex_activated').css('background-color', 'transparent');
          $(divpid).find('.hex_activated').css('opacity', '1');

	  imperium_self.playerActivateSystem();

        }
      });
    }

  });
}


//
// if we have arrived here, we are ready to continue with our options post
// systems activation, which are move / pds combat / space combat / bombardment
// planetary invasion / ground combat
//
playerPostActivateSystem(sector) {

  let imperium_self = this;
  let relevant_action_cards = ["post_activate_system"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);
  let player = imperium_self.game.player;

  let html = "<div class='sf-readable'>" + this.returnFaction(this.game.player) + ": </div><ul>";

  if (imperium_self.canPlayerMoveShipsIntoSector(player, sector)) {
    html += '<li class="option" id="move">move into sector</li>';
  }


  if (this.canPlayerInvadePlanet(player, sector) && this.game.tracker.invasion == 0) {
    if (sector == "new-byzantium" || sector == "4_4") {
      if ((imperium_self.game.planets['new-byzantium'].owner != -1) || (imperium_self.returnAvailableInfluence(imperium_self.game.player) + imperium_self.game.players_info[imperium_self.game.player - 1].goods) >= 6) {
        html += '<li class="option" id="invade">invade planet</li>';
      }
    } else {
      html += '<li class="option" id="invade">invade planet</li>';
    }
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">reassign infantry</li>';
  }

  if (this.canPlayerProduceInSector(this.game.player, sector)) {
    html += '<li class="option" id="produce">produce units</li>';
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">relocate infantry</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  html += '<li class="option" id="finish">finish turn</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("activate_system_post\t" + imperium_self.game.player + "\t" + sector);
        imperium_self.game.players_info[this.game.player - 1].action_cards_played.push(card);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
      }, function () {
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, ["action"]);
    }


    if (action2 == "invade") {

      //
      // New Byzantium requires 6 influence to conquer
      //
      if (sector === "new-byzantium" || sector == "4_4") {
        if (imperium_self.game.planets['new-byzantium'].owner == -1) {
          if (imperium_self.returnAvailableInfluence(imperium_self.game.player) >= 6) {
            imperium_self.playerSelectInfluence(6, function (success) {
              imperium_self.game.tracker.invasion = 1;
              imperium_self.playerInvadePlanet(player, sector);
            });
          } else {
            salert("The first conquest of New Byzantium requires spending 6 influence, which you lack.");
            return;
          }
          return;
        }
      }

      imperium_self.game.tracker.invasion = 1;
      imperium_self.playerInvadePlanet(player, sector);
    }



    if (action2 == "land") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerSelectInfantryToLand(sector);
      return 0;
    }

    if (action2 == "move") {
      imperium_self.playerSelectUnitsToMove(sector);
    }
    if (action2 == "produce") {
      //
      // check the fleet supply and NOTIFY users if they are about to surpass it
      //
      let fleet_supply_in_sector = imperium_self.returnSpareFleetSupplyInSector(player, sector);
      if (fleet_supply_in_sector <= 1) {
        let notice = "You have no spare fleet supply in this sector. Do you still wish to produce more ships?";
        if (fleet_supply_in_sector == 1) {
          notice = "You have fleet supply for 1 additional capital ship in this sector. Do you still wish to produce more ships?";
        }
        let c = confirm(notice);
        if (c) {
          imperium_self.playerProduceUnits(sector);
        }
        return;
      }
      imperium_self.playerProduceUnits(sector);
    }
    if (action2 == "finish") {
      if (!imperium_self.moves.includes("resolve\tplay")) { imperium_self.addMove("resolve\tplay"); }
      imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
      imperium_self.endTurn();
    }
  });
}






playerAllocateNewTokens(player, tokens, resolve_needed = 1, stage = 0, leadership_primary = 0) {

  let imperium_self = this;

  if (this.game.player == player) {

    let obj = {};
    obj.current_command = this.game.players_info[player - 1].command_tokens;
    obj.current_strategy = this.game.players_info[player - 1].strategy_tokens;
    obj.current_fleet = this.game.players_info[player - 1].fleet_supply;
    obj.new_command = 0;
    obj.new_strategy = 0;
    obj.new_fleet = 0;
    obj.new_tokens = tokens;


    let updateInterface = function (imperium_self, obj, updateInterface) {

      let html = '<div class="sf-readable">You have ' + obj.new_tokens + ' tokens to allocate. How do you want to allocate them? </div><ul>';

      if (stage == 1) {
        html = '<div class="sf-readable">The Leadership card gives you ' + obj.new_tokens + ' tokens to allocate. How do you wish to allocate them? </div><ul>';
      }
      if (stage == 2) {
        html = '<div class="sf-readable">Leadership has been played and you have purchased ' + obj.new_tokens + ' additional tokens. How do you wish to allocate them? </div><ul>';
      }
      if (stage == 3) {
        html = '<div class="sf-readable">You have ' + obj.new_tokens + ' new tokens to allocate: </div><ul>';
      }

      html += '<li class="option" id="command">Command Token - ' + (parseInt(obj.current_command) + parseInt(obj.new_command)) + '</li>';
      html += '<li class="option" id="strategy">Strategy Token - ' + (parseInt(obj.current_strategy) + parseInt(obj.new_strategy)) + '</li>';
      html += '<li class="option" id="fleet">Fleet Supply - ' + (parseInt(obj.current_fleet) + parseInt(obj.new_fleet)) + '</li>';
      html += '</ul>';

      imperium_self.updateStatus(html);
      imperium_self.lockInterface();

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "strategy") {
          obj.new_strategy++;
          obj.new_tokens--;
        }

        if (id == "command") {
          obj.new_command++;
          obj.new_tokens--;
        }

        if (id == "fleet") {
          obj.new_fleet++;
          obj.new_tokens--;
        }

        if (obj.new_tokens == 0) {
          if (resolve_needed == 1) {
            if (imperium_self.game.confirms_needed > 0 && leadership_primary == 0) {
              imperium_self.addMove("resolve\ttokenallocation\t1\t" + imperium_self.app.wallet.returnPublicKey());
            } else {
              imperium_self.addMove("resolve\ttokenallocation");
            }
          }
          imperium_self.addMove("purchase\t" + player + "\tstrategy\t" + obj.new_strategy);
          imperium_self.addMove("purchase\t" + player + "\tcommand\t" + obj.new_command);
          imperium_self.addMove("purchase\t" + player + "\tfleetsupply\t" + obj.new_fleet);
          imperium_self.unlockInterface();
          imperium_self.endTurn();
        } else {
          imperium_self.unlockInterface();
          updateInterface(imperium_self, obj, updateInterface);
        }

      });
    };

    updateInterface(imperium_self, obj, updateInterface);

  }

  return 0;
}





playerSelectPlayerWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < this.game.players_info.length; i++) {
    if (filter_func(this.game.players_info[i]) == 1) {
      html += '<li class="textchoice" id="' + (i + 1) + '">' + this.returnFaction((i + 1)) + '</li>';
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();



    let action = $(this).attr("id");

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    mycallback(action);

  });
}



playerSelectSectorWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.board) {
    if (filter_func(this.game.board[i].tile) == 1) {
      html += '<li class="textchoice" id="' + i + '">' + this.game.sectors[this.game.board[i].tile].name + '</li>';
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();


  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.showSectorHighlight(s);
    }
  });
  $('.textchoice').on('mouseleave', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.hideSectorHighlight(s);
    }
  });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");

    if (action != "cancel") {
      imperium_self.hideSectorHighlight(action);
    }

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    imperium_self.updateStatus("");
    mycallback(imperium_self.game.board[action].tile);

  });
}





playerSelectChoice(msg, choices, elect = "other", mycallback = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < choices.length; i++) {
    if (elect == "player") {
      if (this.returnFaction(choices[i]) != "Unknown") {
        html += '<li class="textchoice" id="' + i + '">' + this.returnFaction(choices[i]) + '</li>';
      } else {
        html += '<li class="textchoice" id="' + i + '">' + choices[i] + '</li>';
      }
    }
    if (elect == "planet") {
      html += '<li class="textchoice" id="' + i + '">' + this.game.planets[choices[i]].name + '</li>';
    }
    if (elect == "sector") {
      html += '<li class="textchoice" id="' + i + '">' + this.game.sectors[this.game.board[choices[i]].tile].name + '</li>';
    }
    if (elect == "other") {
      html += '<li class="textchoice" id="' + i + '">' + choices[i] + '</li>';
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    mycallback(action);

  });

}










playerSelectPlanetWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.planets) {
    if (this.game.planets[i].tile != "") {
      if (filter_func(i) == 1) {
        html += '<li class="textchoice" id="' + i + '">' + this.game.planets[i].name + '</li>';
      }
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx);
      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
    }
  });
  $('.textchoice').on('mouseleave', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx);
      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
    }
  });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    if (action != "cancel") {
      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx);
      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);
    }

    if (action == "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }

    imperium_self.updateStatus("");
    imperium_self.hideSectorHighlight(action);
    mycallback(action);

  });
}




playerSelectUnitInSectorWithFilter(msg, sector, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let unit_array = [];
  let sector_array = [];
  let planet_array = [];
  let unit_idx = [];
  let exists_unit = 0;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  let sys = this.returnSectorAndPlanets(sector);

  for (let k = 0; k < sys.s.units[imperium_self.game.player - 1].length; k++) {
    if (filter_func(sys.s.units[imperium_self.game.player - 1][k])) {
      unit_array.push(sys.s.units[imperium_self.game.player - 1][k]);
      sector_array.push(sector);
      planet_array.push(-1);
      unit_idx.push(k);
      exists_unit = 1;
      html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.name + ' - ' + unit_array[unit_array.length - 1].name + '</li>';
    }
  }

// HACK
  for (let p = 0; p < sys.p.length; p++) {
    for (let k = 0; k < sys.p[p].units[imperium_self.game.player - 1].length; k++) {
      if (filter_func(sys.p[p].units[imperium_self.game.player - 1][k])) {
        unit_array.push(sys.p[p].units[imperium_self.game.player - 1][k]);
        sector_array.push(sector);
        planet_array.push(p);
        unit_idx.push(k);
        exists_unit = 1;
        html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.sector + ' / ' + sys.p[p].name + " - " + unit_array[unit_array.length - 1].name + '</li>';
      }
    }
  }

  if (exists_unit == 0) {
    html += '<li class="textchoice" id="none">no unit available</li>';
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  //    $('.textchoice').on('mouseenter', function() { 
  //      let s = $(this).attr("id"); 
  //      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  //    $('.textchoice').on('mouseleave', function() { 
  //      let s = $(this).attr("id");
  //      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
  //    });

  this.lockInterface();

  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    //      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx); 
    //      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);

    if (action === "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }
    if (action === "none") {
      let unit_to_return = { sector: "", planet_idx: "", unit_idx: -1, unit: null }
      mycallback(unit_to_return);
      return;
    }

    let unit_to_return = { sector: sector_array[action], planet_idx: planet_array[action], unit_idx: unit_idx[action], unit: unit_array[action] }
    //      imperium_self.hideSectorHighlight(action);

    imperium_self.updateStatus("");
    mycallback(unit_to_return);

  });
}






playerSelectUnitWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let unit_array = [];
  let sector_array = [];
  let planet_array = [];
  let unit_idx = [];
  let exists_unit = 0;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.sectors) {

    let sys = this.returnSectorAndPlanets(i);
    let sector = i;

    for (let k = 0; k < sys.s.units[imperium_self.game.player - 1].length; k++) {
      if (filter_func(sys.s.units[imperium_self.game.player - 1][k])) {
        unit_array.push(sys.s.units[imperium_self.game.player - 1][k]);
        sector_array.push(sector);
        planet_array.push(-1);
        unit_idx.push(k);
        exists_unit = 1;
        html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.name + ' - ' + unit_array[unit_array.length - 1].name + '</li>';
      }
    }

    for (let p = 0; p < sys.p.length; p++) {
      for (let k = 0; k < sys.p[p].units[imperium_self.game.player - 1].length; k++) {
        if (filter_func(sys.p[p].units[imperium_self.game.player - 1][k])) {
          unit_array.push(sys.p[p].units[imperium_self.game.player - 1][k]);
          sector_array.push(sector);
          planet_array.push(p);
          unit_idx.push(k);
          exists_unit = 1;
          html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.sector + ' / ' + sys.p[p].name + " - " + unit_array[unit_array.length - 1].name + '</li>';
        }
      }
    }

  }
  if (exists_unit == 0) {
    html += '<li class="textchoice" id="none">no unit available</li>';
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  //    $('.textchoice').on('mouseenter', function() { 
  //      let s = $(this).attr("id"); 
  //      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  //    $('.textchoice').on('mouseleave', function() { 
  //      let s = $(this).attr("id");
  //      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    //      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx); 
    //      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);

    if (action === "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }
    if (action === "none") {
      let unit_to_return = { sector: "", planet_idx: "", unit_idx: -1, unit: null }
      mycallback(unit_to_return);
      return;
    }

    let unit_to_return = { sector: sector_array[action], planet_idx: planet_array[action], unit_idx: unit_idx[action], unit: unit_array[action] }
    //      imperium_self.hideSectorHighlight(action);

    imperium_self.updateStatus("");
    mycallback(unit_to_return);

  });
}





playerSelectUnitInSectorFilter(msg, sector, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < this.game.players_info.length; i++) {
    for (let ii = 0; ii < sys.s.units[i].length; ii++) {
      if (filter_func(sys.s.units[i][ii]) == 1) {
        html += '<li class="textchoice" id="' + sector + '_' + i + '_' + i + '">' + this.returnFaction((i + 1)) + " - " + sys.s.units[i][ii].name + '</li>';
      }
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action = $(this).attr("id");

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    let tmpar = action.split("_");

    let s = tmpar[0];
    let p = tmpar[1];
    let unitidx = tmpar[2];

    mycallback({ sector: s, player: p, unitidx: unitidx });

  });
}



playerDiscardActionCards(num, mycallback=null) {

  let imperium_self = this;

  if (num < 0) { imperium_self.endTurn(); }

  let html = "<div class='sf-readable'>You must discard <div style='display:inline' class='totalnum' id='totalnum'>" + num + "</div> action card"; if (num > 1) { html += 's'; }; html += ':</div>';
  html += '<ul>';
  let ac_in_hand = this.returnPlayerActionCards(imperium_self.game.player);

  for (let i = 0; i < ac_in_hand.length; i++) {
    html += '<li class="textchoice" id="' + i + '">' + this.action_cards[ac_in_hand[i]].name + '</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showActionCard(ac_in_hand[s]); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideActionCard(ac_in_hand[s]); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    num--;

    $('.totalnum').html(num);
    $(this).remove();

    imperium_self.hideActionCard(action2);
    imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(ac_in_hand[action2]);
    imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");

    if (num == 0) {

      if (mycallback == null) {
        imperium_self.updateStatus("discarding...");
        imperium_self.endTurn();
      } else {
	mycallback();
      }
    }

  });

}





    this.importTech("antimass-deflectors", {
      name        	:       "Antimass Deflectors" ,
      color       	:       "blue" ,
      prereqs             :       [],
      text		: 	"You may move through asteroid fields and gain -1 when receiving PDS fire",
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].antimass_deflectors == undefined) {
          imperium_self.game.players_info[player-1].antimass_deflectors = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "antimass-deflectors") {
          imperium_self.game.players_info[gainer-1].antimass_deflectors = 1;
          imperium_self.game.players_info[gainer-1].fly_through_asteroids = 1;
        }
      },
    });


    this.importTech("gravity-drive", {
      name                :       "Gravity Drive" ,
      color               :       "blue" ,
      prereqs             :       ["blue"],
      text		: 	"One ship may gain +1 movement when you activate a system" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].gravity_drive == undefined) {
          imperium_self.game.players_info[player-1].gravity_drive = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "gravity-drive") {
          imperium_self.game.players_info[gainer-1].gravity_drive = 1;
          imperium_self.game.players_info[gainer-1].ship_move_bonus = 1;
        }
      },
    });




    this.importTech("fleet-logistics", {
      name        	: 	"Fleet Logistics" ,
      color       	: 	"blue" ,
      prereqs     	:       ['blue','blue'],
      text		: 	"You may perform two actions in any turn" ,
      onNewRound : function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "fleet-logistics")) {
          imperium_self.game.players_info[player-1].fleet_logistics_turn = 0;
        }
      },
      onNewTurn : function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "fleet-logistics")) {
          imperium_self.game.players_info[player-1].fleet_logistics_turn++;
	}
      },
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].fleet_logistics == undefined) {
          imperium_self.game.players_info[player-1].fleet_logistics = 0;
          imperium_self.game.players_info[player-1].fleet_logistics_exhausted = 0;
          imperium_self.game.players_info[player-1].fleet_logistics_turn = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "fleet-logistics") {
          imperium_self.game.players_info[gainer-1].fleet_logistics = 1;
          imperium_self.game.players_info[gainer-1].fleet_logistics_exhausted = 0;
          imperium_self.game.players_info[gainer-1].perform_two_actions = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        if (menu == "main") {
          if (imperium_self.doesPlayerHaveTech(player, "fleet-logistics")) {
            return { event : 'fleetlogistics', html : '<li class="option" id="fleetlogistics">use fleet logistics</li>' };
	  }
        }
        return {};
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
        if (menu == "main") {
          if (imperium_self.doesPlayerHaveTech(player, "fleet-logistics")) {
	  if (imperium_self.game.players_info[player-1].fleet_logistics_exhausted == 0) {
	    if (imperium_self.game.players_info[player-1].fleet_logistics_turn < 2) {
	      if (imperium_self.game.players_info[player-1].fleet_logistics == 1) {
                return 1;
	      }
	    }
	  }
	  }
        }
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {
	if (menu == "main") {
  	  imperium_self.game.players_info[player-1].fleet_logistics_exhausted = 1;
          imperium_self.updateLog(imperium_self.returnFaction(player) + " exhausts Fleet Logistics");
          imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"fleet_logistics_exhausted"+"\t"+"int"+"\t"+"1");
	  imperium_self.addMove("play\t"+player);
	  imperium_self.addMove("play\t"+player);
          imperium_self.addMove("NOTIFY\t"+player+" activates fleet logistics");
	  imperium_self.endTurn();
	  imperium_self.updateStatus("Activating Fleet Logistics");
        }
        return 0;
      }

    });


    this.importTech("lightwave-deflector", {
      name        	:       "Light/Wave Deflector" ,
      color       	:       "blue" ,
      prereqs     	:       ['blue','blue','blue'],
      text		:	"Your fleet may move through sectors with opponent ships" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].lightwave_deflector == undefined) {
          imperium_self.game.players_info[player-1].lightwave_deflector = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "lightwave-deflector") {
          imperium_self.game.players_info[gainer-1].lightwave_deflector = 1;
          imperium_self.game.players_info[gainer-1].move_through_sectors_with_opponent_ships = 1;
        }
      },
    });



    this.importTech("neural-motivator", {
      name        	:       "Neural Motivator" ,
      color       	:       "green" ,
      prereqs             :       [],
      text		:	"Gain an extra action card each turn" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].neural_motivator == undefined) {
          imperium_self.game.players_info[player-1].neural_motivator = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "neural-motivator") {
          imperium_self.game.players_info[gainer-1].neural_motivator = 1;
          imperium_self.game.players_info[gainer-1].action_cards_bonus_when_issued = 1;
        }
      },
    });


    this.importTech("dacxive-animators", {
      name                :       "Dacxive Animators" ,
      color               :       "green" ,
      prereqs             :       ["green"],
      text		:	"Place an extra infantry on any planet after winning a defensive ground combat tbere" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].dacxive_animators == undefined) {
          imperium_self.game.players_info[player-1].dacxive_animators = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "dacxive-animators") {
          imperium_self.game.players_info[gainer-1].dacxive_animators = 1;
        }
      },
      groundCombatRoundEnd : function(imperium_self, attacker, defender, sector, planet_idx) {
        let attacker_forces = imperium_self.returnNumberOfGroundForcesOnPlanet(attacker, sector, planet_idx);
        let defender_forces = imperium_self.returnNumberOfGroundForcesOnPlanet(defender, sector, planet_idx);
	//if (imperium_self.doesPlayerHaveTech(attacker, "dacxive-animators")) {
	//  if (attacker_forces > defender_forces && defender_forces == 0) {
	//    imperium_self.addPlanetaryUnit(attacker, sector, planet_idx, "infantry");
	//    imperium_self.updateLog(imperium_self.returnFaction(attacker) + " reinforces infantry with Dacxive Animators");
	//  }
	//}
	if (imperium_self.doesPlayerHaveTech(defender, "dacxive-animators")) {
	  if (attacker_forces < defender_forces && attacker_forces == 0) {
	    imperium_self.addPlanetaryUnit(defender, sector, planet_idx, "infantry");
	    imperium_self.updateLog(imperium_self.returnFaction(defender) + " reinforces infantry with Dacxive Animators");
	  }
	}
      },
    });


    this.importTech("hyper-metabolism", {
      name        	: 	"Hyper Metabolism" ,
      color       	: 	"green" ,
      prereqs     	:       ['green','green'],
      text		:	"Gain an extra command token each round" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].hyper_metabolism == undefined) {
          imperium_self.game.players_info[player-1].hyper_metabolism = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "hyper-metabolism") {
          imperium_self.game.players_info[gainer-1].hyper_metabolism = 1;
          imperium_self.game.players_info[gainer-1].new_tokens_bonus_when_issued = 1;
        }
      },
    });




    this.importTech("x89-bacterial-weapon", {
      name        	:       "X-89 Bacterial Weapon" ,
      color       	:       "green" ,
      prereqs     	:       ['green','green','green'],
      text		:	"Bombardment destroys all infantry on planet" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].x89_bacterial_weapon == undefined) {
          imperium_self.game.players_info[player-1].x89_bacterial_weapon = 0;
          imperium_self.game.players_info[player-1].x89_bacterial_weapon_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "x89-bacterial-weapon") {
          imperium_self.game.players_info[gainer-1].x89_bacterial_weapon = 1;
          imperium_self.game.players_info[gainer-1].x89_bacterial_weapon_exhausted = 0;
        }
      },
      onNewRound : function(imperium_self, player) {
        imperium_self.game.players_info[player-1].x89_bacterial_weapon_exhausted = 0;
        return 1;
      },
      bombardmentTriggers : function(imperium_self, player, bombarding_player, sector) { 
	if (imperium_self.game.players_info[bombarding_player-1].x89_bacterial_weapon == 1 && imperium_self.game.players_info[bombarding_player-1].x89_bacterial_weapon_exhausted == 0) {
	  if (imperium_self.doesSectorContainPlayerUnit(bombarding_player, sector, "warsun") || imperium_self.doesSectorContainPlayerUnit(bombarding_player, sector, "dreadnaught")) { 
	    return 1;
 	  }
	}
	return 0;
      },
      bombardmentEvent : function(imperium_self, player, bombarding_player, sector, planet_idx) {

	if (imperium_self.game.player != bombarding_player) { return 0; }

        let sys = imperium_self.returnSectorAndPlanets(sector);
        let planet = sys.p[planet_idx];
	let html = '';

        html = '<p>Do you wish to use Bacterial Weapons during Bombardment?</p><ul>';
        html += '<li class="option textchoice" id="attack">use bacterial weapons?</li>';
        html += '<li class="option textchoice" id="skip">skip</li>';
        html += '</ul>';

	imperium_self.updateStatus(html);

        $('.textchoice').off();
        $('.textchoice').on('click', function() {

          let action2 = $(this).attr("id");

	  if (action2 == "attack") {

	    // destroy 100 == destroy them all :)
	    imperium_self.addMove("destroy_infantry_on_planet\t"+player+"\t"+sector+"\t"+planet_idx+"\t"+"100");
            imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"x89_bacterial_weapon_exhausted"+"\t"+"int"+"\t"+"1");
	    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " uses Bacterial Weapons");
	    imperium_self.endTurn();
	  }
	  if (action2 == "skip") {
	    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " refrains from using Bacterial Weapons");
	    imperium_self.endTurn();
	  }
        });
	return 0;
      },
    });



    this.importTech("plasma-scoring", {
      name        	:       "Plasma Scoring" ,
      color       	:       "red" ,
      prereqs             :       [],
      text		:	"All PDS and bombardment fire gets +1 bonus shot" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].plasma_scoring == undefined) {
          imperium_self.game.players_info[player-1].plasma_scoring = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "graviton-laser-system") {
          imperium_self.game.players_info[gainer-1].plasma_scoring = 1;
	  imperium_self.game.players_info[gainer-1].pds_combat_roll_bonus_shots++;
        }
      },
      pdsSpaceDefenseTriggers : function(imperium_self, attacker, player, sector) {
	if (imperium_self.doesPlayerHaveTech(player, "plasma-scoring")) {
 	  if (imperium_self.doesPlayerHavePDSUnitsWithinRange(attacker, player, sector) == 1 && attacker != player) {
	    imperium_self.updateLog(imperium_self.returnFaction(player) + " gets +1 shot from Plasma Scoring");
	  }
	}
	//
	// we don't need the event, just the notification on trigger
	//
	return 0;
      },
    });




    this.importTech("magen-defense-grid", {
      name                :       "Magen Defense Grid" ,
      color               :       "red" ,
      text		:	"When ground combat begins on a planet with PDS or Space Dock, destroy one opponent infantry" ,
      prereqs             :       ["red"],

      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].magen_defense_grid == undefined) {
          imperium_self.game.players_info[player-1].magen_defense_grid = 0;
        }
      },
      onNewRound : function(imperium_self, player) {
        if (player == imperium_self.game.player) {
          imperium_self.game.players_info[player-1].magen_defense_grid = 1;
        }
        return 1;
      },
      groundCombatTriggers : function(imperium_self, player, sector, planet_idx) { 
	if (imperium_self.doesPlayerHaveTech(player, "magen-defense-grid")) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  let planet = sys.p[planet_idx];

          if (player == planet.owner) {
	    let non_infantry_units_on_planet = 0;
	    for (let i = 0; i < planet.units[player-1].length; i++) {
	      if (planet.units[player-1][i].type == "spacedock" || planet.units[player-1][i].type == "pds") {
		imperium_self.updateLog("Magan Defense Grid triggers on " + planet.name);
	        return 1;
	      }
	    }
	  }
	}
        return 0;
      },
      groundCombatEvent : function(imperium_self, player, sector, planet_idx) {

	let sys = imperium_self.returnSectorAndPlanets(sector);
	let planet = sys.p[planet_idx];

	for (let i = 0; i < planet.units.length; i++) {
	  if (planet.units[i] != (player-1)) {
	    for (let ii = 0; i < planet.units[i].length; ii++) {

	      let attacker_unit = planet.units[i][ii];
	      let attacker = (i+1);
	      let defender = player;

	      if (attacker_unit.type == "infantry") {
		imperium_self.assignHitsToGroundForces(attacker, defender, sector, planet_idx, 1);
                imperium_self.eliminateDestroyedUnitsInSector(attacker, sector);
                imperium_self.updateSectorGraphics(sector);
		imperium_self.updateLog(imperium_self.returnFaction(attacker) + " loses 1 infantry to Magan Defense Grid");
		ii = planet.units[i].length+3;
		i = planet.units.length+3;
	      }
	    }
	  }
	}
	return 1;
      }
    });




    this.importTech("duranium-armor", {
      name        	: 	"Duranium Armor" ,
      color       	: 	"red" ,
      prereqs     	:       ['red','red'],
      text		:	"Each round, you may repair any ship which has not taken damage this round" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].duranium_armor == undefined) {
          imperium_self.game.players_info[player-1].duranium_armor = 0;
          imperium_self.game.players_info[player-1].duranium_armor = 0;
        }
      },
      onNewRound : function(imperium_self, player, mycallback) {
        if (player == imperium_self.game.player) {
          imperium_self.game.players_info[player-1].duranium_armor = 1;
          imperium_self.game.players_info[player-1].may_repair_damaged_ships_after_space_combat = 1;
        }
        return 1;
      },
      spaceCombatRoundOver : function(imperium_self, attacker, defender, sector) {

	let sys = imperium_self.returnSectorAndPlanets(sector);

	if (imperium_self.doesPlayerHaveTech(attacker, "duranium-armor")) {
	  for (let i = 0; i < sys.s.units[attacker-1].length; i++) {
	    let this_unit = sys.s.units[attacker-1][i];
	    if (this_unit.last_round_damaged < imperium_self.game.state.space_combat_round) {
	      this_unit.strength = this_unit.max_strength;
	      imperium_self.updateLog(imperium_self.returnFaction(attacker) + " repairs ships with Duranium Armor");
	    }
	  }
        }

	if (imperium_self.doesPlayerHaveTech(defender, "duranium-armor")) {
	  for (let i = 0; i < sys.s.units[defender-1].length; i++) {
	    let this_unit = sys.s.units[defender-1][i];
	    if (this_unit.last_round_damaged < imperium_self.game.state.space_combat_round) {
	      this_unit.strength = this_unit.max_strength;
	      imperium_self.updateLog(imperium_self.returnFaction(defender) + " repairs ships with Duranium Armor");
	    }
	  }
        }

      },
    });




    this.importTech("assault-cannon", {
      name        	:       "Assault Cannon" ,
      color       	:       "red" ,
      prereqs     	:       ['red','red','red'],
      text		:	"If you have three or more capital ships in a sector, destroy one opponent capital ship" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].assault_cannont == undefined) {
          imperium_self.game.players_info[player-1].assault_cannont = 0;
        }
      },
      onNewRound : function(imperium_self, player, mycallback) {
        if (player == imperium_self.game.player) {
          imperium_self.game.players_info[player-1].assault_cannont = 1;
          imperium_self.game.players_info[player-1].may_assign_first_round_combat_shot = 1;
        }
        return 1;
      },
      spaceCombatTriggers :function(imperium_self, player, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);

	for (let i = 0; i < sys.s.units.length; i++) {
	  if ((i+1) != player) {
	    if (imperium_self.doesPlayerHaveTech((i+1), "assault-cannon")) {
	      let capital_ships = 0;
	      for (let ii = 0; ii < sys.s.units[i].length; ii++) {
		let thisunit = sys.s.units[i][ii];
		if (thisunit.type == "destroyer") { capital_ships++; }
		if (thisunit.type == "carrier") { capital_ships++; }
		if (thisunit.type == "cruiser") { capital_ships++; }
		if (thisunit.type == "dreadnaught") { capital_ships++; }
		if (thisunit.type == "flagship") { capital_ships++; }
		if (thisunit.type == "warsun") { capital_ships++; }
	      }
	      if (capital_ships >= 3) {

		//
		// if I have an eligible ship
		//
	        for (let z = 0; z < sys.s.units[player-1].length; z++) {
		  let thisunit = sys.s.units[player-1][z];
		  if (thisunit.type == "destroyer") { return 1; }
		  if (thisunit.type == "carrier") { return 1; }
		  if (thisunit.type == "cruiser") { return 1; }
		  if (thisunit.type == "dreadnaught") { return 1; }
		  if (thisunit.type == "flagship") { return 1; }
		  if (thisunit.type == "warsun") { return 1; }
	        }
	        return 1;
	      }
	    }
	  }
	}

      },
      spaceCombatEvent : function(imperium_self, player, sector) {
	imperium_self.game.players_info[player-1].target_units = ['carrier','destroyer','cruiser','dreadnaught','flagship','warsun'];
	imperium_self.game.queue.push("destroy_ships\t"+player+"\t"+"1"+"\t"+imperium_self.game.state.activated_sector);
	return 1;
      },
    });





    this.importTech("spacedock-ii", {
      name        :       "SpaceDock II" ,
      unit        :       1 ,
      prereqs     :       ["yellow","yellow"],
      text        :       "May produce 4 more units than its planet resource value" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].spacedock_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].spacedock_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "spacedock-ii") {
          imperium_self.game.players_info[gainer-1].spacedock_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type === "spacedock" && imperium_self.doesPlayerHaveTech(player, "spacedock-ii")) {
          return imperium_self.returnUnit("spacedock-ii", player, 0);
        }
        return unit;
      },

    });



    this.importTech("pds-ii", {
      name        :       "PDS II" ,
      unit        :       1 ,
      prereqs     :       ["red","yellow"],
      text        :       "Hits on 5, able to fire into adjacent sectors" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].pds_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].pds_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "pds-ii") {
          imperium_self.game.players_info[gainer-1].pds_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type === "pds" && imperium_self.doesPlayerHaveTech(player, "pds-ii")) {
          return imperium_self.returnUnit("pds-ii", player, 0);
        }
        return unit;
      },

    });


    this.importTech("carrier-ii", {
      name        :       "Carrier II" ,
      unit        :       1 ,
      prereqs     :       ["blue","blue"],
      text        :       "Moves 2 hexes and carries 6 infantry or fighters" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].carrier_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].carrier_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "carrier-ii") {
          imperium_self.game.players_info[gainer-1].carrier_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type === "carrier" && imperium_self.doesPlayerHaveTech(player, "carrier-ii")) {
console.log("returning upgraded carrier...");
          return imperium_self.returnUnit("carrier-ii", player, 0);
        }
        return unit;
      },

    });


    this.importTech("infantry-ii", {
      name        :       "Infantry II" ,
      unit        :       1 ,
      prereqs     :       ["green","green"],
      text        :       "Chance of medical rescue and return to homeworld after unit is destroyed",
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].infantry_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].infantry_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "infantry-ii") {
          imperium_self.game.players_info[gainer-1].infantry_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "infantry" && imperium_self.doesPlayerHaveTech(player, "infantry-ii")) {
          return imperium_self.returnUnit("infantry-ii", player, 0);
        }
        return unit;
      },

    });

    this.importTech("destroyer-ii", {
      name        :       "Destroyer II" ,
      unit        :       1 ,
      prereqs     :       ["red","red"],
      text	  : 	 "Hits on 8 and has stronger anti-fighter barrage (6x3)" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].destroyer_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].destroyer_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "destroyer-ii") {
          imperium_self.game.players_info[gainer-1].destroyer_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "destroyer" && imperium_self.doesPlayerHaveTech(player, "destroyer-ii")) {
          return imperium_self.returnUnit("destroyer-ii", player, 0);
        }
        return unit;
      },

    });

    this.importTech("fighter-ii", {
      name        :       "Fighter II" ,
      unit        :       1 ,
      prereqs     :       ["green","blue"],
      text	  : 	 "Hits on 8 and moves 2 hexes. May survive without carriers or support",
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].fighter_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].fighter_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "fighter-ii") {
          imperium_self.game.players_info[gainer-1].fighter_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "fighter" && imperium_self.doesPlayerHaveTech(player, "fighter-ii")) {
          return imperium_self.returnUnit("fighter-ii", player, 0);
        }
        return unit;
      },

    });

    this.importTech("cruiser-ii", {
      name        :       "Cruiser II" ,
      unit        :       1 ,
      prereqs     :       ["green","yellow","red"],
      text	  : 	 "Hits on 6, moves 3 sectors and can carry 1 fighter or infantry" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].cruiser_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].cruiser_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "cruiser-ii") {
          imperium_self.game.players_info[gainer-1].cruiser_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "cruiser" && imperium_self.doesPlayerHaveTech(player, "cruiser-ii")) {
          return imperium_self.returnUnit("cruiser-ii", player, 0);
        }
        return unit;
      },

    });

    this.importTech("dreadnaught-ii", {
      name        :       "Dreadnaught II" ,
      unit        :       1 ,
      prereqs     :       ["blue","blue","yellow"],
      text	  : 	 "Hits on 5, moves 2 sectors and can carry 1 unit. 2 hits to destroy" ,
      initialize :       function(imperium_self, player) {
	if (imperium_self.game.players_info[player-1].dreadnaught_ii == 1) { return 1; };
        imperium_self.game.players_info[player-1].dreadnaught_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	if (tech == "dreadnaught-ii") {
          imperium_self.game.players_info[gainer-1].dreadnaught_ii = 1;
        }
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (unit.type == "dreadnaught" && imperium_self.doesPlayerHaveTech(player, "dreadnaught-ii")) {
          return imperium_self.returnUnit("dreadnaught-ii", player, 0);
        }
        return unit;
      },

    });



    this.importTech("warsun", {
      name        :       "Warsun" ,
      unit        :       1 ,
      prereqs     :       ["red","red","red","yellow"],
      text	  : 	 "The Death Star: terrifying in combat, but fragile without supporting fleet" ,
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].may_produce_warsuns == undefined) {
          imperium_self.game.players_info[player-1].may_produce_warsuns = 0;
        }
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        if (tech == "warsun") {
          imperium_self.game.players_info[gainer-1].may_produce_warsuns = 1;
        }
      },
    });



    this.importTech("sarween-tools", {
      name        	: 	"Sarween Tools" ,
      color       	: 	"yellow" ,
      text		:	"Reduce cost of units produced by -1 when using production",
      prereqs     	:       [],
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].sarween_tools == undefined) {
          imperium_self.game.players_info[player-1].sarween_tools = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "sarween-tools") {
          imperium_self.game.players_info[gainer-1].sarween_tools = 1;
          imperium_self.game.players_info[gainer-1].production_bonus = 1;
        }
      },
    });




    this.importTech("graviton-laser-system", {
      name        	:       "Graviton Laser System" ,
      color       	:       "yellow" ,
      text		:	"Exhaust card once per round to target capital ships with PDS fire" ,
      prereqs             :       ["yellow"],
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].graviton_laser_system == undefined) {
          imperium_self.game.players_info[player-1].graviton_laser_system = 0;
          imperium_self.game.players_info[player-1].graviton_laser_system_exhausted = 0;
          imperium_self.game.players_info[player-1].graviton_laser_system_active = 0;
        }
      },
      onNewRound : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].graviton_laser_system == 1) {
          imperium_self.game.players_info[player-1].graviton_laser_system_exhausted = 0;
          imperium_self.game.players_info[player-1].graviton_laser_system_active = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "graviton-laser-system") {
          imperium_self.game.players_info[gainer-1].graviton_laser_system = 1;
          imperium_self.game.players_info[gainer-1].graviton_laser_system_exhausted = 0;
        }
      },
      modifyTargets(imperium_self, attacker, defender, player, combat_type="", targets=[]) {
        if (combat_type == "pds") {
	  //
	  // defenders in PDS are the ones with this enabled
	  //
          if (imperium_self.game.players_info[defender-1].graviton_laser_system_active == 1) {
	    if (!targets.includes("warsun")) { targets.push("warsun"); }
	    if (!targets.includes("flagship")) { targets.push("flagship"); }
	    if (!targets.includes("dreadnaught")) { targets.push("dreadnaught"); }
	    if (!targets.includes("cruiser")) { targets.push("cruiser"); }
	    if (!targets.includes("carrier")) { targets.push("carrier"); }
	    if (!targets.includes("destroyer")) { targets.push("destroyer"); }
          }
        }
	return targets;
      },
      menuOption  :       function(imperium_self, menu, player) {
	if (menu == "pds") {
          return { event : 'graviton', html : '<li class="option" id="graviton">use graviton laser targetting</li>' };
        }
        return {};
      },
      menuOptionTriggers:  function(imperium_self, menu, player) { 
	if (menu == "pds" && imperium_self.game.players_info[player-1].graviton_laser_system_exhausted == 0 && imperium_self.game.players_info[player-1].graviton_laser_system == 1) {
	  return 1;
	}
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {
        if (menu == "pds") {
	  imperium_self.updateLog(imperium_self.returnFaction(player) + " exhausts Graviton Laser System");
          imperium_self.game.players_info[player-1].graviton_laser_system_exhausted = 1;
          imperium_self.game.players_info[player-1].graviton_laser_system_active = 1;
          imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"graviton_laser_system_exhausted"+"\t"+"int"+"\t"+"1");
          imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"graviton_laser_system_active"+"\t"+"int"+"\t"+"1");
          imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(player)+" activates Graviton Laser System");
	}
	return 0;
      }
    });






    this.importTech("transit-diodes", {
      name                :       "Transit Diodes" ,
      color               :       "yellow" ,
      prereqs             :       ["yellow", "yellow"],
      text		:	"Exhaust to reallocate 4 infantry between planets your control" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].transit_diodes == undefined) {
          imperium_self.game.players_info[player-1].transit_diodes = 0;
          imperium_self.game.players_info[player-1].transit_diodes_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "transit-diodes") {
          imperium_self.game.players_info[gainer-1].transit_diodes = 1;
          imperium_self.game.players_info[gainer-1].transit_diodes_exhausted = 0;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
	if (menu == "main") {
          return { event : 'transitdiodes', html : '<li class="option" id="transitdiodes">use transit diodes</li>' };
        }
        return {};
      },
      menuOptionTriggers:  function(imperium_self, menu, player) { 
	if (menu == "main" && imperium_self.doesPlayerHaveTech(player, "transit-diodes")) {
	  return 1;
	}
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {
        if (menu == "main") {
	  imperium_self.playerRemoveInfantryFromPlanets(player, 4, function(num_to_add) {
	    imperium_self.playerAddInfantryToPlanets(player, num_to_add, function() {
              imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"transit_diodes_exhausted"+"\t"+"int"+"\t"+"1");
              imperium_self.addMove("NOTIFY\t"+player+" activates transit diodes");
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(player) + " has moved infantry");
	      imperium_self.endTurn();
	    });	    
	  });
	}
	return 0;
      }
    });




    this.importTech("integrated-economy", {
      name        	:       "Integrated Economy" ,
      color       	:       "yellow" ,
      prereqs     	:       ['yellow','yellow','yellow'],
      text		:	"You may produce on a planet after capturing it, up to cost (resource) limit of planet." ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].integrated_economy == undefined) {
          imperium_self.game.players_info[player-1].integrated_economy = 0;
          imperium_self.game.players_info[player-1].integrated_economy_planet_invaded = 0;
          imperium_self.game.players_info[player-1].integrated_economy_planet_invaded_resources = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "integrated-economy") {
          imperium_self.game.players_info[gainer-1].integrated_economy = 1;
          imperium_self.game.players_info[gainer-1].integrated_economy_planet_invaded = 0;
          imperium_self.game.players_info[gainer-1].integrated_economy_planet_invaded_resources = 0;
        }
      },
      gainPlanet : function(imperium_self, gainer, planet) {
        if (imperium_self.doesPlayerHaveTech(gainer, "integrated-economy")) {
          imperium_self.game.players_info[gainer-1].may_player_produce_without_spacedock = 1;
          imperium_self.game.players_info[gainer-1].may_player_produce_without_spacedock_production_limit = 0;
console.log("P: " + planet);
          imperium_self.game.players_info[gainer-1].may_player_produce_without_spacedock_cost_limit += imperium_self.game.planets[planet].resources;
        }
      },
    });




    this.importUnit("infantry", {
      name     		:       "Infantry",
      type     		:       "infantry",
      cost 		:	0.5,
      combat 		:	8,
      strength 		:	1,
      space		:	0,
      ground		:	1,
      can_be_stored	:	1,
      capacity_required :	1,
      description	:	"Infantry invade planets, but cannot move between sectors without being carried on carriers or other ships with capacity.",
    });

    this.importUnit("fighter", {
      name     		:       "Fighter",
      type     		:       "fighter",
      cost 		:	0.5,
      move 		:	1,
      combat 		:	9,
      strength 		:	1,
      can_be_stored	:	1,
      capacity_required :	1,
      description	:	"Fighters are disposable ships deployed to protect capital ships. They must be transported on carriers or other ships with capacity.",
    });


    this.importUnit("pds", {
      name     		:       "PDS",
      type     		:       "pds",
      range 		:	0,
      cost 		:	5,
      combat 		:	6,
      description	:	"PDS units fire on other ships that invade their sectors. They can also fire on foreign infantry that invade a planet.",
    });

    this.importUnit("spacedock", {
      name     		:       "Spacedock",
      type     		:       "spacedock",
      capacity 		:	3,
      production 	:	4,
      combat      	: 	0,
      range       	: 	0,
      description	:	"Spacedocks are used to produce infantry and other ships. They cannot produce ships in space if an opponent fighter is in the sector",
    });

    this.importUnit("carrier", {
      name     		:       "Carrier",
      type     		:       "carrier",
      cost 		:	3,
      move 		:	1,
      combat 		:	9,
      capacity 		:	4,
      strength 		:	1,
      description	:	"The Carrier is a troop and fighter transport ship. Load it with infantry and fighters and use it to conquer other sectors.",
    });

    this.importUnit("destroyer", {
      name     		:       "Destroyer",
      type     		:       "destroyer",
      cost 		:	1,
      move 		:	2,
      combat 		:	9,
      strength 		:	1,
      anti_fighter_barrage :	2,
      anti_fighter_barrage_combat :	9,
      description	:	"The Destroyer is an inexpensive but mobile ship designed to counter fighter swarms - its ANTI-FIGHTER BARRAGE (2 rolls hitting on 9 or higher) happens at the very start of space-combat",
    });

    this.importUnit("cruiser", {
      name     		:       "Cruiser",
      type     		:       "cruiser",
      cost 		:	2,
      move 		:	2,
      combat 		:	7,
      strength 		:	1,
      description	:	"The Cruiser is a more powerful ship with a reasonable chance of landing hits in battle.",
    });

    this.importUnit("dreadnaught", {
      name     		:       "Dreadnaught",
      type     		:       "dreadnaught",
      cost 		:	4,
      move 		:	1,
      capacity 		:	1,
      combat 		:	6,
      strength 		:	2,
      bombardment_rolls	:	1,
      bombardment_combat:	5,
      description	:	"The Dreadnaught is a powerful combat ship able to SUSTAIN DAMAGE once before being destroyed in combat",
    });

    this.importUnit("flagship", {
      name     		:       "Flagship",
      type     		:       "flagship",
      cost 		:	8,
      move 		:	1,
      capacity 		:	1,
      combat 		:	7,
      strength 		:	2,
      description	:	"The Flagship is the pride of the fleet -- each faction's flagship confers specific abilities. See your factino sheet for more details",
    });

    this.importUnit("warsun", {
      name     		:       "War Sun",
      type     		:       "warsun",
      cost 		:	12,
      move 		:	1,
      capacity 		:	6,
      combat 		:	3,
      strength 		:	2,
      bombardment_rolls	:	3,
      bombardment_combat:	3,
      description	:	"The War Sun is death packaged in a mass of planet-destroying turbinium. Rumours of their lethality abound, as few have fought one and lived to tell the tale." ,
    });

  
    this.importUnit("infantry-ii", {
      name     		:       "Infantry II",
      type     		:       "infantry",
      cost 		:	0.5,
      combat 		:	7,
      strength 		:	1,
      space		:	0,
      ground		:	1,
      can_be_stored	:	1,
      capacity_required :	1,
      extension 	: 	1,
      description	:	"Infantry II are stronger and more resilient but cannot typically be moved between sectors without moving on carriers or other ships with capacity.",
    });

    this.importUnit("fighter-ii", {
      name     		:       "Fighter II",
      type     		:       "fighter",
      cost 		:	0.5,
      move 		:	2,
      combat 		:	8,
      strength 		:	1,
      can_be_stored	:	1,
      capacity_required :	1,
      extension 	: 	1,
      description	:	"Fighter II can move without being transported by other ships. Any ships inexcess of your carrying capacity could against your fleet supply.",
      
    });

    this.importUnit("spacedock-ii", {
      name     		:       "Spacedock II",
      type     		:       "spacedock",
      capacity 		:	3,
      production 	:	4,
      extension 	: 	1,
      description	:	"Spacedock II can produce more units whenever they produce.",
    });

    this.importUnit("pds-ii", {
      name     		:       "PDS II",
      type     		:       "pds",
      cost 		:	5,
      combat 		:	5,
      range		:	1,
      extension 	: 	1,
      description	:	"PDS II has a slightly more accurate targeting mechanism and can fire into adjacent sectors.",
    });

    this.importUnit("carrier-ii", {
      name     		:       "Carrier II",
      type     		:       "carrier",
      cost 		:	3,
      move 		:	2,
      combat 		:	9,
      capacity 		:	6,
      strength 		:	1,
      extension 	: 	1,
      description	:	"Carrier II has upgraded ship capacity and is slightly more robust in combat",
    });

    this.importUnit("destroyer-ii", {
      name     		:       "Destroyer II",
      type     		:       "destroyer",
      cost 		:	1,
      move 		:	2,
      combat 		:	8,
      strength 		:	1,
      extension 	: 	1,
      anti_fighter_barrage :	3,
      anti_fighter_barrage_combat :	6,
      description	:	"Destroyer II has improved ANTI-FIGHTER-BARRAGE (3x6) and is slightly more effective in general combat",
    });

    this.importUnit("cruiser-ii", {
      name     		:       "Cruiser II",
      type     		:       "cruiser",
      cost 		:	2,
      move 		:	2,
      combat 		:	7,
      strength 		:	1,
      extension 	: 	1,
      description	:	"Cruiser II has extended range and the ability to support a small phalanx of ground troops",
    });

    this.importUnit("dreadnaught-ii", {
      name     		:       "Dreadnaught II",
      type     		:       "dreadnaught",
      cost 		:	4,
      move 		:	2,
      capacity 		:	1,
      combat 		:	5,
      strength 		:	2,
      extension 	: 	1,
      description	:	"Dreadnaught II has improved movement, can support a small ground team and is slightly more effective in space combat",
    });




 

    this.importPromissary("ceasefire", {
      name        :       "Ceasefire Promissary" ,
      faction	  :	  -1,
      text	  :	  "When the owner activates a sector that contains one of your units, you may trigger this to prevent them moving in units." ,
      //
      // we use 
      //
      activateSystemTriggers	:	function(imperium_self, attacker, player, sector) {
	let promissary_name = imperium_self.game.players_info[attacker-1].faction + "-" + "ceasefire";
	if (imperium_self.doesPlayerHavePromissary(player, promissary_name)) { 
	  if (attacker != player) {
	    if (imperium_self.doesPlayerHaveUnitsInSector(player, sector)) {
	      return 1; 
	    }
	  }
	}
	return 0;
      },
      activateSystemEvent	:	function(imperium_self, attacker, player, sector) {

	if (imperium_self.game.player != player) {
	  imperium_self.updateStatus(imperium_self.returnFaction(player) + " is deciding whether to use Ceasefire");
	  return 0; 
	}

        let html = '<div clss="sf-readable">Permit '+imperium_self.returnFaction(attacker) + ' to activate sector or use ceasefire? </div><ul>';
        html += '<li class="option" id="activate">use ceasefire</li>';
        html += '<li class="option" id="nothing">do nothing</li>';
        html += '</ul>';

        imperium_self.updateStatus(html);

        $('.option').off();
        $('.option').on('click', function () {

          let opt = $(this).attr("id");

	  if (opt === "nothing") {
	    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " does not use Ceasefire");
	    imperium_self.endTurn();
	    return 0;
	  }

	  if (opt === "activate") {
	    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " uses Ceasefire to end " + imperium_self.returnFaction(attacker) + " turn");
	    imperium_self.addMove("ceasefire\t"+attacker+"\t"+player);
            imperium_self.endTurn();
            return 0;
	  }

          return 0;
        });
      },
      handleGameLoop : function(imperium_self, qe, mv) {

        if (mv[0] == "ceasefire") {

          let attacker = parseInt(mv[1]);
          let sector = mv[2];
          imperium_self.game.queue.splice(qe, 1);

	  let terminated_play = 0;
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("play") != 0 && terminated_play == 0) {
	      imperium_self.game.queue.splice(i, 1);
	    } else {
	      if (terminated_play == 0) {
	        terminated_play = 1;
        	imperium_self.game.queue.push("resolve\tplay");
        	imperium_self.game.queue.push("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        	imperium_self.game.queue.push("player_end_turn\t" + attacker);
	      }
	    }
	  }

          return 1;
        }
        return 1;
      }
    });



    this.importPromissary("trade", {
      name        :       "Trade Promissary" ,
      faction	  :	  -1,
      text	  :	  "When the owner replenishes commodities, this promissary triggers and you gain their commodities as trade goods" ,
      gainCommodities	:	function(imperium_self, player, amount) {
	let promissary_name = imperium_self.game.players_info[player-1].faction + "-" + "trade";
	let pprom = imperium_self.returnPromissaryPlayer(promissary_name);
	for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	  if ((i+1) != player) {
	    if (imperium_self.doesPlayerHavePromissary((i+1), promissary_name)) {
	      imperium_self.game.players_info[i].goods += amount;
	      imperium_self.givePromissary(player, (i+1), promissary_name);
	      imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " redeems their Trade Promissary from " + imperium_self.returnFaction(pprom));
	      return 0;
	    }
	  }
	}
	return amount;
      },
    });



    this.importPromissary("political", {
      name        :       "Political Promissary" ,
      faction	  :	  -1,
      text	  :	  "The owner of this card cannot participate in resolving this agenda" ,
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
        if (menu == "pre_agenda") {
          x.event = 'political-promissary';
          x.html = '<li class="option" id="political-promissary">Political Promissary</li>';
        }
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
	if (menu != "pre_agenda") { return 0; }
        let playable_promissaries = imperium_self.returnPlayablePromissaryArray(player, "political");
        for (let i = 0; i < playable_promissaries.length; i++) {
	  if (imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes.includes(playable_promissaries[i])) { return 1; }
	}
        return 0;
      },
      //
      // choose faction politicla promissary, and add a useless rider
      //
      menuOptionActivated:  function(imperium_self, menu, player) {
        if (imperium_self.game.player == player) {

          let html = '<div class="sf-readable">Select a Specific Promissary: </div><ul>';
          let playable_promissaries = imperium_self.returnPlayablePromissaryArray(player, "political");
	  for (let i = 0; i < playable_promissaries.length; i++) {
	    let tmpar = playable_promissaries[i].split("-");
	    let pprom = imperium_self.returnPromissaryPlayer(playable_promissaries[i]);
            html += `<li class="option" id="${i}">${imperium_self.returnFactionName(pprom)} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
          html += '</ul>';

          imperium_self.updateStatus(html);

          $('.option').off();
          $('.option').on('click', function() {

            let i = $(this).attr("id");
	    let prom = playable_promissaries[parseInt(i)]
	    let pprom = imperium_self.returnPromissaryPlayer(playable_promissaries[parseInt(i)]);

	    imperium_self.addMove("rider\t"+pprom+"\tpolitical-promissary\t-1");
	    imperium_self.addMove("give\t"+imperium_self.game.player+"\t"+prom+"\t"+"promissary"+"\t"+prom);
	    imperium_self.endTurn();

            return 0;
          });
	}
	return 0;
      }
    });

    this.importPromissary("throne", {
      name        :       "Support for the Throne" ,
      faction	  :	  -1,
      text	  :	  "Gain 1 VP when you receive this card. Lose this card and 1 VP if the owner of this card is eliminated or you activate a system containing any of their units." ,
      gainPromissary	:    function(imperium_self, gainer, promissary) {
	if (promissary.indexOf("throne") > -1) {
	  let pprom = imperium_self.returnPromissaryPlayer(promissary);
	  if (pprom != gainer) {
	    imperium_self.game.players_info[gainer-1][promissary] = 1;
	    imperium_self.game.players_info[gainer-1].vp++;
	    imperium_self.updateLog(imperium_self.returnFaction(gainer) + " gains 1 VP from Support for the Throne");
	    imperium_self.updateLeaderboard();
	  }
	}
      },
      losePromissary	:    function(imperium_self, loser, promissary) {
	if (promissary.indexOf("throne") > -1) {
	  let pprom = imperium_self.returnPromissaryPlayer(promissary);
	  if (pprom != loser) {
	    imperium_self.game.players_info[loser-1][promissary] = 1;
	    imperium_self.game.players_info[loser-1].vp--;
	    imperium_self.updateLog(imperium_self.returnFaction(loser) + " loses 1 VP from Support for the Throne");
	    imperium_self.updateLeaderboard();
	  }
	}
      },
      // run code on trigger, no need for event separately since asynchronous
      activateSystemTriggers : function(imperium_self, activating_player, player, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);
	for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	  if ((i+1) != activating_player) {
	    if (imperium_self.doesPlayerHaveUnitsInSector((i+1), sector)) {
	      let faction_promissary = imperium_self.game.players_info[player-1].id + "-" + "throne";
	      if (imperium_self.doesPlayerHavePromissary(activating_player, faction_promissary)) {
	        imperium_self.game.players_info[activating_player-1][faction_promissary] = 0;
	        imperium_self.updateLog(imperium_self.returnFaction(activating_player) + " loses 1 VP from Support for the Throne");
	        imperium_self.game.players_info[activating_player-1].vp--;
	     	imperium_self.givePromissary(activating_player, (i+1), details);
	      }
	    }
	  }
	}
	return 0;
      }
    });



    this.importFaction('faction2', {
      id		:	"faction2" ,
      name		: 	"Universities of Jol Nar",
      nickname		: 	"Jol Nar",
      homeworld		: 	"sector50",
      space_units	: 	["carrier","carrier","dreadnaught","fighter"],
      ground_units	: 	["infantry","infantry","pds","spacedock"],
      tech		: 	["sarween-tools", "neural-motivator", "plasma-scoring", "antimass-deflectors", "faction2-analytic", "faction2-brilliant", "faction2-fragile", "faction2-flagship"],
      background	: 	'faction2.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro		:	`<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Universities of Jol Nar, a physically weak faction which excells at science and technology. Survive long enough to amass enough protective technology and you can be a contender for the Imperial Throne. Good luck!</div>`
    });


    this.importTech("faction2-flagship", {
      name        	:       "XXCha Flagship" ,
      faction     	:       "faction2",
      type      	:       "ability" ,
      text		:	"Extra hit on every roll of 9 or 10 before modifications" ,
      modifyUnitHits 	: function(imperium_self, player, defender, attacker, combat_type, rerolling_unit, roll, total_hits) {
        if (!imperium_self.doesPlayerHaveTech(attacker, "faction2-flagship")) { return total_hits; }
	if (rerolling_unit.owner == attacker) {
	  if (rerolling_unit.type == "flagship") {
	    if (roll > 8) { 
	      imperium_self.updateLog("Jol Nar flagship scores an additional hit through flagshup ability");
	      total_hits++; 
	      return total_hits;
	    }
	  }
	}
	return total_hits;
      } ,
    });




    this.importTech('faction2-analytic', {

      name        :       "Analytic" ,
      faction     :       "faction2",
      type        :       "ability" ,
      text	  :	"Ignore 1 tech prerequisite on non-unit upgrades",
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction2-analytic")) {
          imperium_self.game.players_info[player-1].permanent_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 1;
        }
      },

    });


    this.importTech('faction2-fragile', {

      name        :       "Fragile" ,
      faction     :       "faction2",
      type        :       "ability" ,
      text	  :	  "-1 on all combat rolls" ,
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction2-fragile")) {
          imperium_self.game.players_info[player-1].permanent_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 1;
        }
      },
      modifyCombatRoll :	  function(imperium_self, attacker, defender, player, combat_type, roll) {
	if (combat_type == "space" || combat_type == "ground") {
          if (imperium_self.doesPlayerHaveTech(attacker, "faction2-fragile")) {
  	    imperium_self.updateLog("Jol Nar combat rolls -1 due to fragility");
	    roll -= 1;
	    if (roll < 1) { roll = 1; }
	  }
        }

	return roll;
      },
    });
    this.importTech('faction2-brilliant', {
      name        :       "Brilliant" ,
      faction     :       "faction2",
      type        :       "ability" ,
      text	  :	  "Tech primary is played when token spent to execute secondary" ,
      initialize     :    function(imperium_self, player) {
	if (imperium_self.faction2_brilliant_swapped == undefined) {
	  imperium_self.faction2_brilliant_swapped = 1;

	  imperium_self.brilliant_original_event = imperium_self.strategy_cards['technology'].strategySecondaryEvent;
	  imperium_self.strategy_cards["technology"].strategySecondaryEvent = function(imperium_self, player, strategy_card_player) {

	    if (imperium_self.doesPlayerHaveTech(player, "faction2-brilliant") && player != strategy_card_player && imperium_self.game.player == player) {

	      imperium_self.game.players_info[player-1].cost_of_technology_secondary = 6;

              imperium_self.playerAcknowledgeNotice("The Tech strategy card has been played. You may expend a strategy token to research a technology. You can then purchase a second for 6 resources:", function() {

                let html = '<p>Technology has been played. Do you wish to spend a strategy token to research a technology? </p><ul>';
                    html += '<li class="option" id="yes">Yes</li>';
                    html += '<li class="option" id="no">No</li>';
                    html += '</ul>';

                imperium_self.updateStatus(html);
                imperium_self.lockInterface();

                $('.option').off();
                $('.option').on('click', function() {

	          if (!imperium_self.mayUnlockInterface()) {
	            salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
	            return;
	          }
	          imperium_self.unlockInterface();

	          let id = $(this).attr("id");

		  if (id === "no") {
                    imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
                    imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
		    imperium_self.endTurn();
		    return 0;
		  }

                  imperium_self.playerResearchTechnology(function(tech) {

                    imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
                    imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
                    imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);


		    //
		    // avoid double research of same tech by manually inserting
		    //
                    imperium_self.game.players_info[imperium_self.game.player-1].tech.push(tech);


	  	    let resources_to_spend = 6;
                    let html = '<p>Do you wish to spend 6 resources to research a second technology? </p><ul>';

  	            if (
        	      imperium_self.game.players_info[player-1].permanent_research_technology_card_must_not_spend_resources == 1 ||
        	      imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 1
        	    ) {
        	      html = '<p>Do you wish to research a second technology for free?';
        	      resources_to_spend = 0;
        	    }

	            let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
	            if (available_resources >= resources_to_spend) {
	              html += '<li class="option" id="yes">Yes</li>';
	            }
	            html += '<li class="option" id="no">No</li>';
	            html += '</ul>';
 
	            imperium_self.updateStatus(html);
	            imperium_self.lockInterface();

	            $('.option').off();
	            $('.option').on('click', function() {

	              if (!imperium_self.mayUnlockInterface()) {
	                salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
	                return;
	              }
	              imperium_self.unlockInterface();
 
	              let id = $(this).attr("id");

	              if (id === "yes") {
	                imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources = 0;
	                imperium_self.playerSelectResources(resources_to_spend, function(success) {
	                  if (success == 1) {
	                    imperium_self.playerResearchTechnology(function(tech) {
	                      imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);
	                      imperium_self.endTurn();
	                    });
	                  } else {
	                    imperium_self.endTurn();
		    	    return 0;
	                  }
	                });
	              }
	              if (id === "no") {
	                imperium_self.endTurn();
	                return 0;
	              }
	            });
		  });
                });
              });
	    } else {
	      imperium_self.brilliant_original_event(imperium_self, player, strategy_card_player);
	    }
	  }
	}
      }
    });



    this.importTech('faction2-eres-siphons', {
      name        :       "E-Res Siphons" ,
      faction     :       "faction2",
      type        :       "special" ,
      color       	: 	"yellow" ,
      prereqs	:	["yellow","yellow"],
      text	:	"Gain 4 trade goods whenever a system is activated containing your ships" ,
      initialize  :	  function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].eres_siphons == null) {
          imperium_self.game.players_info[player-1].eres_siphons = 0;
	}
      },
      gainTechnology : function(imperium_self, gainer, tech) {
	if (tech == "faction2-eres-siphons") {
          imperium_self.game.players_info[gainer-1].eres_siphons = 1;
        }
      },
      activateSystemTriggers :    function(imperium_self, activating_player, player, sector) {
	if (imperium_self.game.players_info[player-1].eres_siphons == 1 && activating_player != player) {
          if (imperium_self.doesSectorContainPlayerShips(player, sector) == 1) { return 1; }
	}
        return 0;
      },
      postSystemActivation :   function(imperium_self, activating_player, player, sector) {
        imperium_self.game.players_info[player-1].goods += 4;
      }
    });



    this.importTech('faction2-deep-space-conduits', {
      name        :       "Deep Space Conduits" ,
      faction     :       "faction2",
      type        :       "special" ,
      color       	: 	"blue" ,
      prereqs	:	["blue","blue"],
      text	:	"Activate card to make activated system 1 hop away from all other systems with Jol Nar ships" ,
      initialize  :	  function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].deep_space_conduits == null) {
          imperium_self.game.players_info[player-1].deep_space_conduits = 0;
          imperium_self.game.players_info[player-1].deep_space_conduits_exhausted = 0;
	}
      },
      onNewRound : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].deep_space_conduits == 1) {
          imperium_self.game.players_info[player-1].deep_space_conduits_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
	if (tech == "faction2-deep-space-conduits") {
          imperium_self.game.players_info[gainer-1].deep_space_conduits = 1;
          imperium_self.game.players_info[gainer-1].deep_space_conduits_exhausted = 0;
        }
      },
      activateSystemTriggers : function(imperium_self, activating_player, player, sector) { 
	if (player == imperium_self.game.player && activating_player == player) {
	  if (imperium_self.game.players_info[activating_player-1].deep_space_conduits == 1 && imperium_self.game.players_info[activating_player-1].deep_space_conduits_exhausted == 0) {
	    if (imperium_self.doesSectorContainPlayerUnits(activating_player, sector)) {
	      return 1;
	    }
	  }
	}
	return 0;
      },
      activateSystemEvent : function(imperium_self, activating_player, player, sector) { 

	let html = 'Do you wish to activate Deep Space Conduits: <ul>';
	html    += '<li class="textchoice" id="yes">activate</li>';
	html    += '<li class="textchoice" id="no">skip</li>';
	html    += '</ul>';

	imperium_self.updateStatus(html);

	$('.textchoice').off();
	$('.textchoice').on('click', function() {

	  let action = $(this).attr("id");

	  if (action == "yes") {
	    let sectors = imperium_self.returnSectorsWithPlayerUnits(activating_player);
	    imperium_self.game.players_info[activating_player-1].deep_space_conduits_exhausted = 1;
            imperium_self.addMove("setvar\tplayers\t"+player+"\t"+"deep_space_conduits_exhausted"+"\t"+"int"+"\t"+"1");
	    for (let i = 0; i < sectors.length; i++) {
	      imperium_self.addMove("adjacency\ttemporary\t"+sectors[i]+"\t"+sector);
	    }
	    imperium_self.endTurn();
	  }

	  if (action == "no") {
	    imperium_self.updateStatus();
	    imperium_self.endTurn();
	  }

	});
      }
    });





    this.importFaction('faction7', {
      id		:	"faction7" ,
      name		: 	"Embers of Muaat",
      nickname		: 	"Muaat",
      homeworld		: 	"sector76",
      space_units	: 	["warsun","fighter","fighter"],
      ground_units	: 	["infantry","infantry","infantry","infantry","spacedock"],
      tech		: 	["plasma-scoring", "faction7-star-forge", "faction7-gashlai-physiology", "faction7-advanced-warsun-i","faction7-flagship"],
      background	: 	'faction7.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Yssaril Tribe, a primitive race of swamp-dwelling creatures whose fast instincts and almost unerring ability to change tactics on-the-fly lead many to suspect more is at work than their primitive appearance belies. Good luck!</div>`
    });






    this.importTech("faction7-star-forge", {

      name        :       "Star Forge" ,
      faction     :       "faction7",
      type      :         "ability" ,
      text        :       "Spend 1 strategy token to place 2 fighters or a destroy in sector with your warsun" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].star_forge == undefined) {
          imperium_self.game.players_info[player-1].star_forge = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction7-star-forge") {
          imperium_self.game.players_info[gainer-1].star_forge = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
        if (menu === "main") {
          x.event = 'starforge';
          x.html = '<li class="option" id="starforge">star forge</li>';
        }
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction7-star-forge") && menu === "main") {
          return 1;
        }
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

        if (imperium_self.game.player == player) {

	  //
	  // star forge logic
	  //
          imperium_self.playerSelectSectorWithFilter(
            "Star Forge spends 1 strategy token to drop 2 fighters or 1 destroyer in a sector containing your War Sun: " ,
            function(sector) {
	      return imperium_self.doesSectorContainPlayerUnit(imperium_self.game.player, sector, "warsun");
            },
            function(sector) {

              imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdestroyer\t"+sector);
              imperium_self.addMove("NOTIFY\tStar Forge adds destroyer to "+sector);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\t"+"strategy"+"\t"+"1");
              imperium_self.endTurn();
              return 0;

            },
            function() {
              imperium_self.playerTurn();
            }
          );

          return 0;

        };

	return 0;
      }
    });








    this.importTech("faction7-gashlai-physiology", {

      name        :       "Gashlai Physiology" ,
      faction     :       "faction7",
      type        :       "ability" ,
      text        :       "Player may move through supernovas" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].gashlai_physiology == undefined) {
          imperium_self.game.players_info[player-1].gashlai_physiology = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction7-gashlai-physiology") {
          imperium_self.game.players_info[gainer-1].gashlai_physiology = 1;
	  imperium_self.game.players_info[gainer-1].fly_through_supernovas = 1;
        }
      },
    });








    this.importTech("faction7-magmus-reactor", {

      name        :       "Magmus Reactor" ,
      faction     :       "faction7",
      type        :       "special" ,
      text        :       "Player may move into supernovas. Gain 1 trade good producing with Warsun or adjacent to Supernova" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].magmus_reactor == undefined) {
          imperium_self.game.players_info[player-1].magmus_reactor = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction7-magmus-reactor") {
          imperium_self.game.players_info[gainer-1].magmus_reactor = 1;
	  imperium_self.game.players_info[gainer-1].move_into_supernovas = 1;
        }
      },
      postProduction : function(imperium_self, player, sector, stuff) {
	if (imperium_self.game.players_info[player-1].magmus_reactor == 1) {
          let as = imperium_self.returnAdjacentSectors(sector);
	  let give_bonus = 0;
          if (imperium_self.doesSectorContainPlayerUnit(player, sector, "warsun")) { give_bonus = 1; }
	  if (give_bonus == 0) {
            for (let i = 0; i < as.length; i++) {
  	      let sys = imperium_self.returnSectorAndPlanets(as[i]);
	      if (sys.s.type == 4) { give_bonus = 1; }
	    }
	  }
	  if (give_bonus == 1) {
	    imperium_self.updateLog("Muatt gains 1 trade good from Magmus Reactor - producing in a sector with a Warsun or adjacent to a Supernova");
            imperium_self.game.players_info[player-1].goods += 1;
            imperium_self.updateTokenDisplay();
            imperium_self.displayFactionDashboard();
	  }
	}
      }
    });






    this.importTech("faction7-flagship", {
      name        	:       "Muaat Flagship" ,
      faction     	:       "faction7",
      type      	:       "ability" ,
      text        	:       "May spend 1 strategy token to place a cruiser in your flagship system" ,
    });


    this.importTech("faction7-advanced-warsun-i", {

      name        :       "Advanced Warsun I" ,
      faction     :       "faction7",
      replaces    :       "warsun",
      unit        :       1 ,
      type      :         "special",
      text        :       "A more dangerous and mobile warsun" ,
      prereqs     :       [],
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction7_advanced_warsun_i == undefined) {
          imperium_self.game.players_info[player-1].faction7_advanced_warsun_i = 0;
	}
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        imperium_self.game.players_info[gainer-1].faction7_advanced_warsun_i = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {

        if (imperium_self.game.players_info[unit.owner-1].faction7_advanced_warsun_i == 1 && unit.type == "warsun") {
          unit.cost = 12;
          unit.combat = 3;
          unit.move = 1;
          unit.capacity = 6;
	  unit.bombardment_rolls = 3;
	  unit.bombardment_combat = 3;
        }

        return unit;
      },

    });





    this.importTech("faction7-advanced-warsun-ii", {

      name        :       "Advanced Warsun II" ,
      faction     :       "faction7",
      replaces    :       "warsun",
      unit        :       1 ,
      type      :         "special",
      text        :       "A more dangerous and mobile warsun" ,
      prereqs     :       ["red","red","red","yellow"],
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction7_advanced_warsun_ii == undefined) {
          imperium_self.game.players_info[player-1].faction7_advanced_warsun_ii = 0;
	}
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        imperium_self.game.players_info[gainer-1].faction7_advanced_warsun_ii = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {

        if (imperium_self.game.players_info[unit.owner-1].faction7_advanced_warsun_ii == 1 && unit.type == "warsun") {
          unit.cost = 10;
          unit.combat = 3;
          unit.move = 3;
          unit.capacity = 6;
	  unit.bombardment_rolls = 3;
	  unit.bombardment_combat = 3;
        }

        return unit;
      },

    });






    this.importFaction('faction4', {
      id		:	"faction4" ,
      name		: 	"Sardakk N'Orr",
      nickname		: 	"Sardakk",
      homeworld		: 	"sector53",
      space_units	: 	["carrier","carrier","cruiser"],
      ground_units	: 	["infantry","infantry","infantry","infantry","infantry","spacedock"],
      tech		: 	["faction4-unrelenting", "faction4-exotrireme-i", "faction4-flagship"],
      background	: 	'faction4.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Sardaak N'Orr, an overpowered faction known for its raw strength in combat. Your brutal power makes you an intimidating faction on the board. Good luck!</div>`
    });




    this.importTech('faction4-unrelenting', {

      name        :       "Unrelenting" ,
      faction     :       "faction4",
      type        :       "ability" ,
      text	  :	  "+1 on all combat rolls" ,
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction4-unrelenting")) {
          imperium_self.game.players_info[player-1].faction4_unrelenting = 1;
        }
      },
      modifyCombatRoll :	  function(imperium_self, attacker, defender, player, combat_type, roll) {
	if (combat_type == "space" || combat_type == "ground") {
          if (imperium_self.doesPlayerHaveTech(attacker, "faction4-unrelenting")) {
  	    imperium_self.updateLog("Sardakk combat rolls +1 due to Sardakk");
	    roll += 1;
	    if (roll > 10) { roll = 10; }
	  }
        }
	return roll;
      },
    });


    this.importTech("faction4-flagship", {
      name        	:       "Sardakk Flagship" ,
      faction     	:       "faction4",
      type      	:       "ability" ,
      text	  :	  "+1 on all combat rolls for ships in same sector" ,
      modifyCombatRoll :	  function(imperium_self, attacker, defender, player, combat_type, roll) {
	if (combat_type == "space") {
	  let flagship_bonus = 0;
	  if (imperium_self.doesSectorContainPlayerUnit(attacker, imperium_self.game.state.activated_sector, "flagship")) {
	    imperium_self.updateLog("Sardakk Flagship adds +1 to dice roll");
	    roll += 1;
	    if (roll > 10) { roll = 10; }
	  } 
	}
        return roll;
      },
    });




    this.importTech("faction4-exotrireme-i", {

      name        :       "Exotrireme I" ,
      faction     :       "faction4",
      replaces    :       "dreadnaught",
      unit        :       1 ,
      type        :       "special",
      text	  :	  "A more powerful dreadnaught" ,
      prereqs     :       [],
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction4_advanced_dreadnaught_i == undefined) {
          imperium_self.game.players_info[player-1].faction4_advanced_dreadnaught_i = 0;
        }
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        imperium_self.game.players_info[gainer-1].faction4_advanced_dreadnaught_i = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (imperium_self.game.players_info[unit.owner-1].faction4_advanced_dreadnaught_i == 1 && unit.type == "dreadnaught") {
          unit.cost = 4;
          unit.combat = 5;
          unit.move = 1;
          unit.capacity = 1;
	  unit.strength = 2;
	  unit.bombardment_rolls = 2;
	  unit.bombardment_combat = 4;
	  unit.description = "The Exotrireme I is a more powerful dreadnaught not vulnerable to Direct Hit cards";
        }

        return unit;
      },

    });



    this.importTech("faction4-exotrireme-ii", {

      name        :       "Exotrireme II" ,
      faction     :       "faction4",
      replaces    :       "dreadnaught",
      unit        :       1 ,
      type        :       "special",
      prereqs     :       ["blue","blue","yellow"],
      text	  :	  "A much more powerful dreadnaught" ,
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction4_advanced_dreadnaught_ii == undefined) {
          imperium_self.game.players_info[player-1].faction4_advanced_dreadnaught_ii = 0;
        }
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
        imperium_self.game.players_info[gainer-1].faction4_advanced_dreadnaught_ii = 1;
        imperium_self.game.players_info[gainer-1].faction4_advanced_dreadnaught_i = 0;
      },
      upgradeUnit :       function(imperium_self, player, unit) {
        if (imperium_self.game.players_info[unit.owner-1].faction4_advanced_dreadnaught_ii == 1 && unit.type == "dreadnaught") {
          unit.cost = 4;
          unit.combat = 5;
          unit.move = 2;
          unit.capacity = 1;
	  unit.strength = 2;
	  unit.bombardment_rolls = 2;
	  unit.bombardment_combat = 4;
	  unit.description = "The Exotrireme II is a more powerful dreadnaught not vulnerable to Direct Hit cards. It may be destroyed after a round of space combat to destroy up to two opponent ships.";
        }
        return unit;
      },
      spaceCombatRoundEnd :    function(imperium_self, attacker, defender, sector) {
        if (imperium_self.doesPlayerHaveTech(attacker, "faction4-exotrireme-ii")) {
	  if (imperium_self.doesSectorContainPlayerUnit(attacker, sector, "dreadnaught")) {
	    imperium_self.addMove("faction4_exotrireme_ii_sacrifice\t"+attacker+"\t"+sector);
	  }
	}
        if (imperium_self.doesPlayerHaveTech(defender, "faction4-exotrireme-ii")) {
	  if (imperium_self.doesSectorContainPlayerUnit(defender, sector, "dreadnaught")) {
	    imperium_self.addMove("faction4_exotrireme_ii_sacrifice\t"+defender+"\t"+sector);
	  }
	}
	return 1;
      },
      handleGameLoop : function(imperium_self, qe, mv) {

        if (mv[0] == "faction4_exotrireme_ii_sacrifice") {

          let player_to_go = parseInt(mv[1]);
          let sys = imperium_self.returnSectorAndPlanets(mv[2]);
          let opponent = imperium_self.returnOpponentInSector(player_to_go, mv[2]);

	  if (player_to_go == imperium_self.game.player) {

	    if (opponent == -1) {
	      imperium_self.addMove("resolve\tfaction4_exotrireme_ii_sacrifice");

	      imperium_self.addMove("NOTIFY\tNo target ships for Sardakk Exotrireme II faction ability");
	      imperium_self.endTurn();
	      return 0;
	    }

	    let anything_to_kill = 0;
	    for (let i = 0; i < sys.s.units[opponent-1].length; i++) {
	      if (sys.s.units[opponent-1][i].strength > 0) {
	        anything_to_kill = 1;
	      }
	    }

	    if (anything_to_kill == 0) {
	      imperium_self.addMove("resolve\tfaction4_exotrireme_ii_sacrifice");
	      imperium_self.addMove("NOTIFY\tNo target ships for Sardakk Exotrireme II action ability");
	      imperium_self.endTurn();
	      return 0;
	    }

            html = '<div class="sf-readable">Do you wish to sacrifice a Dreadnaught to destroy up to 2 opponent ships?</div><ul>';
	    for (let i = 0; i < sys.s.units[imperium_self.game.player-1].length; i++) {
	      if (sys.s.units[imperium_self.game.player-1][i].type == "dreadnaught") {
                html += `<li class="option" id="${i}">sacrifice ${imperium_self.returnShipInformation(sys.s.units[imperium_self.game.player-1][i])}</li>`;
	      }
	    }
            html += '<li class="option" id="no">do not sacrifice</li>';
            html += '</ul>';

	    imperium_self.updateStatus(html);

            $('.option').on('click', function () {

	      let action2 = $(this).attr("id");

	      if (action2 === "no") {
	        imperium_self.addMove("resolve\tfaction4_exotrireme_ii_sacrifice");
	        imperium_self.endTurn();
	        return 0;
	      }

	      imperium_self.addMove("resolve\tfaction4_exotrireme_ii_sacrifice");
 	      imperium_self.addMove("faction4_exotrireme_ii_picktwo\t"+imperium_self.game.player+"\t"+mv[2]);
 	      imperium_self.addMove("NOTIFY\tSardakk sacrifies Exotritreme II to destroy opponent ships");
 	      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"space"+"\t"+mv[2]+"\t"+"0"+"\t"+action2+"\t"+"1");
	      imperium_self.endTurn();
	      return 0;
	    });
	  }
	  return 0;
        }



        if (mv[0] == "faction4_exotrireme_ii_picktwo") {

          let player_to_go = parseInt(mv[1]);
          let sys = imperium_self.returnSectorAndPlanets(mv[2]);

	  if (player_to_go == imperium_self.game.player) {
	    imperium_self.addMove("resolve\tfaction4_exotrireme_ii_picktwo");
	    imperium_self.playerDestroyOpponentShips(player_to_go, 2, mv[2]);
	  } else {
	    imperium_self.updateStatus("Exotrireme II engaging in suicide assault");
	  }

	  return 0;

        }
      }
    });




    this.importTech('faction4-particle-weave', {
      name        :       "Particle Weave" ,
      faction     :       "faction4",
      type        :       "special" ,
      prereqs	  :	["red","red"],
      text	  :	  "Infantry vaporize 1 opponent for each hit received" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction4_particle_weave == undefined) {
          imperium_self.game.players_info[player-1].faction4_particle_weave = 0;
          imperium_self.game.players_info[player-1].faction4_particle_weave_opponent = 0;
          imperium_self.game.players_info[player-1].faction4_particle_weave_my_forces = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
	if (tech == "faction4-particle-weave") {
          imperium_self.game.players_info[gainer-1].faction4_particle_weave = 1;
        }
      },
      groundCombatTriggers : function(imperium_self, player, sector, planet_idx) {
        if (imperium_self.doesPlayerHaveTech(player, "faction4-particle-weave")) {
	  //
	  // if player is in combat
	  //
	  let sys = imperium_self.returnSectorAndPlanets(sector);
          let planet = sys.p[planet_idx];
          imperium_self.game.players_info[player-1].faction4_particle_weave_my_forces = planet.units[player-1].length;

        }
        return 0;
      },

      groundCombatRoundEnd(imperium_self, attacker, defender, sector, planet_idx) { 

        if (imperium_self.doesPlayerHaveTech(attacker, "faction4-particle-weave")) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  let planet = sys.p[planet_idx];
	  let current_forces = planet.units[attacker-1].length;
	  if (current_forces < imperium_self.game.players_info[attacker-1].faction4_particle_weave_my_forces) {
	    imperium_self.updateLog("Sardakk Particle Weave vaporizes 1 opponent infantry...");
	    for (let z = 0; z < planet.units[defender-1].length; z++) {
	      if (planet.units[defender-1][z].type == "infantry") {
		planet.units[defender-1].splice(z, 1);
		z = planet.units[defender-1].length+1;
	      }
	    }
	  }
	  imperium_self.saveSystemAndPlanets(sys);
	}

        if (imperium_self.doesPlayerHaveTech(defender, "faction4-particle-weave")) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  let planet = sys.p[planet_idx];
	  let current_forces = planet.units[defender-1].length;
	  if (current_forces < imperium_self.game.players_info[defender-1].faction4_particle_weave_my_forces) {
	    imperium_self.updateLog("Sardakk Particle Weave vaporizes 1 opponent infantry...");
	    for (let z = 0; z < planet.units[attacker-1].length; z++) {
	      if (planet.units[attacker-1][z].type == "infantry") {
		planet.units[attacker-1].splice(z, 1);
		z = planet.units[attacker-1].length+1;
	      }
	    }
	  }
	  imperium_self.saveSystemAndPlanets(sys);
	}

	return 1; 
      }
    });



    this.importFaction('faction1', {
      id		:	"faction1" ,
      name		: 	"Federation of Sol",
      nickname		: 	"Sol",
      homeworld		: 	"sector52",
      space_units	:	["carrier","carrier","destroyer","fighter","fighter","fighter"],
      ground_units	:	["infantry","infantry","infantry","infantry","infantry","spacedock"],
      tech		:	["neural-motivator","antimass-deflectors", "faction1-orbital-drop", "faction1-versatile", "faction1-flagship"],
      background	: 	"faction1.jpg",
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Sol Federation. a Terran faction under cellular military government. Your reinforced infantry and tactical flexibility will be important in your fight for the Imperial Throne. Good luck!</div>`
    });
 


    this.importTech("faction1-flagship", {

      name        :       "Sol Flagship" ,
      faction     :       "faction1",
      text	  :	  "Flagship gains 1 infantry when player selects a strategy card" ,
      type	  :	  "ability" ,
      playersChooseStrategyCardsBeforeTriggers : function(imperium_self, player) {
	if (!imperium_self.doesPlayerHaveTech(player, "faction1-flagship")) { return 0; }
        let player_fleet = imperium_self.returnPlayerFleet(player);
	if (player_fleet.flagship > 0) {
	  return 1;
	}
	return 0;
      },
      playersChooseStrategyCardsBeforeEvent : function(imperium_self, player) {
	for (let i in this.game.sectors) {
	  if (imperium_self.doesSectorContainPlayerUnit(player, i, "flagship")) {
	    let sec = this.game.sectors[i];
	    for (let k = 0; k < sec.units[player-1].length; k++) {
	      if (sec.units[player-1][k].type == "flagship") {
		imperium_self.loadUnitOntoShip(player, i, k, "infantry");
		imperium_self.updateLog("Faction Ability: infantry added to Sol Flagship...");
		return 1;
	      }
	    }
	  }
	}
	return 1;
      }  
    });




    this.importTech("faction1-orbital-drop", {

      name        :       "Orbital Drop" ,
      faction     :       "faction1",
      type	:	  "ability" ,
      text	  :	  "Drop two infantry onto any controlled planet" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].orbital_drop == undefined) {
          imperium_self.game.players_info[player-1].orbital_drop = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction1-orbital-drop") {
          imperium_self.game.players_info[gainer-1].orbital_drop = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
	if (menu === "main") {
          x.event = 'orbitaldrop';
          x.html = '<li class="option" id="orbitaldrop">orbital drop</li>';
	}
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) { 
        if (imperium_self.doesPlayerHaveTech(player, "faction1-orbital-drop") && menu === "main") {
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) { 
	    if (imperium_self.game.state.active_player_moved == 0) {
	      return 1;
	    }
	  }
	}
        return 0; 
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

	if (imperium_self.game.player == player) {
	
          imperium_self.playerSelectPlanetWithFilter(
            "Use Orbital Drop to reinforce which planet with two infantry: " ,
            function(planet) {
	      if (imperium_self.game.planets[planet].owner == imperium_self.game.player) { return 1; } return 0;
            },
            function(planet) {
              planet = imperium_self.game.planets[planet];
              imperium_self.addMove("resolve\tplay");
              imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
              imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
              imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
              imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\t"+"strategy"+"\t"+"1");
              imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys three infantry to " + planet.name);
              imperium_self.endTurn();
              return 0;
            },
	    null
	  );
	  return 0;
        };
      }
    });

    this.importTech("faction1-versatile", {

      name        :       "Versatile" ,
      faction     :       "faction1",
      type        :       "ability" ,
      text	  :	  "Gain an extra command token each round" ,
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction1-versatile")) {
          imperium_self.game.players_info[player-1].new_tokens_per_round = 3;
	}
      },

    });


    this.importTech("faction1-advanced-carrier-ii", {

      name        :       "Advanced Carrier II" ,
      faction     :       "faction1",
      replaces    :       "carrier-ii",
      unit        :       1 ,
      type	  :	"special",
      text	  :	  "A more sophisticated carrier" ,
      prereqs     :       ["blue","blue"],
      initialize :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction1_advanced_carrier_ii == undefined) {
	  imperium_self.game.players_info[player-1].faction1_advanced_carrier_ii = 0;
	}
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	imperium_self.game.players_info[gainer-1].faction1_advanced_carrier_ii = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {

	if (imperium_self.game.players_info[unit.owner-1].faction1_advanced_carrier_ii == 1 && unit.type == "carrier") {
          unit.cost = 3;
          unit.combat = 9;
          unit.move = 2;
          unit.capacity = 8;
        }

        return unit;
      },

    });


    this.importTech("faction1-advanced-infantry-ii", {

      name        :       "Special Ops II" ,
      faction     :       "faction1",
      replaces    :       "infantry-ii",
      unit        :       1 ,
      type	  :  	  "special",
      text	  :	  "Battle-hardened infantry" ,
      prereqs     :       ["green","green"],
      initialize  :       function(imperium_self, player) {
	imperium_self.game.players_info[player-1].faction1_advanced_infantry_ii = 0;
      },
      gainTechnology :       function(imperium_self, gainer, tech) {
	imperium_self.game.players_info[gainer-1].faction1_advanced_infantry_ii = 1;
      },
      upgradeUnit :       function(imperium_self, player, unit) {

	if (imperium_self.game.players_info[unit.owner-1].faction1_advanced_infantry_ii == 1 && unit.type == "infantry") {
          unit.cost = 0.5;
          unit.combat = 6;
        }

        return unit;
      },

    });




    this.importFaction('faction3', {
      id		:	"faction3" ,
      name		: 	"XXCha Kingdom",
      nickname		: 	"XXCha",
      homeworld		: 	"sector51",
      space_units	: 	["carrier","cruiser","cruiser","fighter","fighter","fighter"],
      ground_units	: 	["infantry","infantry","infantry","infantry","pds","spacedock"],
      tech		: 	["graviton-laser-system","faction3-peace-accords","faction3-quash","faction3-flagship","faction3-field-nullification"],
      background	: 	'faction3.jpg',
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the XXCha Kingdom, a faction which excels in diplomacy and defensive weaponry. With the proper alliances and political maneuvers your faction you can be a contender for the Imperial Throne. Good luck!</div>`
    });
  




    this.importTech('faction3-flagship', {
      name        :       "XXCha Flagship" ,
      faction     :       "faction3",
      type        :       "ability" ,
      text	:	  "3 space cannons which target adjacent systems attached to flagship" ,
      returnPDSUnitsWithinRange : function(imperium_self, player, attacker, defender, sector, battery) {

       if (!imperium_self.doesPlayerHaveTech(player, "faction3-flagship")) { return battery; }

       let player_fleet = imperium_self.returnPlayerFleet(player);
       if (player_fleet.flagship > 0) {

         let as = this.returnAdjacentSectors(sector);
         for (let i = 0; i < as.length; i++) {
	   if (imperium_self.doesSectorContainPlayerUnit(player, as[i], "flagship")) {

             let pds1 = {};
                 pds1.range = imperium_self.returnUnit(player, "pds").range;
                 pds1.combat = imperium_self.returnUnit(player, "pds").combat;
                 pds1.owner = player;
                 pds1.sector = sector;

             let pds2 = {};
                 pds2.range = imperium_self.returnUnit(player, "pds").range;
                 pds2.combat = imperium_self.returnUnit(player, "pds").combat;
                 pds2.owner = player;
                 pds2.sector = sector;

             let pds3 = {};
                 pds3.range = imperium_self.returnUnit(player, "pds").range;
                 pds3.combat = imperium_self.returnUnit(player, "pds").combat;
                 pds3.owner = player;
                 pds3.sector = sector;

             battery.push(pds1);
             battery.push(pds2);
             battery.push(pds3);
     
	     return battery;
	   }
	 }
        }
       return battery;
      }
    });






    this.importTech('faction3-peace-accords', {

      name        :       "Peace Accords" ,
      faction     :       "faction3",
      type        :       "ability",
      text	:	  "Colonize adjacent unprotected planet when diplomacy secondary is played" ,
      initialize  : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].peace_accords == undefined) {
          imperium_self.game.players_info[player-1].peace_accords = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction3-peace-accords") {
          imperium_self.game.players_info[gainer-1].peace_accords = 1;
        }
      },
      strategyCardAfterTriggers : function(imperium_self, player, strategy_card_player, card) {
	if (imperium_self.game.players_info[player-1].peace_accords == 1) { return 1; }
	return 0;
      },
      strategyCardAfterEvent : function(imperium_self, player, strategy_card_player, card) {

	if (card == "diplomacy") {

	  let pcs = imperium_self.returnPlayerPlanetCards(player);
	  let sectors = [];
	  let adjacent_sectors = [];
	  let seizable_planets = [];

	  for (let i = 0; i < pcs.length; i++) {
	    if (!sectors.includes(imperium_self.game.planets[pcs[i]].sector)) {
	      sectors.push(imperium_self.game.planets[pcs[i]].sector);
	      adjacent_sectors.push(imperium_self.game.planets[pcs[i]].sector);
	    }
	  }

	 /*** add to include planets adjacent to units ***
         let plsectors = this.returnSectorsWithPlayerUnits(player);
         for (let i = 0; i < plsectors.length; i++) {
	   if (!sectors.includes(plsectors[i])) {
	      sectors.push(plsectors[i]);
	      adjacent_sectors.push(plsectors[i]);
           }
         }
	 *** add to include planets adjacent to units ***/



	  //
	  // get all planets adjacent to...
	  //
	  for (let i = 0; i < sectors.length; i++) {
	    let as = imperium_self.returnAdjacentSectors(sectors[i]);
	    for (let z = 0; z < as.length; z++) {
	      if (!adjacent_sectors.includes(as[z])) { adjacent_sectors.push(as[z]); }
	    }
    	  }

	  //
	  // get all planets I don't control in those sectors
	  //
	  for (let b = 0; b < adjacent_sectors.length; b++) {
	    let sys = imperium_self.returnSectorAndPlanets(adjacent_sectors[b]);
	    if (sys.p) {
	      for (let y = 0; y < sys.p.length; y++) {
	        let planet_uncontrolled = 0;
	        if (sys.p[y].owner != player) {
		  if (!imperium_self.doesPlanetHaveInfantry(sys.p[y])) {
	  	    seizable_planets.push(sys.p[y].planet);
	          }
	        }
	      }
	    }
	  }

	  //
	  //
	  //
	  if (seizable_planets.length < 0) { 
	    return 1;
	  }



	  if (imperium_self.game.players_info[player-1].peace_accords == 1) {
	    if (imperium_self.game.player == player) {
              imperium_self.playerSelectPlanetWithFilter(
                "Select a planet to annex via Peace Accords: " ,
                function(planet) {
	  	  if (seizable_planets.includes(planet)) { return 1; } return 0;
                },
                function(planet) {
                  imperium_self.addMove("annex\t"+imperium_self.game.player+"\t"+imperium_self.game.planets[planet].sector+"\t"+imperium_self.game.planets[planet].idx);
                  imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " annexes " + imperium_self.game.planets[planet].name + " via Peace Accords");
	    	  imperium_self.endTurn();
                  return 0;
                },
	        function() {
	    	  imperium_self.endTurn();
                  return 0;
		}
              );
            }
            return 0;
          }
	  return 1;
	}
	return 1;
      }
    });




    this.importTech('faction3-quash', {
      name        :       "Quash" ,
      faction     :       "faction3",
      type        :       "ability" ,
      text	:	  "Spend strategy token to quash upcoming agenda" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].quash == undefined) {
          imperium_self.game.players_info[player-1].quash = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction3-quash") {
          imperium_self.game.players_info[gainer-1].quash = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
	if (menu === "main") {
          x.event = 'quash';
          x.html = '<li class="option" id="quash">quash agenda</li>';
        }
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) { 
        if (imperium_self.doesPlayerHaveTech(player, "faction3-quash") && menu == "main") {
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) { 
	    if (imperium_self.game.state.active_player_moved == 0) {
	      return 1;
	    }
	  }
	}
	return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

        if (imperium_self.game.player == player) {

          let html = '';
          html += 'Select one agenda to quash in the Galactic Senate.<ul>';
          for (i = 0; i < imperium_self.game.state.agendas.length; i++) {
	    if (imperium_self.game.state.agendas[i] != "") {
              html += '<li class="option" id="'+imperium_self.game.state.agendas[i]+'">' + imperium_self.agenda_cards[imperium_self.game.state.agendas[i]].name + '</li>';
            }
          }
          html += '</ul>';

          imperium_self.updateStatus(html);

          $('.option').off();
          $('.option').on('mouseenter', function() { let s = $(this).attr("id"); imperium_self.showAgendaCard(imperium_self.game.state.agendas[s]); });
          $('.option').on('mouseleave', function() { let s = $(this).attr("id"); imperium_self.hideAgendaCard(imperium_self.game.state.agendas[s]); });
          $('.option').on('click', function() {

             let agenda_to_quash = $(this).attr('id');
	     imperium_self.updateStatus("Quashing Agenda");

             imperium_self.addMove("expend\t"+imperium_self.game.player+"\t"+"strategy"+"\t"+"1");
             imperium_self.addMove("quash\t"+agenda_to_quash+"\t"+"1"); // 1 = re-deal
	     imperium_self.endTurn();
	  });
	}
      }
    });




    this.importTech('faction3-instinct-training', {
      name        :       "Instinct Training" ,
      faction     :       "faction3",
      prereqs	:	["green"] ,
      color	:   "green" ,
      type        :       "special" ,
      text	:	  "Expend strategy token to cancel opponent action card" ,
      initialize  :	  function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].instinct_training == null) {
          imperium_self.game.players_info[player-1].instinct_training = 0;
	}
      },
      gainTechnology : function(imperium_self, gainer, tech) {
	if (tech == "faction3-instinct-training") {
          imperium_self.game.players_info[gainer-1].instinct_training = 1;
        }
      },
      playActionCardTriggers : function(imperium_self, player, action_card_player, card) {
        if (imperium_self.game.players_info[player-1].instinct_training == 1) { return 1; }
	return 0;
      },
      playActionCardEvent : function(imperium_self, player, action_card_player, card) {

        if (imperium_self.game.player == player) {
          // remove previous action card
          imperium_self.addMove("resolve\t"+"action_card");
          imperium_self.addMove("resolve\t"+"action_card_post");
          imperium_self.addMove("expend\t"+imperium_self.game.player+"strategy"+"1");
	  imperium_self.endTurn();
        }

	return 0;

      },
    });

    this.importTech('faction3-field-nullification', {

      name        :       "Nullification Fields" ,
      faction     :       "faction3",
      type        :       "special" ,
      color	  :	  "yellow" ,
      prereqs	:	["yellow","yellow"] ,
      text	:	  "Terminate the turn of active player who activates a system containing your ship" ,
      initialize  : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].field_nullification == undefined) {
          imperium_self.game.players_info[player-1].field_nullification = 0;
          imperium_self.game.players_info[player-1].field_nullification_exhausted = 0;
        }
      },
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction3-field-nullification")) {
          imperium_self.game.players_info[player-1].field_nullification_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction3-field-nullification") {
          imperium_self.game.players_info[gainer-1].field_nullification = 1;
          imperium_self.game.players_info[gainer-1].field_nullification_exhausted = 0;
        }
      },
      activateSystemTriggers : function(imperium_self, activating_player, player, sector) {
        if (imperium_self.doesPlayerHaveTech(player, "faction3-field-nullification")) {
	  if (imperium_self.doesSectorContainPlayerShips(player, sector)) { 
	    if (activating_player != player) { return 1; }
	  }
	}
	return 0;
      },
      activateSystemEvent : function(imperium_self, activating_player, player, sector) {
        if (imperium_self.doesPlayerHaveTech(player, "faction3-field-nullification")) {

	  if (imperium_self.game.players_info[player-1].field_nullification_exhausted == 1) { return 1; }

	  if (imperium_self.game.player != player) {
	    imperium_self.updateStatus(imperium_self.returnFaction(player) + " is deciding whether to use Nullification Fields");
	    return 0;
	  }

	  let html = 'Do you wish to use Field Nullification to terminate this player\'s turn? <ul>';
	  html += '<li class="textchoice" id="yes">activate nullification field</li>';
	  html += '<li class="textchoice" id="no">do not activate</li>';
	  html += '</ul>';

	  imperium_self.updateStatus(html);

	  $('.textchoice').off();
	  $('.textchoice').on('click', function() {

	    let choice = $(this).attr("id");

	    if (choice == "yes") {
              imperium_self.addMove("resolve\tplay");
              imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
              imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
	      imperium_self.addMove("field_nullification\t"+player+"\t"+activating_player+"\t"+sector);
	      imperium_self.endTurn();
	    }
	    if (choice == "no") {
	      imperium_self.endTurn();
	    }
	  });
	  return 0;
        }
	return 1;
      },
      handleGameLoop : function(imperium_self, qe, mv) {
        if (mv[0] == "field_nullification") {

          let player = parseInt(mv[1]);
          let activating_player = parseInt(mv[2]);
	  let sector = mv[3];
          imperium_self.game.queue.splice(qe, 1);

	  imperium_self.updateLog(imperium_self.returnFactionNickname(player) + " uses Nullification Fields to end " + imperium_self.returnFactionNickname(activating_player) + " turn");

          return 1;

        }
	return 1;
      }
    });



    this.importFaction('faction5', {
      id		:	"faction5" ,
      name		: 	"Yin Brotherhood",
      nickname		: 	"Yin",
      homeworld		: 	"sector74",
      space_units	: 	["carrier","carrier","destroyer","fighter","fighter","fighter","fighter"],
      ground_units	: 	["infantry","infantry","infantry","infantry","spacedock"],
      tech		: 	["sarween-tools", "faction5-indoctrination", "faction5-devotion", "faction5-flagship"],
      background	: 	'faction5.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Yin Brotherhood, a monastic order of religious zealots whose eagerness to sacrifice their lives for the collective good makes them terrifying in one-on-one combat. Direct their self-destructive passion and you can win the Imperial Throne. Good luck!</div>`
    });



    // two influence to convert an opponent infantry to your side
    //
    // runs at the start of ground combat, and after every round
    //
    this.importTech('faction5-indoctrination', {
      name        :       "Indoctrination" ,
      faction     :       "faction5",
      type        :       "ability" ,
      text        :       "Spend 2 influence to convert 1 enemy infantry at combat start" ,
      groundCombatTriggers : function(imperium_self, player, sector, planet_idx) {
        if (imperium_self.doesPlayerHaveTech(player, "faction5-indoctrination")) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  if (sys.p[planet_idx].units[player-1].length > 0) {
            if (imperium_self.returnAvailableInfluence(player) >= 2) {
	      if (imperium_self.game.state.ground_combat_round < 2) {
	        return 1;
	      }
            }
          }
        }
	return 0;
      },
      groundCombatEvent : function(imperium_self, player, sector, planet_idx) { 
	if (imperium_self.game.player == player) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  if (sys.p[planet_idx].units[player-1].length > 0) {
            imperium_self.playIndoctrination(imperium_self, player, sector, planet_idx, function(imperium_self) {	  
  	      imperium_self.endTurn();
            });
	  } else {
  	    imperium_self.endTurn();
          }
          return 0;
        }
      },
    });



    //
    // after each space battle round, sacrifice cruiser or destroyer to assign 1 hit to a unit
    //
    this.importTech('faction5-devotion', {
      name        :       "Devotion" ,
      faction     :       "faction5",
      type        :       "ability" ,
      text        :       "Sacrifice destroyer or cruiser to assign 1 enemy hit at combat end" ,
      spaceCombatTriggers : function(imperium_self, player, sector) {
        if (imperium_self.doesPlayerHaveTech(player, "faction5-devotion")) {
          if (imperium_self.doesPlayerHaveShipsInSector(player, sector)) {
            if (imperium_self.game.state.space_combat_round > 0) {
              return 1;
            }
          }
        }
	return 0;
      },
      spaceCombatEvent : function(imperium_self, player, sector) {
        if (imperium_self.game.player == player) {
          imperium_self.playDevotion(imperium_self, player, sector, function() {
            imperium_self.endTurn();
          });
	}
	return 0;
      }
    });


    this.importTech('faction5-impulse-core', {
      name        :       "Impulse Core" ,
      faction     :       "faction5",
      prereqs     :       ["yellow", "yellow"] ,
      color       :       "yellow" ,
      type        :       "special" ,
      text        :       "Sacrifice destroyer or cruiser at combat start, opponent takes hit on capital ship" ,
      spaceCombatTriggers : function(imperium_self, player, sector) {
        if (imperium_self.doesPlayerHaveTech(player, "faction5-impulse-core")) {
          if (imperium_self.doesPlayerHaveShipsInSector(player, sector)) {
            if (imperium_self.game.state.space_combat_round == 0) {
              return 1;
            }
          }
        }
        return 0;
      },
      spaceCombatEvent : function(imperium_self, player, sector) {
	if (imperium_self.game.player == player) {
          imperium_self.playDevotion(imperium_self, player, sector, function() {
            imperium_self.endTurn();
          }, 1);
	}
	return 0;
      }
    });



    this.importTech('faction5-yin-spinner', {
      name        :       "Yin Spinner" ,
      faction     :       "faction5",
      prereqs     :       ["green", "green"] ,
      color       :       "green" ,
      type        :       "special" ,
      initialize  :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction5_yin_spinner == null) {
          imperium_self.game.players_info[player-1].faction5_yin_spinner = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction5-yin-spinner") {
          imperium_self.game.players_info[gainer-1].faction5_yin_spinner = 1;
        }
      },
      playerEndTurnTriggers : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction5_yin_spinner == 1) {
	  if (imperium_self.game.player == player) {
            if (imperium_self.game.state.active_player_has_produced == 1) {
	      return 1;
            }
          }
        }
	return 0;
      },
      playerEndTurnEvent : function(imperium_self, player) {

	if (imperium_self.game.player != player) { return 0; }

        imperium_self.playerSelectPlanetWithFilter(
              "Yin Spinner Tech: place additional infantry on which planet?",
              function(planet) {
                planet = imperium_self.game.planets[planet];
                if (planet.owner == imperium_self.game.player) { return 1; } return 0;
              },
              function(planet) {
                planet = imperium_self.game.planets[planet];
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sectors);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " spins extra infantry on " + planet.name);
                imperium_self.endTurn();
                return 0;

              },
              function() {
                imperium_self.playerTurn();
              }
        );
      }
    });










    
    this.importTech("faction5-flagship", {
      name        	:       "Yin Flagship" ,
      faction     	:       "faction5",
      type      	:       "ability" ,
      text        	:       "Wipes out all ships in sector when destroyed" ,
      unitDestroyed : function(imperium_self, attacker, unit) {
	if (unit.type == "flagship") {
          if (imperium_self.doesPlayerHaveTech(unit.owner, "faction5-flagship")) {

	    let active_sector = imperium_self.game.state.activated_sector;
            if (active_sector === "") { active_sector = imperium_self.game.state.space_combat_sector; }

	    // destroy all units in this sector
	    let sys = imperium_self.returnSectorAndPlanets(active_sector);

	    if (sys) {

	      for (let i = 0; i < sys.s.units.length; i++) {
		sys.s.units[i] = [];
	      }
	      for (let i = 0; i < sys.p.length; i++) {
	        for (let ii = 0; ii < sys.p[i].units.length; ii++) {
		  sys.p[i].units[ii] = [];
	        }
	      }

              imperium_self.saveSystemAndPlanets(active_sector);
              imperium_self.updateSectorGraphics(active_sector);
	      imperium_self.updateLog("The destruction of the Yin Flagship has caused a terrible calamity...");

	    }
	  }
	}
	return unit;
      },
    });





this.playIndoctrination = function(imperium_self, player, sector, planet_idx, mycallback) {

  if (this.game.player != player) { return; }
  if (this.game.player != player) { return; }

  let sys = imperium_self.returnSectorAndPlanets(sector);
  let planet = sys.p[planet_idx];
  let opponent = imperium_self.returnOpponentOnPlanet(player, planet);
  let can_play_indoctrination = 0;

  if (imperium_self.returnNonPlayerInfantryOnPlanet(player, planet) <= 0 || opponent == -1) {
    mycallback(imperium_self);
    return;
  }

  if (sys.p[planet_idx].units[opponent-1].length <= 0) {
    mycallback(imperium_self);
    return;
  }

  let html = "<div class='sf-readable'>Do you wish to spend 2 influence to convert 1 enemy infantry to your side?</div><ul>";
      html += '<li class="textchoice" id="yes">yes</li>';
      html += '<li class="textchoice" id="no">no</li>';
      html += '</ul>';
  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {
    let action2 = $(this).attr("id");
    if (action2 === "no") {
      mycallback(imperium_self);
      return;
    }
    if (action2 === "yes") {

      imperium_self.playerSelectInfluence(2, function (success) {

        if (success == 1) {
          imperium_self.addMove("destroy_infantry_on_planet"+"\t"+player+"\t"+sector+"\t"+planet_idx+"\t"+1);
          imperium_self.addMove("add_infantry_to_planet"+"\t"+player+"\t"+planet.planet+"\t"+1);
          imperium_self.addMove("NOTIFY\tYin Indoctrination converts opposing infantry");
        } else {
          mycallback(imperium_self);
          return;
        }
      });
    }
  });
}
   



this.playDevotion = function(imperium_self, player, sector, mycallback, impulse_core=0) {

  if (imperium_self.game.player != player) { return 0; }

  let sys = imperium_self.returnSectorAndPlanets(sector);
  let opponent = imperium_self.returnOpponentInSector(player, sector);

  let can_sacrifice_destroyer = imperium_self.doesSectorContainPlayerUnit(player, sector, "destroyer");
  let can_sacrifice_cruiser = imperium_self.doesSectorContainPlayerUnit(player, sector, "cruiser");
 
  if (can_sacrifice_destroyer != 1 && can_sacrifice_cruiser != 1) {
    mycallback(imperium_self);
    return;
  }
  if (opponent == -1) {
    mycallback(imperium_self);
    return;
  }


  let html = "<div class='sf-readable'>Do you wish to sacrifice a Destroyer or Cruiser to assign 1 hit to an enemy ship?</div><ul>";
  if (can_sacrifice_destroyer) {
      html += '<li class="textchoice" id="destroyer">sacrifice destroyer</li>';
  }
  if (can_sacrifice_cruiser) {
      html += '<li class="textchoice" id="cruiser">sacrifice cruiser</li>';
  }
      html += '<li class="textchoice" id="no">no</li>';
      html += '</ul>';
  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {
    let action2 = $(this).attr("id");
    if (action2 === "no") {
      mycallback(imperium_self);
      return;
    }
    if (action2 === "destroyer") {

      let unit_idx = 0;
      for (let i = 0; i < sys.s.units[player-1].length; i++) {
	if (sys.s.units[player-1][i].type == "destroyer") {
	  unit_idx = i;
        }
      }

      imperium_self.addMove("destroy_unit"+"\t"+player+"\t"+player+"\t"+"space"+"\t"+sector+"\t"+0+"\t"+unit_idx+"\t"+1);
      imperium_self.playDevotionAssignHit(imperium_self, player, sector, mycallback, impulse_core);
      return;
    }
    if (action2 === "cruiser") {

      let unit_idx = 0;
      for (let i = 0; i < sys.s.units[player-1].length; i++) {
	if (sys.s.units[player-1][i].type == "cruiser") {
	  unit_idx = i;
        }
      }

      imperium_self.addMove("destroy_unit"+"\t"+player+"\t"+player+"\t"+"space"+"\t"+sector+"\t"+0+"\t"+unit_idx+"\t"+1);
      imperium_self.playDevotionAssignHit(imperium_self, player, sector, mycallback, impulse_core);
      return;
    }
  });

  return 0;
}
   
this.playDevotionAssignHit = function(imperium_self, player, sector, mycallback, impulse_core=0) {

  let sys = imperium_self.returnSectorAndPlanets(sector);
  let opponent = imperium_self.returnOpponentInSector(player, sector);

  if (impulse_core == 1) {
    this.addMove("assign_hits_capital_ship"+"\t"+opponent+"\t"+sector+"\t"+1);
    mycallback();
    return;
  }

  let html = "<div class='sf-readable'>Assign 1 hit to which opponent ship?</div><ul>";
  for (let i = 0; i < sys.s.units[opponent-1].length; i++) {

    let unit = sys.s.units[opponent-1][i];

    html += '<li class="textchoice" id="'+i+'">'+unit.name;

    if (unit.capacity >= 1) {
      let fleet = '';
      let fighters = 0;
      let infantry = 0;
      for (let ii = 0; ii < unit.storage.length; ii++) {
        if (unit.storage[ii].type == "infantry") {
          infantry++;
        }
        if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
          fighters++;
        }
      }
      if (infantry > 0 || fighters > 0) {
        fleet += ' ';
        if (infantry > 0) { fleet += infantry + "i"; }
        if (fighters > 0) {
          if (infantry > 0) { fleet += ", "; }
          fleet += fighters + "f";
        }
        fleet += ' ';
      }
      html += fleet;
    }

    html += '</li>';

  }
  html += '</ul>';

  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    $('.textchoice').off();
    let unit_idx = $(this).attr("id");
    imperium_self.addMove("assign_hit"+"\t"+player+"\t"+opponent+"\t"+player+"\t"+"ship"+"\t"+sector+"\t"+unit_idx+"\t"+1);
    mycallback(imperium_self);
    return;

  }); 
}




    this.importFaction('faction6', {
      id		:	"faction6" ,
      name		: 	"Yssaril Tribes",
      nickname		: 	"Yssaril",
      homeworld		: 	"sector75",
      space_units	: 	["carrier","carrier","cruiser","fighter","fighter"],
      ground_units	: 	["infantry","infantry","infantry","infantry","infantry","pds","spacedock"],
      //tech		: 	["neural-motivator", "faction6-stall-tactics", "faction6-scheming", "faction6-crafty","faction6-transparasteel-plating","faction6-mageon-implants","faction6-flagship"],
      tech		: 	["neural-motivator", "faction6-stall-tactics", "faction6-scheming", "faction6-crafty","faction6-flagship"],
      background	: 	'faction6.jpg' ,
      promissary_notes	:	["trade","political","ceasefire","throne"],
      intro             :       `<div style="font-weight:bold">Welcome to Red Imperium!</div><div style="margin-top:10px;margin-bottom:15px;">You are playing as the Yssaril Tribe, a primitive race of swamp-dwelling creatures whose fast instincts and almost unerring ability to change tactics on-the-fly lead many to suspect more is at work than their primitive appearance belies. Good luck!</div>`
    });






    this.importTech("faction6-stall-tactics", {

      name        :       "Stall Tactics" ,
      faction     :       "faction6",
      type      :         "ability" ,
      text        :       "Discard an Action Card to stall one turn" ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].stall_tactics == undefined) {
          imperium_self.game.players_info[player-1].stall_tactics = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction6-stall-tactics") {
          imperium_self.game.players_info[gainer-1].stall_tactics = 1;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        let x = {};
        if (menu === "main") {
          x.event = 'stalltactics';
          x.html = '<li class="option" id="stalltactics">discard action card (stall)</li>';
        }
        return x;
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction6-stall-tactics") && menu === "main") {
	  let ac = imperium_self.returnPlayerActionCards(player);
	  if (ac.length > 0) {
            return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

        if (imperium_self.game.player == player) {
	  imperium_self.playerDiscardActionCards(1, function() {
            imperium_self.addMove("resolve\tplay");
            imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
            imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
            imperium_self.endTurn();
            return 0;
	  });
	}

	return 0;
      }
    });





    this.importTech("faction6-crafty", {

      name        :       "Crafty" ,
      faction     :       "faction6",
      type        :       "ability" ,
      text        :       "Unlimited action cards. Game effects cannot change." ,
      onNewRound     :    function(imperium_self, player) {
        if (imperium_self.doesPlayerHaveTech(player, "faction6-crafty")) {
          imperium_self.game.players_info[player-1].action_card_limit = 1000;
        }
      },
    });






    this.importTech("faction6-scheming", {

      name        :       "Scheming" ,
      faction     :       "faction6",
      type        :       "ability" ,
      text        :       "Receive bonus card when gaining action cards, then discard one" ,
      initialize  :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].faction6_scheming == null) {
          imperium_self.game.players_info[player-1].faction6_scheming = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction6-scheming") {
          imperium_self.game.players_info[gainer-1].faction6_scheming = 1;
        }
      },
      gainActionCards : function(imperium_self, player, amount) {
        if (imperium_self.doesPlayerHaveTech(player, "faction6-scheming")) {
          imperium_self.game.queue.push("yssaril_action_card_discard\t"+player+"\t1");
          imperium_self.game.queue.push("gain\t"+player+"\taction_cards"+"\t"+1+"\t"+"0");
          imperium_self.game.queue.push("DEAL\t2\t"+player+"\t1");
          imperium_self.game.queue.push("NOTIFY\t" + imperium_self.returnFaction(player) + " gains bonus action card and must discard one");
	}
        return 1;
      },
      handleGameLoop : function(imperium_self, qe, mv) {
        if (mv[0] == "yssaril_action_card_discard") {

          let player = parseInt(mv[1]);
          let num = parseInt(mv[2]);
          imperium_self.game.queue.splice(qe, 1);

	  if (imperium_self.game.player === player) {
	    imperium_self.playerDiscardActionCards(num, function() {
	      imperium_self.endTurn();
	    });
	  }

          return 0;
        }
	return 1;
      }
    });







    //
    // players that have passed cannot play action cards during your turn
    //
    this.importTech('faction6-transparasteel-plating', {
      name        :       "Transparasteel Plating" ,
      faction     :       "faction6",
      prereqs     :       ["green"] ,
      color       :       "green" ,
      type        :       "special" ,
      text        :       "Selectively terminate action cards from players who have passed on your turn" ,
      initialize  :       function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].transparasteel_plating == null) {
          imperium_self.game.players_info[player-1].transparasteel_plating = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction6-transparasteel-plating") {
          imperium_self.game.players_info[gainer-1].transparasteel_plating = 1;
        }
      },
      playActionCardTriggers : function(imperium_self, player, action_card_player, card) {
        if (imperium_self.game.players_info[player-1].transparasteel_plating == 1) {
	  if (imperium_self.game.player == player && action_card_player != player && imperium_self.game.players_info[action_card_player-1].passed == 1) {
	    return 1;
	  }
	}
	return 0; 
      },
      playActionCardEvent : function(imperium_self, player, action_card_player, card) {
        if (imperium_self.game.player == player) {
          // remove action card
          imperium_self.addMove("resolve\t"+"action_card");
          imperium_self.addMove("resolve\t"+"action_card_post");
          imperium_self.addMove("expend\t"+imperium_self.game.player+"strategy"+"1");
          imperium_self.endTurn();
        }
        return 0;
      },
    });




    this.importTech('faction6-mageon-implants', {
      name        :       "Mageon Implants" ,
      faction     :       "faction6",
      prereqs     :       ["green","green","green"] ,
      color       :       "green" ,
      type        :       "special" ,
      text        :       "Exhaust to look at other players action cards and take one." ,
      initialize : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].mageon_implants == undefined) {
          imperium_self.game.players_info[player-1].mageon_implants = 0;
          imperium_self.game.players_info[player-1].mageon_implants_exhausted = 0;
        }
      },
      onNewRound : function(imperium_self, player) {
        if (imperium_self.game.players_info[player-1].mageon_implants == 1) {
          imperium_self.game.players_info[player-1].mageon_implants = 1;
          imperium_self.game.players_info[player-1].mageon_implants_exhausted = 0;
        }
      },
      gainTechnology : function(imperium_self, gainer, tech) {
        if (tech == "faction6-mageon-implants") {
          imperium_self.game.players_info[gainer-1].mageon_implants = 1;
          imperium_self.game.players_info[gainer-1].mageon_implants_exhausted = 0;
        }
      },
      menuOption  :       function(imperium_self, menu, player) {
        if (menu == "main") {
          return { event : 'mageonimplants', html : '<li class="option" id="mageonimplants">exhaust mageon implants</li>' };
        }
        return {};
      },
      menuOptionTriggers:  function(imperium_self, menu, player) {
        if (menu == "main" && imperium_self.game.players_info[player-1].mageon_implants_exhausted == 0 && imperium_self.game.players_info[player-1].mageon_implants == 1) {
          return 1;
        }
        return 0;
      },
      menuOptionActivated:  function(imperium_self, menu, player) {

        imperium_self.playerSelectPlayerWithFilter(
          "Select a player from which to take an action card (if possible): " ,
          function(player) {
            if (player != imperium_self.game.player) { return 1; } return 0;
          },
          function(player) {
            imperium_self.addMove("faction6_choose_card_triggered\t"+imperium_self.game.player+"\t"+player);
            imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " pulls a random action card from " + imperium_self.returnFaction(player));
            imperium_self.endTurn();
            return 0;
          },
          function() {
            imperium_self.playerTurn();
          }
        );

        return 0;
      },
      handleGameLoop : function(imperium_self, qe, mv) {

        if (mv[0] == "faction6_choose_card_triggered") {

          let faction6_player = parseInt(mv[1]);
          let faction6_target = parseInt(mv[2]);
          imperium_self.game.queue.splice(qe, 1);

	  if (imperium_self.game.player === faction6_target) {
	    let ac = imperium_self.returnPlayerActionCards();
	    imperium_self.addMove("faction6_choose_card_return\t"+faction6_player+"\t"+faction6_target+"\t"+JSON.stringify(ac));
	    imperium_self.endTurn();
	  }

          return 0;
        }

        if (mv[0] == "faction6_choose_card_return") {

          let faction6_player = parseInt(mv[1]);
          let faction6_target = parseInt(mv[2]);
          let faction6_target_cards = JSON.parse(mv[3]);

          imperium_self.game.queue.splice(qe, 1);

	  if (imperium_self.game.player === faction6_player) {

    	    let html = '<div class="" style="margin-bottom:10px">Select ' + imperium_self.returnFactionNickname(faction6_target) + ' action card:</div><ul>';
	    for (let i = 0; i < faction6_target_cards.length; i++) {
      	      html += `<li class="option" id="${i}">${imperium_self.action_cards[faction6_target_cards[i]].name}</li>`;
	    }
	    html += `<li class="option" id="cancel">skip</li>`;

	    imperium_self.updateStatus(html);

            $('.option').off();
            $('.option').on('click', function () {

	      $('.option').off();

              let opt = $(this).attr("id");


	      if (opt === "skip") {
		imperium_self.playerTurn();	
		return 0;
	      }

	      imperium_self.addMove("setvar\tplayers\t"+imperium_self.game.player+"\t"+"mageon_implants_exhausted"+"\t"+"int"+"\t"+"1");
              imperium_self.addMove("pull\t"+imperium_self.game.player+"\t"+faction6_target+"\t"+"action"+"\t"+faction6_target_cards[opt]);
              imperium_self.endTurn();
              return 0;

            });
	  }

          return 0;
        }

	return 1;
      }

    });




    
    this.importTech("faction6-flagship", {
      name        	:       "Yssaril Flagship" ,
      faction     	:       "faction6",
      type      	:       "ability" ,
      text        	:       "May move through sectors containing other ships" ,
      upgradeUnit :       function(imperium_self, player, unit) {
        if (imperium_self.doesPlayerHaveTech(unit.owner, "faction6-flagship") && unit.type == "flagship") {
          unit.may_fly_through_sectors_containing_other_ships = 1;
          unit.move = 3;
        }
        return unit;
      },
    });







/****

this.playMageonImplants = function(imperium_self, player, target, mycallback) {

  if (imperium_self.game.player != player) { return 0; }



}



this.playDevotion = function(imperium_self, player, sector, mycallback, impulse_core=0) {


  let sys = imperium_self.returnSectorAndPlanets(sector);
  let opponent = imperium_self.returnOpponentInSector(player, sector);

  let can_sacrifice_destroyer = imperium_self.doesSectorContainPlayerUnit(player, sector, "destroyer");
  let can_sacrifice_cruiser = imperium_self.doesSectorContainPlayerUnit(player, sector, "cruiser");
 
  if (can_sacrifice_destroyer != 1 && can_sacrifice_cruiser != 1) {
    mycallback(imperium_self);
    return;
  }
  if (opponent == -1) {
    mycallback(imperium_self);
    return;
  }


  let html = "<div class='sf-readable'>Do you wish to sacrifice a Destroyer or Cruiser to assign 1 hit to an enemy ship?</div><ul>";
  if (can_sacrifice_destroyer) {
      html += '<li class="textchoice" id="destroyer">sacrifice destroyer</li>';
  }
  if (can_sacrifice_cruiser) {
      html += '<li class="textchoice" id="cruiser">sacrifice cruiser</li>';
  }
      html += '<li class="textchoice" id="no">no</li>';
      html += '</ul>';
  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {
    let action2 = $(this).attr("id");
    if (action2 === "no") {
      mycallback(imperium_self);
      return;
    }
    if (action2 === "destroyer") {

      let unit_idx = 0;
      for (let i = 0; i < sys.s.units[player-1].length; i++) {
	if (sys.s.units[player-1][i].type == "destroyer") {
	  unit_idx = i;
        }
      }

      imperium_self.addMove("destroy_unit"+"\t"+player+"\t"+player+"\t"+"space"+"\t"+sector+"\t"+0+"\t"+unit_idx+"\t"+1);
      imperium_self.playDevotionAssignHit(imperium_self, player, sector, mycallback, impulse_core);
      return;
    }
    if (action2 === "cruiser") {

      let unit_idx = 0;
      for (let i = 0; i < sys.s.units[player-1].length; i++) {
	if (sys.s.units[player-1][i].type == "cruiser") {
	  unit_idx = i;
        }
      }

      imperium_self.addMove("destroy_unit"+"\t"+player+"\t"+player+"\t"+"space"+"\t"+sector+"\t"+0+"\t"+unit_idx+"\t"+1);
      imperium_self.playDevotionAssignHit(imperium_self, player, sector, mycallback, impulse_core);
      return;
    }
  });

  return 0;
}

*****/






    this.importStrategyCard("construction", {
      name     			:       "Construction",
      rank			:	4,
      img			:	"/strategy/BUILD.png",

      text			:	"Build a PDS or Space Dock. Then build a PDS.<hr />Other players may spend a strategy token and activate a sector to build a PDS or Space Dock in it." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {
          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("strategy\t"+"construction"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
	  imperium_self.playerAcknowledgeNotice("You have played Construction. First you will have the option of producing a PDS or Space Dock. Then you will have the option of producing an additional PDS if you so choose.", function() {
            imperium_self.playerBuildInfrastructure((sector) => {
              imperium_self.playerBuildInfrastructure((sector) => {
		imperium_self.updateSectorGraphics(sector);
                imperium_self.endTurn();
              }, 2);
            }, 1);
          });
        }

      },


      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player != strategy_card_player && imperium_self.game.player == player) {

          let html = '<p>Construction has been played. Do you wish to spend 1 strategy token to build a PDS or Space Dock? This will activate the sector (if unactivated): </p><ul>';
          if (imperium_self.game.state.round == 1) { 
	    html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Construction strategy card. You may spend 1 strategy token to build a PDS or Space Dock on a planet you control (this will activate the sector). You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
	  }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            html += '<li class="option" id="yes">Yes</li>';
          }
	  html += '<li class="option" id="no">No</li>';
          html += '</ul>';
 
          imperium_self.updateStatus(html);

          imperium_self.lockInterface(); 

          $('.option').off();
          $('.option').on('click', function() {

            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();
 

            let id = $(this).attr("id");
 
            if (id == "yes") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tstrategy\t1");
              imperium_self.playerBuildInfrastructure((sector) => {
                imperium_self.addMove("activate\t"+imperium_self.game.player+"\t"+sector);
		imperium_self.updateSectorGraphics(sector);
                imperium_self.endTurn();
              }, 1);
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
          });
        }
      },
    });




    this.importStrategyCard("diplomacy", {
      name     			:       "Diplomacy",
      rank			:	2,
      img			:	"/strategy/DIPLOMACY.png",
      text			:	"Pick a sector other than New Byzantium. Other players activate it. Refresh two planets.<hr />Other players may spend a strategy token to refresh two planets." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

          imperium_self.updateStatus('Select sector to quagmire in diplomatic negotiations, and refresh any planets in that system: ');
          imperium_self.playerSelectSector(function(sector) {

	      if (sector.indexOf("_") > -1) { sector = imperium_self.game.board[sector].tile; }

              imperium_self.addMove("resolve\tstrategy");
              imperium_self.addMove("strategy\t"+"diplomacy"+"\t"+strategy_card_player+"\t2");
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player)+" uses Diplomacy to activate "+imperium_self.game.sectors[sector].name);

              for (let i = 0; i < imperium_self.game.players_info.length; i++) {
                imperium_self.addMove("activate\t"+(i+1)+"\t"+sector);
              }

              //
              // re-activate any planets in that system
              //
              let sys = imperium_self.returnSectorAndPlanets(sector);
	      if (sys.p) {
                for (let i = 0; i < sys.p.length; i++) {
                  if (sys.p[i].owner == imperium_self.game.player) {
		    for (let p in imperium_self.game.planets) {
		      if (sys.p[i] == imperium_self.game.planets[p]) {
                        imperium_self.addMove("unexhaust\t"+imperium_self.game.player+"\t"+"planet"+"\t"+p);
		      }
		    }
                  }
                }
	      }
              imperium_self.saveSystemAndPlanets(sys);
              imperium_self.endTurn();


          });
        }
	return 0;

      },

      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player != strategy_card_player && imperium_self.game.player == player) {

          let html = '<p>Do you wish to spend 1 strategy token to unexhaust two planet cards? </p><ul>';
	  if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has just played the Diplomacy strategy card. This lets you to spend 1 strategy token to unexhaust two planet cards. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
          }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) {
	    html += '<li class="option" id="yes">Yes</li>';
	  }
          html += '<li class="option" id="no">No</li>';
          html += '</ul>';
          imperium_self.updateStatus(html);

          $('.option').off();
          $('.option').on('click', function() {

            let id = $(this).attr("id");

            if (id == "yes") {

              let array_of_cards = imperium_self.returnPlayerExhaustedPlanetCards(imperium_self.game.player); // unexhausted

              let choices_selected = 0;
              let max_choices = 0;

              let html  = "<p>Select planets to unexhaust: </p><ul>";
              let divname = ".cardchoice";
              for (let z = 0; z < array_of_cards.length; z++) {
                max_choices++;
                html += '<li class="cardchoice" id="cardchoice_'+array_of_cards[z]+'">' + imperium_self.returnPlanetCard(array_of_cards[z]) + '</li>';
              }
              if (max_choices == 0) {
                html += '<li class="textchoice" id="cancel">cancel (no options)</li>';
                divname = ".textchoice";
              }
              html += '</ul>';
              if (max_choices >= 2) { max_choices = 2; }

              imperium_self.updateStatus(html);
	      imperium_self.lockInterface();

              $(divname).off();
              $(divname).on('click', function() {

	        if (!imperium_self.mayUnlockInterface()) {
	          salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
	          return;
	        }
	        imperium_self.unlockInterface();

                let action2 = $(this).attr("id");

                if (action2 === "cancel") {
                  imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	          imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
                  imperium_self.endTurn();
                  return;
                }

                let tmpx = action2.split("_");
                let divid = "#"+action2;
                let y = tmpx[1];
                let idx = 0;
                for (let i = 0; i < array_of_cards.length; i++) {
                  if (array_of_cards[i] === y) {
                    idx = i;
                  }
                }

                choices_selected++;
                imperium_self.addMove("unexhaust\t"+imperium_self.game.player+"\tplanet\t"+array_of_cards[idx]);

                $(divid).off();
                $(divid).css('opacity','0.2');

                if (choices_selected >= max_choices) {
                  imperium_self.prependMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	          imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
                  imperium_self.endTurn();
                }

              });
            }

            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }

          });

        }

      },
    });



    this.importStrategyCard("imperial", {
      name     			:       "Imperial",
      rank			:	8,
      img			:	"/strategy/EMPIRE.png",
      text			:	"You may score a public objective. If you control New Byzantium gain 1 VP. Otherwise gain a secret objective.<hr />All players score objectives in Initiative Order" ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

	  let supplementary_scoring = function() {
  	    imperium_self.playerAcknowledgeNotice("You will first be asked to score your public objective. The game will then allow other players to purchase secret objectives.", function() {
              imperium_self.addMove("resolve\tstrategy");
              imperium_self.playerScoreVictoryPoints(imperium_self, function(imperium_self, vp, objective) {

                if (vp > 0 && (imperium_self.stage_i_objectives[objective] != undefined || imperium_self.stage_ii_objectives[objective] != undefined)) {

                  if (imperium_self.stage_i_objectives[objective] != undefined) {
                    imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.endTurn();
		    });
		  } else {
                    imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.endTurn();
		    });
		  }
		} else {
                  imperium_self.addMove("score\t"+imperium_self.game.player+"\t"+"1"+"\t"+"new-byzantium");
		  imperium_self.updateStatus("scoring completed");
                  imperium_self.endTurn();
		}
              }, 1);
            });
	  };




	  let supplementary_secret = function() {
  	    imperium_self.playerAcknowledgeNotice("You will next be asked to score a public objective. The game will then allow other players to purchase secret objectives.", function() {
              imperium_self.addMove("resolve\tstrategy");
              imperium_self.playerScoreVictoryPoints(imperium_self, function(imperium_self, vp, objective) {

                if (vp > 0 && (imperium_self.stage_i_objectives[objective] != undefined || imperium_self.stage_ii_objectives[objective] != undefined)) {

                  if (imperium_self.stage_i_objectives[objective] != undefined) {
                    imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.addMove("gain\t"+strategy_card_player+"\t"+"secret_objective"+"\t"+"1");
                      for (let i = 0; i < imperium_self.game.players_info.length; i++) { imperium_self.addMove("DEAL\t6\t"+(i+1)+"\t1"); }
                      imperium_self.endTurn();
		    });
		  } else {
                    imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.addMove("gain\t"+strategy_card_player+"\t"+"secret_objective"+"\t"+"1");
                      for (let i = 0; i < imperium_self.game.players_info.length; i++) { imperium_self.addMove("DEAL\t6\t"+(i+1)+"\t1"); }
                      imperium_self.endTurn();
		    });
		  }
		} else {
                  imperium_self.addMove("gain\t"+strategy_card_player+"\t"+"secret_objective"+"\t"+"1");
                  for (let i = 0; i < imperium_self.game.players_info.length; i++) { imperium_self.addMove("DEAL\t6\t"+(i+1)+"\t1"); }
                  imperium_self.endTurn();
		}
              }, 1);
            });
	  };

	  if (imperium_self.game.planets['new-byzantium'].owner == strategy_card_player) {
	    imperium_self.playerAcknowledgeNotice("You are granted an additional Victory Point for controlling New Byzantium during Imperial Scoring", supplementary_scoring);
	  } else {
	    imperium_self.playerAcknowledgeNotice("As you do not control New Byzantium during Imperial Scoring, you will be issued an additional Secret Objective", supplementary_secret);
	  }
        }

	return 0;
      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        imperium_self.game.state.playing_strategy_card_secondary = 1;

        if (imperium_self.game.player == player) {
          if (imperium_self.game.player != strategy_card_player && imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            imperium_self.playerBuySecretObjective(2);
          } else {
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
            imperium_self.endTurn();
          }
        }

  	return 0;
      },
      strategyTertiaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        imperium_self.game.state.playing_strategy_card_secondary = 1;
        imperium_self.game.state.round_scoring = 1;

	if (player == imperium_self.game.player) {

	  let my_secret_objective = "";
	  let my_secret_vp = "";

          imperium_self.game.state.round_scoring = 2;

          imperium_self.playerScoreSecretObjective(imperium_self, function(x, vp, objective) {

	    my_secret_vp = vp;
	    my_secret_objective = objective;

            imperium_self.playerScoreVictoryPoints(imperium_self, function(x, vp, objective) {

	      imperium_self.updateStatus("scoring completed");
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);

              if (my_secret_vp > 0) { 
		
                if (imperium_self.secret_objectives[my_secret_objective] != undefined) {
                  imperium_self.secret_objectives[my_secret_objective].scoreObjective(imperium_self, player, function() {

		    imperium_self.addMove("score\t"+player+"\t"+my_secret_vp+"\t"+my_secret_objective); 

              	    if (vp > 0) {

        	      if (imperium_self.stage_i_objectives[objective] != undefined) {
        		imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
			  imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	    		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(my_secret_objective);
	      		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
			  imperium_self.endTurn();
			});
        	      }
        	      if (imperium_self.stage_ii_objectives[objective] != undefined) {
        		imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
			  imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	    		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(my_secret_objective);
	      		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
			  imperium_self.endTurn();
			});
        	      } 

		    } else {

	    	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(my_secret_objective);
		      imperium_self.endTurn();

		    }
		  });
                }
		return 0;
	      }

              if (vp > 0) {
        	if (imperium_self.stage_i_objectives[objective] != undefined) {
        	  imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
		    imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	            imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
		    imperium_self.endTurn();
		  });
        	}
        	if (imperium_self.stage_ii_objectives[objective] != undefined) {
        	  imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
		    imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	            imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
		    imperium_self.endTurn();
		  });
        	}
	      } else {

	        imperium_self.endTurn();

	      }
            }, 2);

          });
  	  return 0;
        }
      }
    });




    this.importStrategyCard("leadership", {
      name     			:       "Leadership",
      rank			:	1,
      img			:	"/strategy/INITIATIVE.png",
      text			:	"You may gain and distribute three tokens.<hr />All players may purchase extra tokens at three influence per token." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

	if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {
          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("strategy\t"+"leadership"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
          imperium_self.playerAllocateNewTokens(imperium_self.game.player, 3, 0, 1, 1);
 	}

	return 0;

      },

      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (player == imperium_self.game.player) {
	  if (strategy_card_player != imperium_self.game.player) {
            imperium_self.playerBuyTokens(2);
	    return 0;
 	  } else {
            imperium_self.playerBuyTokens(2);
	    return 0;
	  }
        }

	return 1;

      },

    });




    this.importStrategyCard("politics", {
      name     			:       "Politics",
      rank			:	3,
      img			:	"/strategy/POLITICS.png",
      text			:	"Pick a new Speaker. Gain 2 action cards. Vote on two agendas if New Byzantium is controlled.<hr />Other players may spend a strategy token to purchase two action cards.",
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        //
        // card player goes for primary
        //
        if (imperium_self.game.player === strategy_card_player && player == strategy_card_player) {

          //
          // two action cards
          //
          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("gain\t"+imperium_self.game.player+"\taction_cards"+"\t"+2);
          imperium_self.addMove("DEAL\t2\t"+imperium_self.game.player+"\t2");
          imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " gains action cards");
          imperium_self.addMove("strategy\t"+"politics"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);

          //
          // pick the speaker
          //
          let factions = imperium_self.returnFactions();
          let html = 'Make which player the speaker? <ul>';
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            html += '<li class="option" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
          }
          html += '</ul>';
          imperium_self.updateStatus(html);

          let chancellor = imperium_self.game.player;
          let selected_agendas = [];

          $('.option').off();
          $('.option').on('click', function() {

            let chancellor = (parseInt($(this).attr("id")) + 1);
            let laws = imperium_self.returnAgendaCards();
            let laws_selected = 0;

	    //
	    // if New Byzantium is unoccupied, we skip the voting stage
	    //
	    imperium_self.playerAcknowledgeNotice("You will receive two action cards once other players have decided whether to purchase action cards.", function() {
              imperium_self.addMove("change_speaker\t"+chancellor);
	      imperium_self.endTurn();
	    });
	    return 0;

          });
        }
      },

      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == player) {
          if (imperium_self.game.player != strategy_card_player && imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            imperium_self.playerBuyActionCards(2);
          } else {
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
            imperium_self.endTurn();
          }
        }
      },

      strategyTertiaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        let selected_agendas = [];
        let laws = imperium_self.returnAgendaCards();
        let laws_selected = 0;

        if (imperium_self.game.player == player) {

          //
          // refresh votes --> total available
          //
          imperium_self.game.state.votes_available = [];
          imperium_self.game.state.votes_cast = [];
          imperium_self.game.state.how_voted_on_agenda = [];
          imperium_self.game.state.voted_on_agenda = [];
          imperium_self.game.state.voting_on_agenda = 0;

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            imperium_self.game.state.votes_available.push(imperium_self.returnAvailableVotes(i+1));
            imperium_self.game.state.votes_cast.push(0);
            imperium_self.game.state.how_voted_on_agenda[i] = "abstain";
            imperium_self.game.state.voted_on_agenda[i] = [];
            //
            // add extra 0s to ensure flexibility if extra agendas added
            //
            for (let z = 0; z < imperium_self.game.state.agendas_per_round+2; z++) {
              imperium_self.game.state.voted_on_agenda[i].push(0);
            }
          }
        }


        if (imperium_self.game.player === imperium_self.game.state.speaker) {

            let html = '';
            if (imperium_self.game.state.agendas_per_round == 1) {
              html += 'Select one agenda to advance for consideration in the Galactic Senate.<ul>';
            }
            if (imperium_self.game.state.agendas_per_round == 2) {
              html += 'Select two agendas to advance for consideration in the Galactic Senate.<ul>';
            }
            if (imperium_self.game.state.agendas_per_round == 3) {
              html += 'Select three agendas to advance for consideration in the Galactic Senate.<ul>';
            }

            for (i = 0; i < 3 && i < imperium_self.game.state.agendas.length; i++) {
              html += '<li class="option" id="'+imperium_self.game.state.agendas[i]+'">' + laws[imperium_self.game.state.agendas[i]].name + '</li>';
            }
            html += '</ul>';

            imperium_self.updateStatus(html);

            $('.option').off();
            $('.option').on('mouseenter', function() { let s = $(this).attr("id"); imperium_self.showAgendaCard(s); });
            $('.option').on('mouseleave', function() { let s = $(this).attr("id"); imperium_self.hideAgendaCard(s); });
            $('.option').on('click', function() {

              laws_selected++;
              selected_agendas.push($(this).attr('id'));

              $(this).hide();
              imperium_self.hideAgendaCard(selected_agendas[selected_agendas.length-1]);

              if (laws_selected >= imperium_self.game.state.agendas_per_round) {
                for (i = 1; i >= 0; i--) {
                  imperium_self.addMove("resolve_agenda\t"+selected_agendas[i]);
                  imperium_self.addMove("post_agenda_stage_post\t"+selected_agendas[i]);
                  imperium_self.addMove("post_agenda_stage\t"+selected_agendas[i]);
                  imperium_self.addMove("agenda\t"+selected_agendas[i]+"\t"+i);
                  imperium_self.addMove("pre_agenda_stage_post\t"+selected_agendas[i]);
                  imperium_self.addMove("pre_agenda_stage\t"+selected_agendas[i]);
                  imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
                }
                imperium_self.endTurn();
              }
            });
        } else {

	  imperium_self.updateStatus("The Speaker is selecting two Agendas for consideration by the Senate");

	}
      },

    });




    this.importStrategyCard("technology", {
      name     			:       "Technology",
      rank			:	7,
      img			:	"/strategy/TECH.png",
      text			:	"Research a technology. You may spend 6 resources to research another.<hr />Other players may spend a strategy token and 4 resources to research a technology" ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {
        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {
          imperium_self.playerAcknowledgeNotice("You will first have the option of researching a free-technology, and then invited to purchase an additional tech for 6 resources:", function() {
            imperium_self.playerResearchTechnology(function(tech) {
	      imperium_self.game.players_info[imperium_self.game.player-1].tech.push(tech);
              imperium_self.addMove("resolve\tstrategy");
              imperium_self.addMove("strategy\t"+"technology"+"\t"+strategy_card_player+"\t2");
              imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
              imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
              imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);
              imperium_self.endTurn();
            });
          });
        }
      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

console.log("in secondary!");

	let html = "";
	let resources_to_spend = 0;

        if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) {
 
	  resources_to_spend = imperium_self.game.players_info[imperium_self.game.player-1].cost_of_technology_secondary;
;
          html = '<p>Technology has been played. Do you wish to spend 4 resources and a strategy token to research a technology? </p><ul>';
          if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Technology strategy card. You may spend 4 resources and a strategy token to gain a permanent new unit or ability. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability?</p><ul>`;
          }

	  if (
	    imperium_self.game.players_info[player-1].permanent_research_technology_card_must_not_spend_resources == 1 ||
	    imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 1
	  ) { 
            html = '<p>Technology has been played. Do you wish to spend a strategy token to research a technology? </p><ul>';
	    resources_to_spend = 0;
	  }

	  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
	  if (available_resources >= 4 && imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            html += '<li class="option" id="yes">Yes</li>';
          }
	  html += '<li class="option" id="no">No</li>';
          html += '</ul>';
 
          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {
 
            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();

            let id = $(this).attr("id");

            if (id === "yes") {

	      imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources = 0;
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.playerSelectResources(resources_to_spend, function(success) {
                if (success == 1) {
                  imperium_self.playerResearchTechnology(function(tech) {
                    imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);
                    imperium_self.addMove("expend\t"+imperium_self.game.player+"\tstrategy\t1");
                    imperium_self.endTurn();
                  });
                } else {
                  imperium_self.endTurn();
                }
              });
            }
            if (id === "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
          });

	  return 0;

        } else {

          if (imperium_self.game.player != strategy_card_player) { return 0; }

	  resources_to_spend = imperium_self.game.players_info[imperium_self.game.player-1].cost_of_technology_primary;

          html = '<p>Do you wish to spend '+resources_to_spend+' resources to research an additional technology? </p><ul>';

	  if (
	    imperium_self.game.players_info[player-1].permanent_research_technology_card_must_not_spend_resources == 1 ||
	    imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 1
	  ) { 
            html = '<p>Do you wish to research an additional technology? </p><ul>';
	    resources_to_spend = 0;
	  }

	  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
	  if (available_resources >= resources_to_spend) {
            html += '<li class="option" id="yes">Yes</li>';
	  }
          html += '<li class="option" id="no">No</li>';
          html += '</ul>';

          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {

            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();


            let id = $(this).attr("id");

            if (id == "yes") {
	      imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 0;
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.playerSelectResources(resources_to_spend, function(success) {
                if (success == 1) {
                  imperium_self.playerResearchTechnology(function(tech) {
                    imperium_self.addMove("purchase\t"+imperium_self.game.player+"\ttechnology\t"+tech);
                    imperium_self.endTurn();
                  });
                } else {
                }
              });
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
          });

	  return 0;

        }
      },
    });









    this.importAgendaCard('minister-of-technology', {
        name : "Minister of Technology" ,
        type : "Law" ,
        text : "Elect a player. They do not need to spend resources to research technology when the technology card is played" ,
	initialize : function(imperium_self) {
	  imperium_self.game.state.minster_of_technology = null;
	  imperium_self.game.state.minster_of_technology_player = null;
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_research_technology_card_must_not_spend_resources = 0;
	    imperium_self.game.players_info[i].permanent_research_technology_card_must_not_spend_resources = 0;
	  }
	},
        returnAgendaOptions : function(imperium_self) {
          let options = [];
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            options.push(imperium_self.returnFaction(i+1));
          }
          return options;
        },
        onPass : function(imperium_self, winning_choice) {
	  let player_number = 0;
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (imperium_self.returnFaction(i+1) == winning_choice) { player_number = i; }
	  }
          imperium_self.game.state.minister_of_technology = 1;
          imperium_self.game.state.minister_of_technology_player = player_number+1;
          imperium_self.game.players_info[player_number].permanent_research_technology_card_must_not_spend_resources = 1;

	  imperium_self.game.state.laws.push({ agenda : "minister-of-technology" , option : winning_choice });

        }
  });





    this.importActionCard('unexpected-breakthrough', {
        name : "Unexpected Breakthrough" ,
        type : "action" ,
        text : "Do not spend resources to research technology the next time the Technology card is played" ,
        playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_research_technology_card_must_not_spend_resources = 1;
          return 1;
        }
    });






    this.importStrategyCard("trade", {
      name     			:       "Trade",
      rank			:	5,
      img			:	"/strategy/TRADE.png",
      text			:	"Gain 3 trade goods. Refresh your commodities and those of any other players.<hr />Unrefreshed players may spend a strategy token to refresh their commodities." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("strategy\t"+"trade"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
          imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t3");
          imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tcommodities\t"+imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit);
 
          let factions = imperium_self.returnFactions();
          let html = '<p>You will receive 3 trade goods and '+imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit+' commodities. You may choose to replenish the commodities of any other players: </p><ul>';
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            if (i != imperium_self.game.player-1) {
              html += '<li class="option" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
            }
          }
          html += '<li class="option" id="finish">done</li>';
 
          imperium_self.updateStatus(html);
 
          $('.option').off();
          $('.option').on('click', function() {
            let id = $(this).attr("id");
            if (id != "finish") {
              imperium_self.addMove("purchase\t"+(parseInt(id)+1)+"\tcommodities\t"+imperium_self.game.players_info[id].commodity_limit);
              $(this).hide();
            } else {
              imperium_self.endTurn();
            }
          });

        }

      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) {

	  if (imperium_self.game.players_info[player-1].commodities == imperium_self.game.players_info[player-1].commodity_limit) { 
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	    imperium_self.updateLog(imperium_self.returnFaction(player) + " skips the Trade secondary as they have already refreshed commodities");
            imperium_self.endTurn();
	    return 1;
	  }

          let html = '<p>Trade has been played. Do you wish to spend 1 strategy token to refresh your commodities? </p><ul>';
          if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Trade strategy card. You may spend 1 strategy token to refresh your faction commodities, which may be exchanged with your neighbours on the board for trade goods. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
          }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            html += '<li class="option" id="yes">Yes</li>';
          }
          html += '<li class="option" id="no">No</li>';
	  html += '</ul>';


	  if (imperium_self.game.players_info[imperium_self.game.player-1].commodities == imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit) {
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
	    imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " already has commodities and skips trade secondary");
	    imperium_self.endTurn();
	    return 0;
	  }


          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {
 
            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();

            $('.option').off();
            let id = $(this).attr("id");

            if (id == "yes") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tcommodities\t"+imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tstrategy\t1");
	      imperium_self.endTurn();
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
 
          });
        }
      },
    });


    this.importStrategyCard("warfare", {
      name     			:       "Warfare",
      rank			:	6,
      img			:	"/strategy/MILITARY.png",
      text			:	"De-activate a sector. Gain and distribute 1 free token.<hr />Other players may spend a strategy token to producein their home system" ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

          imperium_self.updateStatus('Select sector to de-activate.');
          imperium_self.playerSelectSector(function(sector) {

	    let sys = imperium_self.returnSectorAndPlanets(sector);

            imperium_self.addMove("resolve\tstrategy");
            imperium_self.addMove("strategy\t"+"warfare"+"\t"+strategy_card_player+"\t2");
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
            imperium_self.addMove("deactivate\t"+strategy_card_player+"\t"+sector);
            imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(strategy_card_player)+" deactivates "+sys.s.name);
            imperium_self.playerAllocateNewTokens(imperium_self.game.player, 1, 0, 3, 0);
          });
    
        }

      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) { 

          let html = '<p>Do you wish to spend 1 strategy token to produce in your home sector? </p><ul>';
          if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Warfare strategy card. You may spend 1 strategy token to produce in your Homeworld without activating the sector. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
          }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0 ) { 
            html += '<li class="option" id="yes">Yes</li>';
	  }
          html += '<li class="option" id="no">No</li>';
          html += '</ul>';
 
          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {

            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();

            let id = $(this).attr("id");
 
            if (id == "yes") {
              imperium_self.playerProduceUnits(imperium_self.game.players_info[imperium_self.game.player-1].homeworld, 0, 0, 2, 1); // final is warfare card
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
 
          });
        }
      },
    });


  this.importSecretObjective('military-catastrophe', {
      name 		: 	"Military Catastrophe" ,
      text		:	"Destroy the flagship of another player" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_military_catastrophe = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
        if (imperium_self.game.players_info[imperium_self.game.player-1].units_i_destroyed_this_combat_round.includes("flagship")) {
	  imperium_self.game.state.secret_objective_military_catastrophe = 1;
	}
        return 0; 
      },
      groundCombatRoundEnd :	function(imperium_self, attacker, defender, sector, planet_idx) {
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_military_catastrophe == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('flagship-dominance', {
      name 		: 	"Blood Christening" ,
      text		:	"Achieve victory in a space combat in a system containing your flagship. Your flagship must survive this combat" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_flagship_dominance = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
	if (imperium_self.doesSectorContainPlayerUnit(imperium_self.game.player, sector, "flagship")) { 
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  if (sys.s.units[defender-1].length == 0) {
	    if (attacker == imperium_self.game.player && sys.s.units[attacker-1].length > 0) {
	      imperium_self.game.state.secret_objective_flagship_dominance = 1;
	    }
	  }
	  if (sys.s.units[attacker-1].length == 0) {
	    if (defender == imperium_self.game.player && sys.s.units[defender-1].length > 0) {
	      imperium_self.game.state.secret_objective_flagship_dominance = 1;
	    }
	  }
	}
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_flagship_dominance == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });



  this.importSecretObjective('nuke-them-from-orbit', {
      name 		: 	"Nuke them from Orbit" ,
      text		:	"Destroy the last of a player's ground forces using bombardment" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_nuke_from_orbit = 0;
	imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = 0;
        return 0; 
      },
      bombardmentTriggers :	function(imperium_self, player, bombarding_player, sector, planet_idx) {
	imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = 0;
	let sys = imperium_self.returnSectorAndPlanets(sector);
	let planet = sys.p[planet_idx];
	let infantry_on_planet = imperium_self.returnInfantryOnPlanet(planet);
	for (let i = 0; i < planet.units.length; i++) {
	  if (planet.units[i].length > 0) {
	    if ((i+1) != bombarding_player) {
	      defender = i+1;
	      imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = infantry_on_planet;
	    }
	  }
	}
	return 0;
      },
      planetaryDefenseTriggers :  function(imperium_self, player, sector, planet_idx) {
	if (imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked > 0) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
console.log("PIDX: " + planet_idx);
	  let planet = sys.p[planet_idx];
console.log("PLANET: " + JSON.stringify(planet));
	  let infantry_on_planet = imperium_self.returnInfantryOnPlanet(planet);
	  if (infantry_on_planet == 0) {
	    imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = 1;
	  }
	}
	return 0;
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_nuke_from_orbit == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('anti-imperialism', {
      name 		: 	"Anti-Imperialism" ,
      text		:	"Achieve victory in combat with a player with the most VP" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_anti_imperialism = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
        imperium_self.game.state.secret_objective_anti_imperialism = 0;
	let sys = imperium_self.returnSectorAndPlanets(sector);
	let players_with_most_vp = imperium_self.returnPlayersWithHighestVP();

	if (imperium_self.game.player == attacker && sys.s.units[attacker-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(attacker, sector) == 0) {
	    if (players_with_most_vp.includes(defender)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; } 
	  }
	}
	if (imperium_self.game.player == defender && sys.s.units[defender-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(defender, sector) == 0) {
	    if (players_with_most_vp.includes(attacker)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; }
	  }
	}
        return 0; 
      },
      groundCombatRoundEnd :	function(imperium_self, attacker, defender, sector, planet_idx) {
        let sys = imperium_self.returnSectorAndPlanets(sector);
        let planet = sys.p[planet_idx];
	let players_with_most_vp = imperium_self.returnPlayersWithHighestVP();

	if (imperium_self.game.player == attacker && planet.units[attacker-1].length > 0) {
	  if (planet.units[defender-1].length == 0) {
	    if (players_with_most_vp.includes(defender)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; } 
	  }
	}
	if (imperium_self.game.player == defender && planet.units[defender-1].length > 0) {
	  if (planet.units[attacker-1].length == 0) {
	    if (players_with_most_vp.includes(attacker)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; }
	  }
	}
	return 0;
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_anti_imperialism == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('end-their-suffering', {
      name 		: 	"End Their Suffering" ,
      text		:	"Eliminate a player with the lowest VP from the board in Space or Ground Combat" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_end_their_suffering = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);
	let players_with_lowest_vp = imperium_self.returnPlayersWithLowestVP();

	if (imperium_self.game.player == attacker) {
	  if (sys.s.units[defender-1].length == 0) {
	    if (players_with_lowest_vp.includes(defender)) { 
	      // does the player have any units left?
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[defender-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[defender-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
	if (imperium_self.game.player == defender) {
	  if (sys.s.units[attacker-1].length == 0) {
	    if (players_with_lowest_vp.includes(attacker)) { 
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[attacker-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[attacker-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
        return 0; 
      },
      groundCombatRoundEnd :	function(imperium_self, attacker, defender, sector, planet_idx) {
        let sys = imperium_self.returnSectorAndPlanets(sector);
        let planet = sys.p[planet_idx];
	let players_with_lowest_vp = imperium_self.returnPlayersWithLowestVP();

	if (imperium_self.game.player == attacker) {
	  if (planet.units[defender-1].length == 0) {
	    if (players_with_lowest_vp.includes(defender)) { 
	      // does the player have any units left?
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[defender-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[defender-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
	if (imperium_self.game.player == defender) {
	  if (planet.units[attacker-1].length == 0) {
	    if (players_with_lowest_vp.includes(attacker)) { 
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[attacker-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[attacker-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_end_their_suffering == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });




  this.importSecretObjective('establish-a-blockade', {
      name 		: 	"Establish a Blockade" ,
      text		:	"Have at least 1 ship in the same sector as an opponent's spacedock",
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	for (let i in imperium_self.game.sectors) {
	  if (imperium_self.game.sectors[i].units[player-1].length > 0) {
	    let sys = imperium_self.returnSectorAndPlanets(i);
	    for (let p = 0; p < sys.p.length; p++) {
	      for (let b = 0; b < sys.p[p].units.length; b++) {
	 	if ((b+1) != player) {
	          for (let bb = 0; bb < sys.p[p].units[b].length; bb++) {
		    if (sys.p[p].units[b][bb].type === "spacedock") { return 1; }
		  }
		}
	      }
	    }
	  }
	}
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });

  this.importSecretObjective('close-the-trap', {
      name 		: 	"Close the Trap" ,
      text		:	"Destroy another player's last ship in a system using a PDS" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_close_the_trap = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);
	if (imperium_self.game.player == attacker && sys.s.units[attacker-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(attacker, sector) == 0) {
	    imperium_self.game.state.secret_objective_close_the_trap = 1;
	  }
	}
	if (imperium_self.game.player == defender && sys.s.units[defender-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(defender, sector) == 0) {
	    imperium_self.game.state.secret_objective_close_the_trap = 1;
	  }
	}

        if (imperium_self.game.players_info[imperium_self.game.player-1].units_i_destroyed_this_combat_round.includes("flagship")) {
	  imperium_self.game.state.secret_objective_military_catastrophe = 1;
	}
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_close_the_trap == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('galactic-observer', {
      name 		: 	"Galactic Observer" ,
      text		:	"Have at least 1 ship in 6 different sectors" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let ships_in_systems = 0;
	for (let i in imperium_self.game.board) {
	  let sector = imperium_self.game.board[i].tile;
	  if (imperium_self.doesSectorContainPlayerShip(player, sector)) {
	    ships_in_systems++;
	  }
	}

	if (ships_in_systems > 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });



  this.importSecretObjective('master-of-the-ion-cannon', {
      name 		: 	"Master Cannoneer" ,
      text		:	"Have at least 4 PDS units in play" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let pds_units_in_play = 0;

	for (let i in imperium_self.game.planets) {
	  let planet = imperium_self.game.planets[i];
	  for (let ii = 0; ii < planet.units[player-1].length; ii++) {
	    if (planet.units[player-1][ii].type == "pds") {
	      pds_units_in_play++;
	    }
	  }
	}

	if (pds_units_in_play > 3) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('war-engine', {
      name 		: 	"War Engine" ,
      text		:	"Have three spacedocks in play" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let docks_in_play = 0;

	for (let i in imperium_self.game.planets) {
	  let planet = imperium_self.game.planets[i];
	  for (let ii = 0; ii < planet.units[player-1].length; ii++) {
	    if (planet.units[player-1][ii].type == "spacedock") {
	      docks_in_play++;
	    }
	  }
	}

	if (docks_in_play > 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });

  this.importSecretObjective('wormhole-administrator', {
      name 		: 	"Wormhole Administrator" ,
      text		:	"Have at least 1 ship in systems containing alpha and beta wormholes respectively" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let relevant_sectors = imperium_self.returnSectorsWithPlayerShips(player);
	let alpha = 0;
	let beta = 0;
	for (let i = 0; i < relevant_sectors.length; i++) {
	  if (imperium_self.game.sectors[relevant_sectors[i]].wormhole == 1) { alpha = 1; }
	  if (imperium_self.game.sectors[relevant_sectors[i]].wormhole == 2) { beta = 1; }
	}
	if (alpha == 1 && beta == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('fleet-of-terror', {
      name 		: 	"Fleet of Terror" ,
      text		:	"Have five dreadnaughts in play" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let dreadnaughts = 0;
	let relevant_sectors = imperium_self.returnSectorsWithPlayerShips(player);
	for (let i = 0; i < relevant_sectors.length; i++) {
	  for (let ii = 0; ii < imperium_self.game.sectors[relevant_sectors[i]].units[player-1].length; ii++) {
	    if (imperium_self.game.sectors[relevant_sectors[i]].units[player-1][ii].type === "dreadnaught") {
	      dreadnaughts++;
	    }
	  }
	}
	if (dreadnaughts >= 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('cultural-diplomacy', {
      name 		: 	"Cultural Diplomacy" ,
      text		:	"Control at least 4 cultural planets" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let cultural = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();
        for (let i = 0; i < planetcards.length; i++) { if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; } }
        if (cultural >= 4) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('act-of-espionage', {
      name 		: 	"Act of Espionage" ,
      text		:	"Discard five action cards from your hard" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.returnPlayerActionCards(player).length >= 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	if (imperium_self.game.player == player) {
	  imperium_self.playerDiscardActionCards(5, function() {
	    mycallback(1);
	  });
	} else {
	  mycallback(0);
	}
      }
  });


  this.importSecretObjective('space-to-breathe', {
      name 		: 	"Space to Breathe" ,
      text		:	"Have at least 1 ship in 3 systems with no planets" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let relevant_sectors = imperium_self.returnSectorsWithPlayerShips(player);
	let sectors_without_planets = 0;
	for (let i = 0; i < relevant_sectors.length; i++) {
	  if (imperium_self.game.sectors[relevant_sectors[i]].planets.length == 0) { sectors_without_planets++; }
	}
	if (sectors_without_planets >= 3) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('ascendant-technocracy', {
      name 		: 	"Ascendant Technocracy" ,
      text		:	"Research 4 tech upgrades on the same color path" , 
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {

        let techlist = imperium_self.game.players_info[player-1].tech;

        let greentech = 0;
        let bluetech = 0;
        let redtech = 0;
        let yellowtech = 0;

        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].color == "blue") { bluetech++; }
          if (imperium_self.tech[techlist[i]].color == "red") { redtech++; }
          if (imperium_self.tech[techlist[i]].color == "yellow") { yellowtech++; }
          if (imperium_self.tech[techlist[i]].color == "green") { greentech++; }
        }

        if (bluetech >= 4) { return 1; }
        if (yellowtech >= 4) { return 1; }
        if (redtech >= 4) { return 1; }
        if (greentech >= 4) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        mycallback(1);
      },
  });



  this.importSecretObjective('penal-colonies', {
      name 		: 	"Penal Colonies" ,
      text		:	"Control four planets with hazardous conditions" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let hazardous = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();
        for (let i = 0; i < planetcards.length; i++) { if (imperium_self.game.planets[planetcards[i]].type === "hazardous")   { hazardous++; } }
        if (hazardous >= 4) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('master-of-production', {
      name 		: 	"Master of Production" ,
      text		:	"Control four planets with industrial civilizations" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let industrial = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();
        for (let i = 0; i < planetcards.length; i++) { if (imperium_self.game.planets[planetcards[i]].type === "industrial")   { industrial++; } }
        if (industrial >= 4) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('faction-technologies', {
      name 		: 	"Faction Technologies" ,
      text		:	"Research 2 faction technologies" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let techlist = imperium_self.game.players_info[player-1].tech;
        let factiontech = 0;
        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].type == "normal" && techlist[i].indexOf("faction") == 0) { factiontech++; }
        }
        if (factiontech >= 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('occupy-new-byzantium', {
      name 		: 	"Occupy New Byzantium" ,
      text		:	"Control New Byzantium and have at least 3 ships protecting the sector" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.planets['new-byzantium'].owner == player) {
	  if (imperium_self.game.sectors['new-byzantium'].units[player-1].length >= 3) { return 1; }
	}
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('cast-a-long-shadow', {
      name 		: 	"Cast a Long Shadow" ,
      text		:	"Have at least 1 ship in a system adjacent to an opponent homeworld" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {

 	// 1_1, 4_7, etc.
	let homeworlds = imperium_self.returnHomeworldSectors(imperium_self.game.players_info.length);
	let sectors = [];

	for (let i = 0; i < homeworlds.length; i++) {
	  if (imperium_self.game.board[homeworlds[i]].tile != imperium_self.game.board[imperium_self.game.players_info[player-1].homeworld].tile) {
	    sectors.push(imperium_self.game.board[homeworlds[i]].tile);
	  }
	}

	for (let i = 0; i < sectors.length; i++) {
	  if (imperium_self.isPlayerAdjacentToSector(player, sectors[i])) { return 1; }
	}
       
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });






/***
  this.importStageIPublicObjective('manage-to-breathe', {
      name 	: 	"Deep Breathing" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Just score this for free..." ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	return 1;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
***/

  this.importStageIPublicObjective('planetary-unity', {
      name 	: 	"Planetary Unity" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Control four planets of the same planet type" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

	let hazardous = 0;
	let cultural = 0;
	let industrial = 0;

	let planetcards = imperium_self.returnPlayerPlanetCards(player);

	for (let i = 0; i < planetcards.length; i++) {
	  let p = imperium_self.game.planets[planetcards[i]];
	  if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
	  if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
	  if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
	}

	if (hazardous >= 4 || cultural >= 4 || industrial >= 4) { return 1; }

	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('forge-of-war', {
      name 	: 	"Forge of War" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Research 2 unit upgrade technologies" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	let techlist = imperium_self.game.players_info[player-1].tech;
	let unit_upgrades = 0;
	for (let i = 0; i < techlist.length; i++) {
	  if (imperium_self.tech[techlist[i]].unit == 1) {
	    unit_upgrades++;
	  }
	}
	if (unit_upgrades >= 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('diversified-research', {
      name 	: 	"Diversified Research" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Research 2 technologies in two different color paths" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

	let techlist = imperium_self.game.players_info[player-1].tech;

	let greentech = 0;
	let bluetech = 0;
	let redtech = 0;
	let yellowtech = 0;

	for (let i = 0; i < techlist.length; i++) {
	  if (imperium_self.tech[techlist[i]].color == "blue") { bluetech++; }
	  if (imperium_self.tech[techlist[i]].color == "red") { redtech++; }
	  if (imperium_self.tech[techlist[i]].color == "yellow") { yellowtech++; }
	  if (imperium_self.tech[techlist[i]].color == "green") { greentech++; }
	}

	let achieve_two = 0;
	
	if (bluetech >= 2) { achieve_two++; }
	if (yellowtech >= 2) { achieve_two++; }
	if (redtech >= 2) { achieve_two++; }
	if (greentech >= 2) { achieve_two++; }

	if (achieve_two >= 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('mining-conglomerate', {
      name 	: 	"Mining Conglomerate" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend eight resources when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if (imperium_self.returnAvailableResources(player) >= 8) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectResources(8, function(success) {
	    mycallback(success);
          });
	} else {
	  mycallback(0);
	}
      },
  });
  this.importStageIPublicObjective('conquest-of-science', {
      name 	: 	"Conquest of Science" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Control 3 planets with tech specialities" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let techbonuses = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (planetcards[i].bonus == "red") { techbonuses++; }
          if (planetcards[i].bonus == "blue") { techbonuses++; }
          if (planetcards[i].bonus == "green") { techbonuses++; }
          if (planetcards[i].bonus == "yellow") { techbonuses++; }
        }

	if (techbonuses >= 3) { return 1; }

	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('colonization', {
      name 	: 	"Colonization" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Control six planets outside your home system" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let hazardous = 0;
        let cultural = 0;
        let industrial = 0;
        let diplomatic = 0;

        let planetcards = imperium_self.returnPlayerPlanetCards(player);

        for (let i = 0; i < planetcards.length; i++) {
          if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
          if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
          if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
          if (imperium_self.game.planets[planetcards[i]].type === "diplomatic") { diplomatic++; }
        }

        if ((cultural+hazardous+industrial+diplomatic) >= 6) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });


  this.importStageIPublicObjective('grand-gesture', {
      name 	: 	"A Grand Gesture" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend 3 command or strategy tokens when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if ((imperium_self.game.players_info[player-1].strategy_tokens + imperium_self.game.players_info[player-1].command_tokens) >= 3) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectStrategyAndCommandTokens(3, function(success) {
	    mycallback(success);
          });
	} else {
	  mycallback(0);
	}
      },
  });


  this.importStageIPublicObjective('establish-trade-outposts', {
      name 	: 	"Establish Trade Outposts" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend 5 trade goods when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if (imperium_self.returnAvailableTradeGoods(player) >= 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        imperium_self.game.players_info[player-1].goods -= 5;
	imperium_self.displayFactionDashboard();
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('pecuniary-diplomacy', {
      name 	: 	"Pecuniary Diplomacy" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend 8 influence when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if (imperium_self.returnAvailableInfluence(player) >= 8) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectInfluence(8, function(success) {
	    mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });




  this.importStageIIPublicObjective('master-of-commerce', {
      name 	: 	"Master of Commerce" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 10 trade goods when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if (imperium_self.returnAvailableTradeGoods(player) >= 10) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        imperium_self.game.players_info[player-1].goods -= 10;
	imperium_self.displayFactionDashboard();
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('display-of-dominance', {
      name 	: 	"Display of Dominance" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control at least 1 planet in another player's home sector" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

	let homeworlds = [];
	let homeplanets = [];
	for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	  let home_sector = imperium_self.game.board[imperium_self.game.players_info[player-1].homeworld].tile;
	  let sys = imperium_self.returnSectorAndPlanets(home_sector);
	  for (let ii = 0; ii < sys.p.length; ii++) {
	    homeplanets.push(sys.p[ii].name);
	  }
	}

        let planetcards = imperium_self.returnPlayerPlanetCards();

	for (let i = 0; i < planetcards.length; i++) {
	  if (homeplanets.includes(planetcards[i].name)) { return 1; }
	}

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('technological-empire', {
      name 	: 	"Technological Empire" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control 5 planets with tech bonuses" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let techbonuses = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (planetcards[i].bonus == "red") { techbonuses++; }
          if (planetcards[i].bonus == "blue") { techbonuses++; }
          if (planetcards[i].bonus == "green") { techbonuses++; }
          if (planetcards[i].bonus == "yellow") { techbonuses++; }
        }

        if (techbonuses >= 3) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('establish-galactic-currency', {
      name 	: 	"Establish Galactic Currency" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 16 resources when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if (imperium_self.returnAvailableResources(player) >= 16) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectResources(16, function(success) {
	    mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });
  this.importStageIIPublicObjective('master-of-science', {
      name 	: 	"Master of Science" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Own 2 tech upgrades in each of 4 tech color paths" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let techlist = imperium_self.game.players_info[player-1].tech;

        let greentech = 0;
        let bluetech = 0;
        let redtech = 0;
        let yellowtech = 0;

        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].color == "blue") { bluetech++; }
          if (imperium_self.tech[techlist[i]].color == "red") { redtech++; }
          if (imperium_self.tech[techlist[i]].color == "yellow") { yellowtech++; }
          if (imperium_self.tech[techlist[i]].color == "green") { greentech++; }
        }

        let achieve_two = 0;

        if (bluetech >= 2) { achieve_two++; }
        if (yellowtech >= 2) { achieve_two++; }
        if (redtech >= 2) { achieve_two++; }
        if (greentech >= 2) { achieve_two++; }

        if (achieve_two >= 4) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },

  });
  this.importStageIIPublicObjective('imperial-unity', {
      name 	: 	"Imperial Unity" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control 6 planets of the same planet type" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let hazardous = 0;
        let cultural = 0;
        let industrial = 0;
        let diplomatic = 0;

        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
          if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
          if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
          if (imperium_self.game.planets[planetcards[i]].type === "diplomatic")   { diplomatic++; }
        }

        if (hazardous >= 6 || cultural >= 6 || industrial >= 6 || diplomatic >= 6) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        mycallback(1);
      },
  });
  this.importStageIIPublicObjective('advanced-technologies', {
      name 	: 	"Advanced Technologies" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Research 3 unit upgrade technologies" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        let techlist = imperium_self.game.players_info[player-1].tech;
        let unit_upgrades = 0;
        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].unit == 1) {
            unit_upgrades++;
          }
        }
        if (unit_upgrades >= 3) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('colonial-dominance', {
      name 	: 	"Colonial Dominance" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control 11 planets outside your home system" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let hazardous = 0;
        let cultural = 0;
        let industrial = 0;
        let diplomatic = 0;

        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
          if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
          if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
          if (imperium_self.game.planets[planetcards[i]].type === "diplomatic")   { diplomatic++; }
        }

        if ((cultural+hazardous+industrial+diplomatic) >= 11) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('power-broker', {
      name 	: 	"Power Broker" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 16 influence when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if (imperium_self.returnAvailableInfluence(player) >= 16) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectInfluence(16, function(success) {
            mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });
  this.importStageIIPublicObjective('cultural-revolution', {
      name 	: 	"Cultural Revolution" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 6 command or strategy tokens when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if ((imperium_self.game.players_info[player-1].strategy_tokens + imperium_self.game.players_info[player-1].command_tokens) >= 6) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectStrategyAndCommandTokens(6, function(success) {
            mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });
  
  
  

  this.importAgendaCard('shard-of-the-throne', {
  	name : "Shard of the Throne" ,
  	type : "Law" ,
	elect : "player" ,
  	text : "Elect a Player to earn 1 VP. When this player loses a space combat to another player, they transfer the VP to that player" ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.shard_of_the_throne = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.shard_of_the_throne_player = i+1;
	    }
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "shard-of-the-throne";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

          imperium_self.game.players_info[imperium_self.game.state.shard_of_the_throne_player-1].vp += 1;
	  imperium_self.updateLeaderboard();
	  imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.shard_of_the_throne_player) + " gains the Shard of the Throne (1VP)");

	},
        repealAgenda(imperium_self) {

	  //
	  // remove from active play
	  //
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	    if (imperium_self.game.state.laws[i].agenda === "shard-of-the-throne") {
	      imperium_self.game.state.laws.splice(i, 1);
	      i--;
	    }  
	  }

	  //
	  // unset the player
	  //
	  imperium_self.game.state.shard_of_the_throne_player = -2;

	  return 1;

        },
        spaceCombatRoundEnd : function(imperium_self, attacker, defender, sector) {
	  if (defender == imperium_self.game.state.shard_of_the_throne_player) {
	    if (!imperium_self.doesPlayerHaveShipsInSector(defender, sector)) {
	      imperium_self.game.state.shard_of_the_throne_player = attacker;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.shard_of_the_throne_player) + " gains the Shard of the Throne (1VP)");
	      imperium_self.game.players_info[attacker-1].vp += 1;
	      imperium_self.game.players_info[defender-1].vp -= 1;
	      imperium_self.updateLeaderboard();
	    }
	  }
	},
	groundCombatRoundEnd : function(imperium_self, attacker, defender, sector, planet_idx) {
	  if (defender == imperium_self.game.state.shard_of_the_throne_player) {
	    if (!imperium_self.doesPlayerHaveInfantryOnPlanet(defender, sector, planet_idx)) {
	      imperium_self.game.state.shard_of_the_throne_player = attacker;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.shard_of_the_throne_player) + " gains the Shard of the Throne (1VP)");
	      imperium_self.game.players_info[attacker-1].vp += 1;
	      imperium_self.game.players_info[defender-1].vp -= 1;
	      imperium_self.updateLeaderboard();
	    }
	  }
	},
  });


  this.importAgendaCard('homeland-defense-act', {
  	name : "Homeland Defense Act" ,
  	type : "Law" ,
  	text : "FOR: there is no limit to the number of PDS units on a planet. AGAINST: each player must destroy one PDS unit" ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.homeland_defense_act = 1;
	  let law_to_push = {};
	      law_to_push.agenda = "homeland-defense-act";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

          if (winning_choice === "for") {
	    imperium_self.game.state.pds_limit_per_planet = 100;
	  }

          if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.doesPlayerHaveUnitOnBoard((i+1), "pds")) {
	        imperium_self.game.queue.push("destroy_a_pds\t"+(i+1));
	      }
	    }
	  }

	  imperium_self.game.state.laws.push({ agenda : "homeland-defense-act" , option : winning_choice });

	},
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "homeland-defense-act") {
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the player
          //
          imperium_self.game.state.homeland_defense_act = 0;
	  imperium_self.game.state.pds_limit_per_planet = 2; // limit back

          return 1;

        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "destroy_a_pds") {

            let player = parseInt(mv[1]);
	    imperium_self.game.queue.splice(qe, 1);

	    if (imperium_self.game.player == player) {
              imperium_self.playerSelectUnitWithFilter(
                    "Select a PDS unit to destroy: ",
                    function(unit) {
		      if (unit == undefined) { return 0; }
                      if (unit.type == "pds") { return 1; }
                      return 0;
            	    },
                    function(unit_identifier) {

                      let sector        = unit_identifier.sector;
                      let planet_idx    = unit_identifier.planet_idx;
                      let unit_idx      = unit_identifier.unit_idx;
                      let unit          = unit_identifier.unit;

		      if (unit == null) {
                        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " has no PDS units to destroy");
		        imperium_self.endTurn();
			return 0;
		      }
                      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit.name + " in " + imperium_self.game.sectors[sector].name);
		      imperium_self.endTurn();
                    }
              );
	    }

            return 0;
          }
          return 1;
        }
  });




  this.importAgendaCard('holy-planet-of-ixth', {
  	name : "Holy Planet of Ixth" ,
  	type : "Law" ,
	elect : "planet" ,
  	text : "Elect a cultural planet. The planet's controller gains 1 VP. Units cannot be landed, produced or placed on this planet" ,
        returnAgendaOptions : function(imperium_self) {
	  return imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "cultural") { return 1; } return 0; 
	  });
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.holy_planet_of_ixth = 1;
	  imperium_self.game.state.holy_planet_of_ixth_planet = winning_choice;
	  let law_to_push = {};
	      law_to_push.agenda = "holy-planet-of-ixth";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  //
	  // lock the planet
	  //
	  imperium_self.game.planets[winning_choice].locked = 1;

	  //
	  // issue VP to controller
	  //
	  let owner = imperium_self.game.planets[winning_choice].owner;
	  if (owner != -1) {
	    imperium_self.game.players_info[owner-1].vp += 1;
	    imperium_self.updateLeaderboard();
	    imperium_self.updateLog(imperium_self.returnFaction(owner) + " gains 1 VP from Holy Planet of Ixth");
	  }

	},
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
	  let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "holy-planet-of-ixth") {
	      winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the player
          //
	  if (winning_choice != null) {
            imperium_self.game.state.holy_planet_of_ixth = 0;
            imperium_self.game.state.holy_planet_of_ixth_planet = -1;
	    imperium_self.game.planets[winning_choice].locked = 0;
	  }

          return 1;

        },
  });



  this.importAgendaCard('research-team-biotic', {
        name : "Research Team: Biotic" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an industrial planet. The owner may exhaust this planet to ignore 1 green technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-biotic") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_biotic = 0;
            imperium_self.game.state.research_team_biotic_planet = -1;
          }

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_biotic = 1;
          imperium_self.game.state.research_team_biotic_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-biotic";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].owner == player) {
            return { event : 'research_team_biotic', html : '<li class="option" id="research_team_biotic">use biotic (green) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_green_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].exhausted = 1;
	  }
          return 0;
        }
  });


  this.importAgendaCard('research-team-cybernetic', {
        name : "Research Team: Cybernetic" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an industrial planet. The owner may exhaust this planet to ignore 1 yellow technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_cybernetic = 1;
          imperium_self.game.state.research_team_cybernetic_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-cybernetic";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
	repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-cybernetic") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_cybernetic = 0;
            imperium_self.game.state.research_team_cybernetic_planet = -1;
          }

          return 1;

        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].owner == player) {
            return { event : 'research_team_cybernetic', html : '<li class="option" id="research_team_cybernetic">use cybernetic (yellow) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_yellow_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].exhausted = 1;
	  }
          return 0;
        }
  });


  this.importAgendaCard('research-team-propulsion', {
        name : "Research Team: Propulsion" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an industrial planet. The owner may exhaust this planet to ignore 1 blue technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-propulsion") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_propulsion = 0;
            imperium_self.game.state.research_team_propulsion_planet = -1;
          }

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_propulsion = 1;
          imperium_self.game.state.research_team_propulsion_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-propulsion";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].owner == player) {
            return { event : 'research_team_propulsion', html : '<li class="option" id="research_team_propulsion">use propulsion (blue) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_blue_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].exhausted = 1;
	  }
          return 0;
        }
  });


  this.importAgendaCard('research-team-warfare', {
        name : "Research Team: Warfare" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an hazardous planet. The owner may exhaust this planet to ignore 1 red technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-warfare") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_warfare = 0;
            imperium_self.game.state.research_team_warfare_planet = -1;
          }

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_warfare = 1;
          imperium_self.game.state.research_team_warfare_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-warfare";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].owner == player) {
            return { event : 'research_team_warfare', html : '<li class="option" id="research_team_warfare">use warfare (red) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_red_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].exhausted = 1;
	  }
          return 0;
        }
  });



  this.importAgendaCard('demilitarized-zone', {
  	name : "Demilitarized Zone" ,
  	type : "Law" ,
	elect : "planet" ,
  	text : "Elect a cultural planet. All units are destroyed and cannot be landed, produced or placed on this planet" ,
        returnAgendaOptions : function(imperium_self) {
	  return imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "cultural") { return 1; } return 0; 
	  });
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.demilitarized_zone = 1;
	  imperium_self.game.state.demilitarized_zone_planet = winning_choice;
	  let law_to_push = {};
	      law_to_push.agenda = "demilitarized-zone";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  imperium_self.game.planets[winning_choice].units = []; 
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.planets[winning_choice].units.push([]);
	  }

	  imperium_self.game.planets[winning_choice].locked = 1;

	},
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "demilitarized-zone") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.demilitarized_zone = 0;
            imperium_self.game.state.demilitarized_zone_planet = -1;
	    imperium_self.game.planets[winning_choice].locked = 0;
          }

          return 1;

        },
  });

  this.importAgendaCard('core-mining', {
  	name : "Core Mining" ,
  	type : "Law" ,
	elect : "planet" ,
  	text : "Elect a hazardous planet. Destroy half the infantry on that planet and increase its resource value by +2" ,
        returnAgendaOptions : function(imperium_self) {
	  return imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "hazardous") { return 1; } return 0; 
	  });
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "core-mining") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }


          if (winning_choice != null) {
            imperium_self.game.state.core_mining = 0;
            imperium_self.game.state.core_mining_planet = -1;
	    imperium_self.game.planets[winning_choice].locked = 0;
	    imperium_self.game.planets[winning_choice].resources -= 2;
          }
          return 1;

        },
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.core_mining = 1;
	  imperium_self.game.state.core_mining_planet = winning_choice;
	  let law_to_push = {};
	      law_to_push.agenda = "core-mining";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  let options = imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "hazardous") { return 1; } return 0; 
	  });

	  //
	  // also - destroy the planet and increase its resource value
	  //
	  //let planetidx = options[winning_choice];
	  let planetidx = winning_choice;

	  for (let i = 0; i < imperium_self.game.planets[planetidx].units.length; i++) {
	    let destroy = 1;
	    for (let ii = 0; ii < imperium_self.game.planets[planetidx].units[i].length; ii++) {
	      if (imperium_self.game.planets[planetidx].units[i][ii].type == "infantry") {
	        if (destroy == 1) {
	          imperium_self.game.players[planetidx].units[i].splice(ii, 1);
		  ii--;
		  destroy = 0;
		} else {
		  destroy = 1;
		}
	      }
	    }
	  }

	  imperium_self.game.planets[winning_choice].resources += 2;

	}
  });



  this.importAgendaCard('anti-intellectual-revolution', {
  	name : "Anti-Intellectual Revolution" ,
  	type : "Law" ,
  	text : "FOR: players must destroy a capital ship in order to play the Technology card. AGAINST: at the start of the next round, each player exhausts one planet for each technology they have." ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "anti-intellectual-revolution") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          let techcard = imperium_self.strategy_cards['technology'];
	  if (techcard.strategyPrimaryEventBackup) { techcard.strategyPrimaryEvent = techcard.strategyPrimaryEventBackup; }
	  if (techcard.strategySecondaryEventBackup) { techcard.strategySecondaryEvent = techcard.strategySecondaryEventBackup; }

          return 1;

        },
	initialize : function(imperium_self, winning_choice) {

          if (winning_choice === "for") {

            let techcard = imperium_self.strategy_cards['technology'];

            let old_tech_sec = techcard.strategySecondaryEvent;
            let new_tech_sec = function(imperium_self, player, strategy_card_player) {
	      if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) {
                imperium_self.playerAcknowledgeNotice("Anti-Intellectual Revolution is in play. Do you wish to destroy a capital ship to research technology?", function() {

                  imperium_self.playerSelectUnitWithFilter(
                    "Select a capital ship to destroy: ",
                    function(ship) {
                      if (ship.type == "destroyer") { return 1; }
                      if (ship.type == "cruiser") { return 1; }
                      if (ship.type == "carrier") { return 1; }
                      if (ship.type == "dreadnaught") { return 1; }
                      if (ship.type == "flagship") { return 1; }
                      if (ship.type == "warsun") { return 1; }
                      return 0;
                    },

                    function(unit_identifier) {

                      let sector        = unit_identifier.sector;
                      let planet_idx    = unit_identifier.planet_idx;
                      let unit_idx      = unit_identifier.unit_idx;
                      let unit          = unit_identifier.unit;

                      if (planet_idx == -1) {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"space"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      } else {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      }
                      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit.name + " in " + imperium_self.game.sectors[sector].name);
                      old_tech_sec(imperium_self, player, strategy_card_player);

                    }
                  );
                });
              }
            };
	    techcard.strategySecondaryEventBackup = old_tech_sec;
            techcard.strategySecondaryEvent = new_tech_sec;



            let old_tech_func = techcard.strategyPrimaryEvent;
            let new_tech_func = function(imperium_self, player, strategy_card_player) {
              if (imperium_self.game.player == strategy_card_player) {
                imperium_self.playerAcknowledgeNotice("Anti-Intellectual Revolution is in play. Do you wish to destroy a capital ship to research technology?", function() {

                  imperium_self.playerSelectUnitWithFilter(
                    "Select a capital ship to destroy: ",
                    function(ship) {
                      if (ship.type == "destroyer") { return 1; }
                      if (ship.type == "cruiser") { return 1; }
                      if (ship.type == "carrier") { return 1; }
                      if (ship.type == "dreadnaught") { return 1; }
                      if (ship.type == "flagship") { return 1; }
                      if (ship.type == "warsun") { return 1; }
                      return 0;
                    },

                    function(unit_identifier) {

                      let sector        = unit_identifier.sector;
                      let planet_idx    = unit_identifier.planet_idx;
                      let unit_idx      = unit_identifier.unit_idx;
                      let unit          = unit_identifier.unit;

                      if (planet_idx == -1) {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"space"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      } else {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      }
                      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit.name + " in " + imperium_self.game.sectors[sector].name);
                      old_tech_func(imperium_self, player, strategy_card_player);

                    }
                  );
                });
              }
            };
	    techcard.strategyPrimaryEventBackup = old_tech_func;
            techcard.strategyPrimaryEvent = new_tech_func;
          }

          if (winning_choice === "against") {
            // exhaust two planets
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              imperium_self.game.players_info[i].must_exhaust_at_round_start.push("planet","planet");
            }
          }
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.anti_intellectual_revolution = 1;
	  let law_to_push = {};
	      law_to_push.agenda = "anti-intellectual-revolution";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  this.initialize(imperium_self, winning_choice);
	}
  });



  this.importAgendaCard('unconventional-measures', {
  	name : "Unconventional Measures" ,
  	type : "Directive" ,
  	text : "FOR: each player that votes 'for' draws 2 action cards. AGAINST: each player that votes 'for' discards their action cards." ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
	onPass : function(imperium_self, winning_choice) {

	  //
	  // gain two action cards
	  //
	  if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == winning_choice) {
                imperium_self.game.queue.push("gain\t2\t"+(i+2)+"\taction_cards"+"\t"+2);
                imperium_self.game.queue.push("DEAL\t2\t"+(i+1)+"\t2");
                imperium_self.game.queue.push("NOTIFY\tdealing two action cards to player "+(i+1));
	      }	      
	    }
	  }

	  //
	  // everyone who votes against discards action cards
	  //
	  if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "for") {
                if (imperium_self.game.player == (i+1)) {
		  imperium_self.game.players_info[i].action_cards_in_hand = 0;
		} else {
		  imperium_self.game.players_info[i].action_cards_in_hand = 0;
		  imperium_self.game.deck[1].hand = [];
  		  let law_to_push = {};
		      law_to_push.agenda = "unconventional-measures";
		      law_to_push.option = "winning_choice";
		  imperium_self.game.state.laws.push(law_to_push);
		}
	      }	      
	    }
	  }

        }
  });


  this.importAgendaCard('seeds-of-an-empire', {
  	name : "Seeds of an Empire" ,
  	type : "Directive" ,
  	text : "FOR: the player(s) with the most VP gain a VP. AGAINST: the players with the least VP gain a VP" ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
	onPass : function(imperium_self, winning_choice) {

	  let io = imperium_self.returnInitiativeOrder();

	  //
	  // highest VP
	  //
	  if (winning_choice === "for") {

	    let highest_vp = 0;
	    for (let i = 0; i < io.length; i++) {
	      if (highest_vp >= imperium_self.game.players_info[io[i]-1].vp) { highest_vp = imperium_self.game.players_info[io[i]-1].vp; }
	      imperium_self.game.state.seeds_of_an_empire = io[i];
	    }

	    for (let i = 0; i < io.length; i++) {
	      if (highest_vp == imperium_self.game.players_info[io[i]-1].vp) {
		imperium_self.game.players_info[io[i]-1].vp += 1;
		imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction((io[i])) + " gains 1 VP from Seeds of an Empire");
	        imperium_self.game.state.seeds_of_an_empire = (io[i]);
		if (imperium_self.checkForVictory()) { return 0; }
	      }
	    }
	    
          }


	  //
	  // lowest VP
	  //
	  if (winning_choice === "against") {

	    let lowest_vp = 10000;
	    for (let i = 0; i < io.length; i++) {
	      if (lowest_vp <= imperium_self.game.players_info[io[i]-1].vp) { highest_vp = imperium_self.game.players_info[io[i]-1].vp; }
	    }

	    for (let i = 0; i < io.length; i++) {
	      if (lowest_vp == imperium_self.game.players_info[io[i]-1].vp) {
		imperium_self.game.players_info[io[i]-1].vp += 1;
		imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction((io[i]+1)) + " gains 1 VP from Seeds of an Empire");
	        imperium_self.game.state.seeds_of_an_empire = (io[i]);
		if (imperium_self.checkForVictory()) { return 0; }

	      }
	    }
	    
          }

	  imperium_self.updateLeaderboard();

	  return 1;
        }
  });


  this.importAgendaCard('space-cadet', {
  	name : "Space Cadet" ,
  	type : "Law" ,
  	text : "Any player more than 3 VP behind the lead must henceforth be referred to as an Irrelevant Loser" ,
        returnAgendaOptions : function(imperium_self) { 
	  let options = [ 'for' , 'against' ];
	  return options;
        },
	initialize : function(imperium_self, winning_choice) {
	  if (imperium_self.space_cadet_initialized == undefined) {
	    imperium_self.space_cadet_initialized = 1;
	    if (imperium_self.game.state.space_cadet == 1) {
	      imperium_self.returnFactionNamePreSpaceCadet = imperium_self.returnFactionName;
	      imperium_self.returnFactionName = function(imperium_self, player) {
	        let max_vp = 0;
	        for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	          if (max_vp < imperium_self.game.players_info[i].vp) {
		    max_vp = imperium_self.game.players_info[i].vp;
		  }
	        }
                if (imperium_self.game.players_info[player-1].vp <= (max_vp-3)) { return "Irrelevant Loser"; }
    	        return imperium_self.returnFactionNamePreSpaceCadet(imperium_self, player);
  	      }
	      imperium_self.returnFactionNameNicknamePreSpaceCadet = imperium_self.returnFactionNameNickname;
	      imperium_self.returnFactionNameNickname = function(imperium_self, player) {
	        let max_vp = 0;
	        for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	          if (max_vp < imperium_self.game.players_info[i].vp) {
		    max_vp = imperium_self.game.players_info[i].vp;
		  }
	        }
                if (imperium_self.game.players_info[player-1].vp <= (max_vp-3)) { return "Loser"; }
    	        return imperium_self.returnFactionNameNicknamePreSpaceCadet(imperium_self, player);
  	      }
	    }
	  }
	},
	onPass : function(imperium_self, winning_choice) {
	  if (winning_choice == 'for') {
	    imperium_self.game.state.space_cadet = 1;
	    let law_to_push = {};
	        law_to_push.agenda = "space-cadet";
	        law_to_push.option = winning_choice;
	    imperium_self.game.state.laws.push(law_to_push);
	    this.initialize(imperium_self);
	  }
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) { 
            if (imperium_self.game.state.laws[i].agenda === "space-cadet") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
	  imperium_self.game.state.space_cadet = 0;
          imperium_self.returnFactionName = imperium_self.returnFactionNamePreSpaceCadet;

          return 1;

        }
  });


  this.importAgendaCard('galactic-threat', {
  	name : "Galactic Threat" ,
  	type : "Law" ,
  	text : "Elect a player. They must henceforth be referred to as the Galatic Threat" ,
        returnAgendaOptions : function(imperium_self) { 
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
        },
	initialize : function(imperium_self, winning_choice) {
	  if (imperium_self.galactic_threat_initialized == undefined) {
	    imperium_self.galactic_threat_initialized = 1;
	    if (imperium_self.game.state.galactic_threat == 1) {
	      imperium_self.returnFactionNamePreGalacticThreat = imperium_self.returnFactionName;
	      imperium_self.returnFactionName = function(imperium_self, player) {
                if (imperium_self.game.state.galactic_threat_player == player) { return "The Galactic Threat"; }
    	        return imperium_self.returnFactionNamePreGalacticThreat(imperium_self, player);
  	      }
	      imperium_self.returnFactionNameNicknamePreGalacticThreat = imperium_self.returnFactionNameNickname;
	      imperium_self.returnFactionNameNickname = function(imperium_self, player) {
                if (imperium_self.game.state.galactic_threat_player == player) { return "Threat"; }
    	        return imperium_self.returnFactionNameNicknamePreGalacticThreat(imperium_self, player);
  	      }
	    }
	  }
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.galactic_threat = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.galactic_threat_player = i+1;
	    }
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "galactic-threat";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  this.initialize(imperium_self);
	},
        repealAgenda(imperium_self) {

	  let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) { 
            if (imperium_self.game.state.laws[i].agenda === "galactic-threat") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.galactic_threat = 0;
          imperium_self.game.state.galactic_threat_initialized = 0;
	  if (imperium_self.returnFactionNamePreGalacticThreat) {
            imperium_self.returnFactionName = imperium_self.returnFactionNamePreGalacticThreat;
	  }

          return 1;

        }
  });




  this.importAgendaCard('Committee Formation', {
  	name : "Committee Formation" ,
  	type : "Law" ,
	elect : "player" ,
  	text : "Elect a player. They may form a committee to choose a player to be elected in a future agenda, bypassing voting" ,
        returnAgendaOptions : function(imperium_self) { 
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
        },
	preAgendaStageTriggers : function(imperium_self, player, agenda) {
	  if (imperium_self.game.state.committee_formation == 1 && imperium_self.game.state.committee_formation_player == player) { return 1; }
	  return 0;
	},
	preAgendaStageEvent : function(imperium_self, player, agenda) {

	  let html = "Do you wish to use Committee Formation to select the winner yourself? <ul>";
	      html += '<li class="textchoice" id="yes">assemble the committee</li>';
	      html += '<li class="textchoice" id="no">not this time</li>';
	      html += '</ul>';

	  imperium_self.updateStatus(html);

	  $('.textchoice').off();
	  $('.textchoice').on('click', function() {

	    let action = $(this).attr("id");

	    if (action == "no") { imperium_self.endTurn(); }

	    //
	    // works by "Assassinating all other representatives, so they don't / can't vote"
	    //
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (i != imperium_self.game.player-1) {
                imperium_self.addMove("rider\t"+player+"\tassassinate-representative\t-1");
	      }
	    }
            imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " forms a committee...");
	    

	  });

          return 0;

	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.committee_formation = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.committee_formation_player = (i+1);
	    }
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "committee-formation";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	},
        repealAgenda(imperium_self) {

	  let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "committee_formation") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.game.state.committee_formation = 0;
          imperium_self.game.state.committee_formation_player = -1;
          imperium_self.returnFactionName = imperium_self.returnFactionNamePreGalacticThreat;
          
          return 1;

        }

  });




  this.importAgendaCard('minister-of-policy', {
        name : "Minister of Policy" ,
        type : "Law" ,
	elect : "player" ,
        text : "Elect a player. They draw an extra action card at the start of each round" ,
        returnAgendaOptions : function(imperium_self) {
          let options = [];
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            options.push(imperium_self.returnFaction(i+1));
          }
          return options;
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.minister_of_policy = 1;
          imperium_self.game.state.minister_of_policy_player = winning_choice;
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.minister_of_policy_player = i+1;
	    }
	  }
	  imperium_self.game.players_info[imperium_self.game.state.minister_of_policy_player-1].action_cards_bonus_when_issued++;
	  let law_to_push = {};
	      law_to_push.agenda = "minister-of-policy";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

        },
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "minister-of-policy") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.game.state.minister_of_policy = 0;
	  imperium_self.game.players_info[imperium_self.game.state.minister_of_policy_player-1].action_cards_bonus_when_issued--;
          imperium_self.game.state.minister_of_policy_player = -1;

          return 1;

        }
  });



  this.importAgendaCard('executive-sanctions', {
  	name : "Executive Sanctions" ,
  	type : "Law" ,
  	text : "Players may have a maximum of 3 action cards in their hands at all times" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].action_card_limit = 3;
	    }
	  }
	  let law_to_push = {};
	      law_to_push.agenda = "executive-sanctions";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  return 1;
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "executive-sanctions") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (imperium_self.game.players_info[i].action_card_limit == 3) {
	      imperium_self.game.players_info[i].action_card_limit = 7;
	    }
	  }

          return 1;

        }

  });

  this.importAgendaCard('fleet-limitations', {
  	name : "Fleet Limitations" ,
  	type : "Law" ,
  	text : "Players may have a maximum of four tokens in their fleet supply." ,
  	img : "/imperium/img/agenda_card_template.png" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].fleet_supply_limit = 4;
	      if (imperium_self.game.players_info[i].fleet_supply >= 4) { imperium_self.game.players_info[i].fleet_supply = 4; }
	    }
	  }
	  return 1;
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "fleet-limitations") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].fleet_supply_limit = 16;
          }

          return 1;

        }

  });


  this.importAgendaCard('restricted-conscription', {
  	name : "Restricted Conscription" ,
  	type : "Law" ,
  	text : "Production cost for infantry and fighters is 1 rather than 0.5 resources" ,
  	img : "/imperium/img/agenda_card_template.png" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    imperium_self.units["infantry"].cost = 1;
	    imperium_self.units["fighter"].cost = 1;
	  }
	  let law_to_push = {};
	      law_to_push.agenda = "restricted-conscription";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  return 1;
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "restricted-conscription") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.units["infantry"].cost = 0.5;
          imperium_self.units["fighter"].cost = 0.5;

          return 1;

        }
  });


  this.importAgendaCard('wormhole-travel-ban', {
  	name : "Wormhole Travel Ban" ,
  	type : "Law" ,
  	text : "All wormholes are closed." ,
  	img : "/imperium/img/agenda_card_template.png" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    imperium_self.game.state.wormholes_open = 0;
	  }
	  let law_to_push = {};
	      law_to_push.agenda = "wormhole-travel-ban";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  return 1;
	},
        repealAgenda(imperium_self) {
          
          let winning_choice = null;
          
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "wormhole-travel-ban") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.wormholes_open = 1;;
          
          return 1;

        }

  });





  this.importAgendaCard('archived-secret', {
  	name : "Archived Secret" ,
  	type : "Directive" ,
  	text : "Elected Player draws one secret objective" ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.archived_secret = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.archived_secret_player = i+1;
	    }
	  }

	  //
	  // deal secret objective
	  //
          imperium_self.game.queue.push("gain\t"+(imperium_self.game.state.archived_secret_player)+"\tsecret_objectives\t1");
          imperium_self.game.queue.push("DEAL\t6\t"+(imperium_self.game.state.archived_secret_player)+"\t1");

	  return 1;

	},
  });



  this.importAgendaCard('economic-equality', {
  	name : "Economic Equality" ,
  	type : "Directive" ,
  	text : "FOR: all players discard all trade goods, AGAINST: players lose all trade goods and then gain 5 trade goods. " ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.economic_equality = 1;

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].goods = 0;
	    }
	    imperium_self.updateLog("All players have 0 trade goods");
          }

          if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].goods = 5;
	    }
	    imperium_self.updateLog("All players have 5 trade goods");
          }

	  imperium_self.displayFactionDashboard();

	  return 1;

	},
  });






  this.importAgendaCard('mutiny', {
  	name : "Mutiny" ,
  	type : "Directive" ,
  	text : "FOR: all who vote FOR gain 1 VP, AGAINST: all players who vote FOR lose 1 VP" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.mutiny = 1;

          if (winning_choice === "for") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "for") {
                imperium_self.game.players_info[i].vp++;
	        imperium_self.updateLog(imperium_self.returnFaction(i+1) + " gains 1 VP from Mutiny");
              }
            }
          }

          //
          // everyone who votes against discards action cards
          //
          if (winning_choice === "against") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] === "for") {
                imperium_self.game.players_info[i].vp--;
	        imperium_self.updateLog(imperium_self.returnFaction(i+1) + " loses 1 VP from Mutiny");
              }
            }
	  }

	  imperium_self.updateLeaderboard();

	  return 1;

	},
  });




  this.importAgendaCard('conventions-of-war', {
  	name : "Conventions of War" ,
  	type : "Law" ,
  	text : "FOR: cultural planets are exempt from bombardment, AGAINST: players who vote against discard all action cards" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.conventions_of_war = 1;

          if (winning_choice === "for") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "against") {
                imperium_self.game.players_info[i].action_cards_in_hand = 0;
		if (imperium_self.game.player == (i+1)) {
		  imperium_self.game.deck[1].hand = [];
		}
              }
            }
          }

          //
          // everyone who votes against discards action cards
          //
          if (winning_choice === "against") {
            imperium_self.game.state.bombardment_against_cultural_planets = 0;
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "conventions-of-war";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  return 1;

	},
        repealAgenda(imperium_self) {
          
          let winning_choice = null;
          
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "conventions-of-war") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.bombardment_against_cultural_planets = 1;          

          return 1;

        }

  });





  this.importAgendaCard('swords-to-ploughshares', {
  	name : "Swords to Ploughshares" ,
  	type : "Directive" ,
  	text : "FOR: everyone destroys half their infantry (round up) on every planet, AGAINST: everyone gains 1 infantry each planet" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.swords_to_ploughshares = 1;

          if (winning_choice === "against") {
            for (let i in imperium_self.game.planets) {
	      if (imperium_self.game.planets[i].owner != -1) {
		imperium_self.game.planets[i].units[imperium_self.game.planets[i].owner-1].push(imperium_self.returnUnit("infantry", imperium_self.game.planets[i].owner));
	      }
	    }
	  }


          //
          // everyone who votes against discards action cards
          //

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {

	      let total_infantry_destroyed = 0;

              for (let k in imperium_self.game.planets) {
	        if (imperium_self.game.planets[k].owner == (i+1)) {

		  let destroy_this_infantry = 0;

		  for (let m = 0; m < imperium_self.game.planets[k].units[i].length; m++) {
		    if (imperium_self.game.planets[k].units[i][m].type == "infantry") {
		      if (destroy_this_infantry == 1) {
			destroy_this_infantry = 0;
			total_infantry_destroyed++;
		      } else {
			destroy_this_infantry = 1;
		      }
		    }
		  }

		  for (let m = 0, n = 0; n < total_infantry_destroyed && m < imperium_self.game.planets[k].units[i].length; m++) {
		    if (imperium_self.game.planets[k].units[i][m].type == "infantry") {
		      imperium_self.game.planets[k].units[i].splice(m, 1);
		      m--;
		      n++;
		    }
		  }


	        }
	      }

	      if (total_infantry_destroyed == 1) {
  	        imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " gains " + total_infantry_destroyed + " trade good");
	      } else {
  	        imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " gains " + total_infantry_destroyed + " trade goods");
	      }

	    }
	  }

	  return 1;

	},
  });




  this.importAgendaCard('wormhole-research', {
  	name : "Wormhole Research" ,
  	type : "Directive" ,
  	text : "FOR: all ships in sectors with alpha and beta wormholes are destroyed, their owners research 1 technology, AGAINST: everyone who voted against loses a command token" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.wormhole_research = 1;

	  let players_to_research_tech = [];

          if (winning_choice === "for") {
	    for (let i in imperium_self.game.sectors) {
	      if (imperium_self.game.sectors[i].wormhole != 0) {
	        for (let k = 0; k < imperium_self.game.sectors[i].units.length; k++) {
	          if (imperium_self.game.sectors[i].units[k].length > 0) {
	            imperium_self.game.sectors[i].units[k] = [];
		    if (!players_to_research_tech.includes((k+1))) {
		      players_to_research_tech.push((k+1));
		    }
		  }
		}
	      }
            }

	    players_to_research_tech.sort();
	    for (let i = 0; i < players_to_research_tech.length; i++) { 
	      imperium_self.game.queue.push("reearch\t"+players_to_research_tech[i]);
	    }
          }





          //
          // everyone who votes against loses command token
          //
          if (winning_choice === "against") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "against") {
                imperium_self.game.players_info[i].command_tokens--;
                if (imperium_self.game.players_info[i].command_tokens <= 0) {
                  imperium_self.game.players_info[i].command_tokens = 0;
		}
	      }
	    }
	    imperium_self.updateTokenDisplay();
	  }
	  return 1;

	},
  });







  this.importAgendaCard('new-constitution', {
  	name : "New Constitution" ,
  	type : "Directive" ,
  	text : "FOR: remove all laws in play and exhaust all homeworld at the start of the next round" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.new_constitution = 1;

	  //
	  // repeal any laws in plan
	  //
	  for (let i = imperium_self.game.state.laws.length-1; i > 0; i--) {
	    let saved_agenda = imperium_self.game.state.laws[i].agenda;
	    imperium_self.agenda_cards[saved_agenda].repealAgenda(imperium_self);
	  }

	  let players_to_research_tech = [];

          if (winning_choice === "for") {
	    imperium_self.game.state.laws = [];
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].must_exhaust_at_round_start.push("homeworld");
            }
          }

	  return 1;


	},
  });






  this.importAgendaCard('shared-research', {
  	name : "Shared Research" ,
  	type : "Directive" ,
  	text : "FOR: each player activates their home system, AGAINST: units can move through nebulas" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.shared_research = 1;

	  let players_to_research_tech = [];

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.queue.push("activate\t"+(i+1)+"\t"+imperium_self.returnPlayerHomeworld((i+1)));
            }
          }

          if (winning_choice === "against") {
	    imperium_self.game.players_info[i].fly_through_nebulas = 1;
	  }

	  return 1;

	},
  });







  this.importAgendaCard('wormhole-reconstruction', {
  	name : "Wormhole Reconstruction" ,
  	type : "Directive" ,
  	text : "FOR: alpha and beta wormholes connect to each other, AGAINST:  each player activates all systems with alpha and beta wormholes" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.wormhole_reconstruction = 1;

          if (winning_choice === "for") {
	    imperium_self.game.state.wormholes_adjacent = 1;
          }

          if (winning_choice === "against") {
	    for (let i in imperium_self.game.sectors) {
	      if (imperium_self.game.sectors[i].wormhole == 1 || imperium_self.game.sectors[i].wormhole == 2) {
		for (let ii = 0; ii < imperium_self.game.players_info.length; ii++) {
		  imperium_self.game.sectors[i].activated[ii] = 1;
		}
	        let sys = imperium_self.returnSectorAndPlanets(i);
		if (sys.s) {
		  imperium_self.updateSectorGraphics(i);
		}
	      }
	    }
	  }

	  return 1;

	},
  });





  this.importAgendaCard('crown-of-emphidia', {
        name : "Crown of Emphidia" ,
        type : "Law" ,
        elect : "player" ,
        text : "Elect a Player to earn 1 VP. When this player loses a homeworld to another player, they lose 1 VP and their opponent gains 1 VP" ,
        returnAgendaOptions : function(imperium_self) {
          let options = [];
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            options.push(imperium_self.returnFaction(i+1));
          }
          return options;
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.crown_of_emphidia = 1;

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            if (winning_choice === imperium_self.returnFaction((i+1))) {
              imperium_self.game.state.crown_of_emphidia_player = i+1;
            }
          }

          let law_to_push = {};
              law_to_push.agenda = "crown-of-emphidia";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);

          imperium_self.game.players_info[imperium_self.game.state.crown_of_emphidia_player-1].vp += 1;
          imperium_self.updateLeaderboard();
          imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.crown_of_emphidia_player) + " gains 1 VP from Crown of Emphidia");

        },
        repealAgenda(imperium_self) {
          
          let winning_choice = null;
          
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "crown-of-emphidia") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.crown_of_emphidia = -1;
          imperium_self.game.state.crown_of_emphidia_player = -1;
          
          return 1;

        },
        groundCombatRoundEnd : function(imperium_self, attacker, defender, sector, planet_idx) {
          if (defender == imperium_self.game.state.crown_of_emphidia_player) {
            if (!imperium_self.doesPlayerHaveInfantryOnPlanet(defender, sector, planet_idx)) {
              if (imperium_self.doesPlayerHaveInfantryOnPlanet(attacker, sector, planet_idx)) {
                imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.crown_of_emphidia_player) + " loses the Crown of Emphidia (-1VP)");
                imperium_self.game.state.crown_of_emphidia_player = attacker;
                imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.crown_of_emphidia_player) + " gains the Crown of Emphidia (+1VP)");
                imperium_self.game.players_info[attacker-1].vp += 1;
                imperium_self.game.players_info[defender-1].vp -= 1;
                imperium_self.updateLeaderboard();
	      }
            }
          }

	  return 1;

        },
  });

  this.importAgendaCard('terraforming-initiative', {
        name : "Terraforming Initiative" ,
        type : "Law" ,
        elect : "planet" ,
        text : "Elect a hazardous planet. The resource and influence values of this planet are increased by 1 point each" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "hazardous") { return 1; } return 0;
          });
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.terraforming_initiative = 1;
          imperium_self.game.state.terraforming_initiative_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "terraforming-initiative";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);

          //
          // alter planet
          //
          imperium_self.game.planets[winning_choice].resources++;
          imperium_self.game.planets[winning_choice].influence++;
          imperium_self.updateLog(imperium_self.game.planets[winning_choice].name + " increases resource and influence through terraforming");

	  return 1;

        },
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "terraforming-initiative") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.game.state.terraforming_initiative = -1;
	  if (winning_choice) {
            if (imperium_self.game.planets[winning_choice]) {
              imperium_self.game.planets[winning_choice].resources--;
              imperium_self.game.planets[winning_choice].influence--;
            }
	  }
	  imperium_self.game.state.terraforming_initiative_planet = -1;

          return 1;

        },

  });


  this.importAgendaCard('senate-sanctuary', {
        name : "Senate Sanctuary" ,
        type : "Law" ,
        elect : "planet" ,
        text : "Elect a cultural planet. The influence value of this planet is increased by 2 points" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "cultural") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {
  
          let winning_choice = null;     

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "senate-sanctuary") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;    
            }
          }

          if (winning_choice) {
            if (imperium_self.game.planets[winning_choice]) {
              imperium_self.game.planets[winning_choice].influence -= 2;
            }
          }
          imperium_self.game.state.senate_sanctuary = 0;
          imperium_self.game.state.senate_sanctuary_planet = -1;

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.senate_sanctuary = 1;
          imperium_self.game.state.senate_sanctuary_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "senate-sanctuary";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);

          //
          // alter planet
          //
          imperium_self.game.planets[winning_choice].influence+=2;
          imperium_self.updateLog(imperium_self.game.planets[winning_choice].name + " increases influence value by 2");

	  return 1;

        }
  });


  this.importAgendaCard('publicize-weapons-schematics', {
        name : "Publicize Weapons Schematics" ,
        type : "Directive" ,
        text : "FOR: all players now have War Suns technology, AGAINST: all players with War Suns technology discard all action cards" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.publicize_weapons_schematics = 1;

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (!imperium_self.doesPlayerHaveTech((i+1), "warsun")) {
		imperium_self.game.queue.push("purchase\t"+(i+1)+"\t"+"tech"+"\t"+"warsun");
	      }
 	    }
          }

          if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.doesPlayerHaveTech((i+1), "warsun")) {
		imperium_self.game.players_info[i].action_cards_in_hand = 0;
		if (imperium_self.game.player == (i+1)) {
		  imperium_self.game.deck[1].hand = [];
		}
		imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " discards all Action Cards");
	      }
	    }
	  }

	  return 1;

        }
  });



  this.importAgendaCard('incentive-program', {
        name : "Incentive Program" ,
        type : "Directive" ,
        text : "FOR: reveal a 1 VP public objective, AGAINST: reveal a 2 VP public objective" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.incentive_program = 1;

          if (winning_choice === "for") {
            imperium_self.game.queue.push("revealobjectives");
            for (let i = 1; i <= imperium_self.game.players_info.length; i++) {
              imperium_self.game.queue.push("FLIPCARD\t4\t1\t2\t"+i); // deck card poolnum player
            }
          }

          if (winning_choice === "against") {
            imperium_self.game.queue.push("revealobjectives");
            for (let i = 1; i <= imperium_self.game.players_info.length; i++) {
              imperium_self.game.queue.push("FLIPCARD\t5\t1\t3\t"+i); // deck card poolnum player
            }
	  }
	  return 1;
        }
  });


  this.importAgendaCard('colonial-redistribution', {
        name : "Colonial Redistribution" ,
        type : "Directive" ,
        elect : "planet" ,
        text : "Elect a cultural, industrial or hazardous planet. Destroy all units on the planet. Planet owner chooses a player with the fewest VP to gain control of the planet and gain 1 infantry on it. If no-one controls that planet, the Speaker chooses the recipient." ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "cultural") { return 1; }
            if (planet.type === "industrial") { return 1; }
            if (planet.type === "hazardous") { return 1; }
	    return 0;
          });
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.colonial_redistribution = 1;
          imperium_self.game.state.colonial_redistribution_planet = winning_choice;
	  imperium_self.game.queue.push("colonial_redistribution\t"+winning_choice);

	  imperium_self.game.state.laws.push({ agenda : "colonial-redistribution" , option : winning_choice });

	  return 0;

        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "colonial_redistribution") {

            let winning_choice = mv[1];
            imperium_self.game.queue.splice(qe, 1);

	    let owner = imperium_self.game.planets[winning_choice].owner;
	    let planet_idx = imperium_self.game.planets[winning_choice].idx;
	    let sector = imperium_self.game.planets[winning_choice].sector;

	    if (owner == -1) { owner = imperium_self.game.state.speaker; }
	    imperium_self.game.planets[winning_choice].units[owner] = [];

	    if (imperium_self.game.player == owner) {
            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player to receive 1 infantry and this planet" ,
              function(player) {
	        let lower_vp_player = 0;
		let this_player_vp = player.vp;
	        for (let i = 0; i < imperium_self.game.players_info.length; i++) {
		  if (imperium_self.game.players_info[i] < this_player_vp) { lower_vp_player = 1; }
		}
	        if (lower_vp_player == 1) { return 0; }
		return 1;
              },
	      function(player) {
		imperium_self.updateStatus("");
		imperium_self.addMove("produce\t" + player + "\t" + "1" + "\t" + planet_idx + "\t" + "infantry" + "\t" + sector);
		imperium_self.addMove("annex\t" + player + "\t" + sector + "\t" + planet_idx);
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " gains the contested planet");
		imperium_self.endTurn();
		return 0;
	      },
	    );
	    }

            return 0;
          }

          return 1;
        }
  });



  this.importAgendaCard('compensated-disarmament', {
        name : "Compensated Disarmament" ,
        type : "Directive" ,
        elect : "planet" ,
        text : "Destroy all ground forces on planet. For each infantry destroyed planet owner gains 1 trade good" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
	    return 1;
          });
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.compensated_disarmament = 1;
          imperium_self.game.state.compensated_disarmament_planet = winning_choice;

console.log("planet is: " + winning_choice);

	  let planet = imperium_self.game.planets[winning_choice];
	  let owner = parseInt(planet.owner);
	  let total_infantry = 0;

	  if (owner == -1) { return 1; }

	  let units_to_check = planet.units[owner-1].length;
	  for (let i = 0; i < units_to_check; i++) {
	    let unit = planet.units[owner-1][i];
	    if (unit.type == "infantry") {
	      total_infantry++;
	      planet.units[owner-1].splice(i, 1);
	      i--;
	      units_to_check = planet.units[owner-1].length;
	    }
	  }

	  if (total_infantry > 0) {
	    imperium_self.game.queue.push("purchase\t"+owner+"\tgoods\t"+total_infantry);
	  }

	  imperium_self.updateSectorGraphics(planet.sector);

	  return 1;

        }
  });


  this.importAgendaCard('judicial-abolishment', {
        name : "Judicial Abolishment" ,
        type : "Directive" ,
        elect : "law" ,
        text : "Discard a law if one is in play" ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	    options.push(imperium_self.agenda_cards[imperium_self.game.state.laws[i].agenda].name);
	  }
	  return options;
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.judicial_abolishment = 1;
          imperium_self.game.state.judicial_abolishment_law = winning_choice;

	  let repealed = null;

	  for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	    if (winning_choice === imperium_self.agenda_cards[imperium_self.game.state.laws[i].agenda].name) {
	      imperium_self.agenda_cards[ imperium_self.game.state.laws[i].agenda ].repealAgenda(imperium_self);
	      repealed = imperium_self.game.state.laws[i].agenda;
	      i = imperium_self.game.state.laws.length+2;
	    }
	  }

	  if (repealed) {
	    imperium_self.updateLog(imperium_self.agenda_cards[repealed].name + " abolished");
	  }

	  return 1;

        }
  });




  this.importAgendaCard('public-execution', {

        name : "Public Execution" ,
        type : "Directive" ,
	elect : "player" ,
        text : "Elect a player. They discard all their action cards, lose the speaker token to the next player in initiative order (if they have it) and lose all of their votes." ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
	},
        onPass : function(imperium_self, winning_choice) {

	  let initiative_order = imperium_self.returnInitiativeOrder();

          imperium_self.game.state.public_execution = 1;

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            if (winning_choice === imperium_self.returnFaction((i+1))) {
              imperium_self.game.state.public_execution_player = i+1;
            }
          }


	  // lose action cards
          imperium_self.game.players_info[imperium_self.game.state.public_execution_player-1].action_cards_in_hand = 0;
	  if (imperium_self.game.player == imperium_self.game.state.public_execution_player) {
	    imperium_self.game.deck[1].hand = [];
	  }

	  // lose speakership
	  if (winning_choice == imperium_self.game.state.speaker) {
	    imperium_self.game.state.speaker = initiative_order[0];
	    for (let i = 0; i < initiative_order.length-1; i++) {
	      if (initiative_order[i] == imperium_self.game.state.public_execution_player) {
	        imperium_self.game.state.speaker = initiative_order[i+1];
	      }
	    }
	  }

	  // lose all voting power
          imperium_self.game.state.votes_available[imperium_self.game.state.public_execution_player-1] = 0;

	  imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.public_execution_player) + " representative publicly executed");

	  return 1;

        }
  });








  this.importAgendaCard('ixthian-artifact', {

        name : "Ixthian Artifact" ,
        type : "Directive" ,
        text : "FOR: roll a die. On rolls of 5 and under destroy all units on New Byzantium and 3 units in each adjacent system. On all other rolls each player researches 2 technologies" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
        onPass : function(imperium_self, winning_choice) {

	  if (winning_choice == "for") {

	    let roll = imperium_self.rollDice(10);

imperium_self.updateLog("Ixthian Artifact rolls " + roll);

	    if (roll <= 5) {

	      // destroy all units
	      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
		imperium_self.game.planets['new-byzantium'].units[i] = [];
		imperium_self.game.sectors['new-byzantium'].units[i] = [];
	      }

     	      let as = imperium_self.returnAdjacentSectors('new-byzantium');
 	      for (let i = 0; i < as.length; i++) {
	        for (let ii = 0; ii < imperium_self.game.players_info.length; ii++) {
  	          if (imperium_self.doesSectorContainPlayerUnits((ii+1), as[i])) {
		    imperium_self.game.queue.push("destroy_units\t"+(ii+1)+"\t"+3+"\t"+as[i]+"\t"+0);
    	          }
    	        }
	      }

	    }

	    if (roll >= 6) {
	      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
		imperium_self.game.queue.push("research\t"+(i+1));
		imperium_self.game.queue.push("research\t"+(i+1));
	      }
	      imperium_self.game.queue.push("ACKNOWLEDGE\tThe Ixthian Artifact did not explode. All players may now research two technologies...");
          }
        }
        return 1;
      }
  });



/************************************
  
ACTION CARD - types

"action" -> main menu
"bombardment_attacker"
"bombardment_defender"
"combat"
"ground_combat"
"pds" -> before pds fire
"post_pds" -> after pds fire
"pre_agenda" --> before agenda voting
"post_agenda" --> after agenda voting
"space_combat"
"space_combat_victory"
"rider"


************************************/


    this.importActionCard('infiltrate', {
  	name : "Infiltrate" ,
  	type : "instant" ,
  	text : "The next time you invade a planet, you may takeover any existing PDS units or Space Docks" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_infiltrate_infrastructure_on_invasion = 1;
	  return 1;
	},
    });




    this.importActionCard('reparations', {
  	name : "Reparations" ,
  	type : "action" ,
  	text : "If you have lost a planet this round, refresh one of your planets" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.players_info[action_card_player-1].lost_planet_this_round != -1) {

	    let my_planets = imperium_self.returnPlayerExhaustedPlanetCards(imperium_self.game.player);

            imperium_self.playerSelectPlanetWithFilter(
              "Select an exhausted planet to refresh: " ,
              function(planet) {
		if (my_planets.includes(planet)) { return 1; } return 0;
              },
              function(planet) {
                imperium_self.addMove("unexhaust\tplanet\t"+planet);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player)+" refreshes " + imperium_self.game.planets[planet].name);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	    return 0;
	  }
	  return 1;
	},
    });



    this.importActionCard('political-stability', {
  	name : "Political Stability" ,
  	type : "instant" ,
  	text : "Pick a strategy card you have already played this round. You may keep this for next round" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let html = '<div class="sf-readable">Pick a Strategy Card to keep for next round: </div><ul>';
	    for (let i = 0; i < imperium_self.game.players_info[action_card_player-1].strategy_cards_played.length; i++) {
	      let card = imperium_self.game.players_info[action_card_player-1].strategy_cards_played[i];
              html += '<li class="option" id="'+card+'">' + imperium_self.strategy_cards[card].name + '</li>';
	    }
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.option').off();
	    $('.option').on('click', function() {
	      let card = $(this).attr("id");
	      imperium_self.addMove("strategy_card_retained\t"+imperium_self.game.player+"\t"+card);
	      imperium_self.endTurn();
	      return 0;
	    });

	  }

	  return 0;
	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "strategy_card_retained") {

            let player = parseInt(mv[1]);
            let card = mv[2];
            imperium_self.game.queue.splice(qe, 1);
	    imperium_self.game.players_info[player-1].strategy_cards_retained.push(card);

            return 1;
          }

	  return 1;
        }
    });



    this.importActionCard('lost-star-chart', {
  	name : "Lost Star Chart" ,
  	type : "instant" ,
  	text : "During this turn, all wormholes are adjacent to each other" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.temporary_wormholes_adjacent = 1;
	  return 1;
	},
    });


    this.importActionCard('plague', {
  	name : "Plague" ,
  	type : "action" ,
  	text : "ACTION: Select a planet. Roll a dice for each infantry on planet and destroy number of rolls 6 or higher." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet to cripple with the plague:",
              function(planet) {
		return imperium_self.doesPlanetHaveInfantry(planet);
              },
	      function(planet) {
		imperium_self.addMove("plague\t"+imperium_self.game.player+"\t"+planet);
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " unleashes a plague on " + imperium_self.game.planets[planet].name);
		imperium_self.endTurn();
		return 0;
	      },
	      null
	    );
	  }
	  return 0;
	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "plague") {

            let attacker = parseInt(mv[1]);
            let target = mv[2];
	    let sector = imperium_self.game.planets[target].sector;
	    let planet_idx = imperium_self.game.planets[target].idx;
	    let sys = imperium_self.returnSectorAndPlanets(sector);
	    let z = imperium_self.returnEventObjects();
	    let player = sys.p[planet_idx].owner;

	    let total_units_destroyed = 0;

            for (let i = 0; i < sys.p[planet_idx].units.length; i++) {
              for (let ii = 0; ii < sys.p[planet_idx].units[i].length; ii++) {
		let thisunit = sys.p[planet_idx].units[i][ii];

		if (thisunit.type == "infantry") {
		  let roll = imperium_self.rollDice(10);
		  if (roll > 6) {
		    thisunit.destroyed = 1;
		    for (z_index in z) {
		      thisunit = z[z_index].unitDestroyed(this, attacker, thisunit);
		    }
	            total_units_destroyed++;
		  }
		}
	      }
            }

	    imperium_self.updateLog("The plague destroys " + total_units_destroyed + " infantry");

            imperium_self.eliminateDestroyedUnitsInSector(player, sector);
            imperium_self.saveSystemAndPlanets(sys);
            imperium_self.updateSectorGraphics(sector);
            imperium_self.game.queue.splice(qe, 1);

            return 1;
          }

	  return 1;
        }

    });



    this.importActionCard('repeal-law', {
  	name : "Repeal Law" ,
  	type : "action" ,
  	text : "ACTION: Repeal one law that is in effect." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

	    let html = '<div class="sf-readable">Pick a Law to Repeal: </div><ul>';
	    for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	      let law = imperium_self.game.state.laws[i];
	      let agenda = imperium_self.agenda_cards[law];
              html += '<li class="option" id="'+agenda+'">' + imperium_self.agenda_cards[card].name + '</li>';
	    }
            html += '<li class="option" id="cancel">cancel</li>';
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.option').off();
	    $('.option').on('click', function() {

	      let card = $(this).attr("id");

	      if (card === "cancel") {
	        imperium_self.endTurn();
		return 0;
	      }

	      imperium_self.addMove("repeal_law\t"+card);
	      imperium_self.endTurn();
	      return 0;
	    });
          }

	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "repeal_law") {

            let card = mv[2];
            imperium_self.game.queue.splice(qe, 1);
	    for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	      if (imperium_self.game.state.laws[i] == card) {
		imperium_self.agenda_cards[card].repealAgenda(imperium_self);
	        return 1;
	      }
	    }

            return 1;
          }

	  return 1;
        }
    });



    this.importActionCard('veto', {
  	name : "Veto" ,
  	type : "action" ,
  	text : "ACTION: Select one agenda to remove from consideration and draw a replacement" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            let html = '';
            html += 'Select one agenda to quash in the Galactic Senate.<ul>';
            for (i = 0; i < 3; i++) {
              html += '<li class="option" id="'+imperium_self.game.state.agendas[i]+'">' + imperium_self.agenda_cards[imperium_self.game.state.agendas[i]].name + '</li>';
            }
            html += '</ul>';

            imperium_self.updateStatus(html);

            $('.option').off();
            $('.option').on('mouseenter', function() { let s = $(this).attr("id"); imperium_self.showAgendaCard(s); });
            $('.option').on('mouseleave', function() { let s = $(this).attr("id"); imperium_self.hideAgendaCard(s); });
            $('.option').on('click', function() {

              let agenda_to_quash = $(this).attr('id');

	      imperium_self.hideAgendaCard(agenda_to_quash);

              imperium_self.updateStatus("Quashing Agenda");
              imperium_self.addMove("quash\t"+agenda_to_quash+"\t"+"1"); // 1 = re-deal
              imperium_self.endTurn();
            });
          }

	  return 0;
        }
    });


    this.importActionCard('flank-speed1', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed2', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed3', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed4', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });



    this.importActionCard('propulsion-research', {
  	name : "Propulsion Research" ,
  	type : "instant" ,
  	text : "Gain +1 movement on a single ship moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_ship_move_bonus = 1;
	  return 1;
	}
    });




    this.importActionCard('military-drills', {
  	name : "Military Drills" ,
  	type : "action" ,
  	text : "ACTION: Gain two new command tokens" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    imperium_self.playerAllocateNewTokens(action_card_player, 2);
	  }
	  return 0;
	}
    });



    this.importActionCard('cripple-defenses', {
  	name : "Cripple Defenses" ,
  	type : "action" ,
  	text : "ACTION: Select a planet and destroy all PDS units on that planet" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet to destroy all PDS units on that planet: ",
              function(planet) {
		return imperium_self.doesPlanetHavePDS(planet);
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
		let tile = planet.tile;	        
		let planet_idx = planet.idx;
		let sys = imperium_self.returnSectorAndPlanets(sector);

		for (let b = 0; b < sys.p[planet_idx].units.length; b++) {
		  for (let bb = 0; bb < sys.p[planet_idx].units[b].length; bb++) {
		    if (sys.p[planet_idx].units[b][bb].type == "pds") {
		      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+(b+1)+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+bb+"\t"+"1");
		    }
                  }
                }

		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys all PDS units destroyed on "+sys.p[planet_idx].name);
		imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('reactor-meltdown', {
  	name : "Reactor Meltdown" ,
  	type : "action" ,
  	text : "ACTION: Select a non-homeworld planet and destroy one Space Dock on that planet" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a non-homeworld planet and destroy one Space Dock on that planet: " ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
	        if (planet.hw == 0 && imperium_self.doesPlanetHaveSpaceDock(planet)) {
		  return 1;
		}
              },
	      function(planet) {
		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
		let tile = planet.tile;	        
		let planet_idx = planet.idx;
		let sys = imperium_self.returnSectorAndPlanets(sector);

		for (let b = 0; b < sys.p[planet_idx].units.length; b++) {
		  for (let bb = 0; bb < sys.p[planet_idx].units[b].length; bb++) {
		    if (sys.p[planet_idx].units[b][bb].type == "spacedock") {
		      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+(b+1)+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+bb+"\t"+"1");
		    }
                  }
                }

		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys all Space Docks on "+sys.p[planet_idx].name);
		imperium_self.endTurn();
		return 0;

	      },
	      // cancel -- no space dock available?
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('lost-mission', {
  	name : "Lost Mission" ,
  	type : "action" ,
  	text : "ACTION: Place 1 Destroyer in a system with no existing ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector with no existing ships in which to place a Destroyer: ",
              function(sector) {
		return !imperium_self.doesSectorContainShips(sector);
              },
	      function(sector) {

                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdestroyer\t"+sector);
                imperium_self.addMove("NOTIFY\tAdding destroyer to gamebaord");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });

    this.importActionCard('accidental-colonization', {
  	name : "Accidental Colonization" ,
  	type : "action" ,
  	text : "ACTION: Gain control of one planet not controlled by any player" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet not controlled by another player: ",
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner == -1) { return 1; } return 0;
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
                imperium_self.addMove("gain_planet\t"+imperium_self.game.player+"\t"+sector+"\t"+planet.idx);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " gains planet " + planet.name);
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('uprising', {
  	name : "Uprising" ,
  	type : "action" ,
  	text : "ACTION: Exhaust a non-home planet card held by another player. Gain trade goods equal to resource value." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Exhaust a non-homeworld planet card held by another player. Gain trade goods equal to resource value." ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner != -1 && planet.owner != imperium_self.game.player && planet.exhausted == 0 && planet.hw == 0) { return 1; } return 0;
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let goods = planet.resources;

                imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+goods);
                imperium_self.addMove("expend\t"+imperium_self.game.player+"\tplanet\t"+planet.planet);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " exhausting "+planet.name + " and gaining " + goods + " trade goods");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });



    this.importActionCard('diaspora-conflict', {
  	name : "Diaspora Conflict" ,
  	type : "action" ,
  	text : "ACTION: Exhaust a non-home planet card held by another player. Gain trade goods equal to resource value." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Exhaust a planet card held by another player. Gain trade goods equal to resource value." ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner != -1 && planet.owner != imperium_self.game.player && planet.exhausted == 0 && planet.hw ==0) { return 1; } return 0;
              },
	      function(planet) {

	        let planetname = planet;
		planet = imperium_self.game.planets[planet];
		let goods = planet.resources;

                imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+goods);
                imperium_self.addMove("expend\t"+imperium_self.game.player+"\tplanet\t"+planetname);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " exhausting "+planet.name + " and gaining " + goods + " trade goods");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });



    this.importActionCard('economic-initiative', {
  	name : "Economic Initiative" ,
  	type : "action" ,
  	text : "ACTION: Ready each cultural planet in your control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      if (imperium_self.game.planets[i].type == "cultural") {
		imperium_self.game.planets[i].exhausted = 0;
	      }
	    }
	  }
	  return 1;
	}
    });


    this.importActionCard('focused-research', {
  	name : "Focused Research" ,
  	type : "action" ,
  	text : "ACTION: Spend 4 Trade Goods to Research 1 Technology" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let p = imperium_self.game.players_info[imperium_self.game.player-1];

	  if (p.goods < 4) {
	    imperium_self.updateLog("Player does not have enough trade goods to research a technology");
	    return 1;
	  }

	  //
	  // otherwise go for it
	  //
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerResearchTechnology(function(tech) {
              imperium_self.addMove("purchase\t"+imperium_self.game.player+"\ttech\t"+tech);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tgoods\t4");
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " researches " + imperium_self.tech[tech].name);
              imperium_self.endTurn();
	    });

	  }
	  return 0;
	}
    });



    this.importActionCard('frontline-deployment', {
  	name : "Frontline Deployment" ,
  	type : "action" ,
  	text : "ACTION: Deploy three infantry on one planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
              "Deploy three infantry to a planet you control: ",
              function(planet) {
                if (imperium_self.game.planets[planet].owner == imperium_self.game.player) { return 1; } return 0;
              },
              function(planet) {
		planet = imperium_self.game.planets[planet];
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys three infantry to " + planet.name);
                imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
	}
    });



    this.importActionCard('ghost-ship', {
  	name : "Ghost Ship" ,
  	type : "action" ,
  	text : "ACTION: Place a destroyer in a sector with a wormhole and no enemy ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {
            imperium_self.playerSelectSectorWithFilter(
              "Place a destroyer in a sector with a wormhole and no enemy ships: " ,
              function(sector) {
                if (imperium_self.doesSectorContainShips(sector) == 0 && imperium_self.game.sectors[sector].wormhole != 0) { return 1; } return 0;
              },
              function(sector) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+"-1"+"\t"+"destroyer"+"\t"+sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys a Destroyer to " + imperium_self.game.sectors[sector].name);
               imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
        }
    });



    this.importActionCard('war-effort', {
  	name : "War Effort" ,
  	type : "action" ,
  	text : "ACTION: Place a cruiser in a sector with one of your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
              "Place a cruiser in a sector with one of your ships: " ,
              function(sector) {
                if (imperium_self.doesSectorContainPlayerShips(player, sector) == 1) { return 1; } return 0;
              },
              function(sector) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+"-1"+"\t"+"cruiser"+"\t"+sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys a Cruiser to " + imperium_self.game.sectors[sector].name);
                imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
        }
    });





    this.importActionCard('industrial-initiative', {
  	name : "Industrial Initiative" ,
  	type : "action" ,
  	text : "ACTION: Gain a trade good for each industrial planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let trade_goods_to_gain = 0;

	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      if (imperium_self.game.planets[i].type == "industrial") {
		trade_goods_to_gain++;
	      }
	    }
	  }

	  if (trade_goods_to_gain > 0 ) {
            imperium_self.game.queue.push("purchase\t"+imperium_self.game.player+"\tgoods\t"+trade_goods_to_gain);
	  }

	  return 1;
	}
    });




    this.importActionCard('Insubordination', {
  	name : "Insubordination" ,
  	type : "action" ,
  	text : "ACTION: Select a player and remove 1 token from their command pool" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player and remove one token from their command pool: " ,
              function(player) {
	        if (player != imperium_self.game.player) { return 1; } return 0;
              },
	      function(player) {
                imperium_self.addMove("expend\t"+player+"\tcommand\t"+"1");
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFactionNickname(player) + " loses one comand token");
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
        }
    });




    this.importActionCard('Lucky Shot', {
  	name : "Lucky Shot" ,
  	type : "action" ,
  	text : "ACTION: Destroy a destroyer, cruiser or dreadnaught in a sector with a planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Destroy a destroyer, cruiser or dreadnaught in a sector containing a planet you control: " ,
              function(sector) {
  		if (imperium_self.doesSectorContainPlanetOwnedByPlayer(sector, imperium_self.game.player)) {
  		  if (imperium_self.doesSectorContainUnit(sector, "destroyer") || imperium_self.doesSectorContainUnit(sector, "cruiser") || imperium_self.doesSectorContainUnit(sector, "dreadnaught")) {
		    return 1;
		  }
		}
		return 0;
              },
	      function(sector) {

                imperium_self.playerSelectUnitInSectorWithFilter(
	          "Select a ship in this sector to destroy: " ,
		  sector,
                  function(unit) {
		    if (unit.type == "destroyer") { return 1; }
		    if (unit.type == "cruiser") { return 1; }
		    if (unit.type == "dreadnaught") { return 1; }
		    return 0;
                  },
	          function(unit_info) {

		    let s = unit_info.sector;
		    let p = parseInt(unit_info.unit.owner);
		    let uidx = unit_info.unit_idx;

		    let sys = imperium_self.returnSectorAndPlanets(s);
		    let unit_to_destroy = unit_info.unit;

                    imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+unit_to_destroy.owner+"\t"+"space"+"\t"+s+"\t"+"-1"+"\t"+uidx+"\t"+"1");
		    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit_to_destroy.name + " in " + sys.name);
		    imperium_self.endTurn();
		    return 0;
	          },
	          null
	        );
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
        }
    });





    this.importActionCard('mining-initiative-ac', {
  	name : "Mining Initiative" ,
  	type : "action" ,
  	text : "ACTION: Gain trade goods equal to the highest resource value planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

   	    let maximum_resources = 0;
	    for (let i in imperium_self.game.planets) {
	      if (imperium_self.game.planets[i].owner == action_card_player && imperium_self.game.planets[i].resources > maximum_resources) {
		maximum_resources = imperium_self.game.planets[i].resources;
	      }
	    }

            imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+maximum_resources);
            imperium_self.endTurn();
	    return 0;

	  }
	  return 0;
	}
    });




    this.importActionCard('rise-of-a-messiah', {
  	name : "Rise of a Messiah" ,
  	type : "action" ,
  	text : "ACTION: Add one infantry to each planet player controls" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " adds 1 infantry to " + imperium_self.game.planets[i].name);
	      imperium_self.addPlanetaryUnit(action_card_player, imperium_self.game.planets[i].sector, imperium_self.game.planets[i].idx, "infantry");
	    }
	  }
	  return 1;
	}
    });



    this.importActionCard('unstable-planet', {
  	name : "Unstable Planet" ,
  	type : "action" ,
  	text : "ACTION: Choose a hazardous planet and exhaust it. Destroy 3 infantry on that planet if they exist" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a hazardous planet and exhaust it. Destroy 3 infantry on that planet if they exist" ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
	        if (planet.type == "hazardous") { return 1; } return 0;
              },
	      function(planet) {
                imperium_self.addMove("expend\t"+player+"\tplanet\t"+planet);

		let planet_obj   = imperium_self.game.planets[planet];	
		let planet_owner = parseInt(planet_obj.owner);
		let planet_res   = parseInt(planet_obj.resources);

		let infantry_destroyed = 0;

		if (planet_owner >= 0) {
		  for (let i = 0; i < planet_obj.units[planet_owner-1].length; i++) {
		    if (infantry_destroyed < 3) {
		      if (planet_obj.units[planet_owner-1][i].type == "infantry") {
		        imperium_self.addMove("destroy_unit\t"+action_card_player+"\t"+planet_owner+"\t"+"ground"+"\t"+planet_obj.sector+"\t"+planet_obj.idx+"\t"+"1");
		    	infantry_destroyed++;
		      }
		    }
		  }
		}
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });






    this.importActionCard('Covert Operation', {
  	name : "Covert Operation" ,
  	type : "action" ,
  	text : "ACTION: Choose a player. They give you one of their action cards, if possible" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player. They give you one of their action cards: ",
              function(player) {
	        if (player != imperium_self.game.player) { return 1; } return 0;
              },
	      function(player) {
                imperium_self.addMove("pull\t"+imperium_self.game.player+"\t"+player+"\t"+"action"+"\t"+"random");
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " pulls a random action card from " + imperium_self.returnFaction(player));
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('tactical-bombardment', {
  	name : "Tactical Bombardment" ,
  	type : "action" ,
  	text : "ACTION: Choose a sector in which you have ships with bombardment. Exhaust all planets in that sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector in which you have ships with bombardment. Exhaust all planets in that sector" ,
              function(sector) {
	        if (imperium_self.doesSectorContainPlayerUnit(player, sector, "dreadnaught") == 1) { return 1; }
	        if (imperium_self.doesSectorContainPlayerUnit(player, sector, "warsun") == 1) { return 1; }
		return 0;
              },

	      function(sector) {

		let planets_in_sector = imperium_self.game.sectors[sector].planets;
		for (let i = 0; i < planets_in_sector.length; i++) {
                  imperium_self.addMove("expend\t"+player+"\tplanet\t"+planets_in_sector[i]);
		  imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " exhausts " + imperium_self.game.planets[planets_in_sector[i]].name);
		}
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('signal-jamming', {
  	name : "Signal Jamming" ,
  	type : "action" ,
  	text : "ACTION: Choose a player. They must activate a system in or next to a system in which you have a ship" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector in which you have a ship or one adjacent to one: ",
              function(sector) {
	        if (imperium_self.isPlayerShipAdjacentToSector(action_card_player, sector)) {
		  return 1;
		}
	        return 0;
              },
	      function(sector) {

            	imperium_self.playerSelectPlayerWithFilter(
	          "Select a player to signal jam in that sector: " ,
                  function(p) {
	            if (p != imperium_self.game.player) { return 1; } return 0;
                  },
	          function(p) {
                    imperium_self.addMove("activate\t"+p+"\t"+sector);
		    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(p) + " suffers signal jamming in " + imperium_self.game.sectors[sector].name);
		    imperium_self.endTurn();
		    return 0;
	          },
	          null
	        );
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('unexpected-action', {
  	name : "Unexpected Action" ,
  	type : "action" ,
  	text : "ACTION: Deactivate a stystem you have activated. Gain one command or strategy token: ", 
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector that you have activated and deactivate it: " ,
              function(sector) {
		if (imperium_self.game.sectors[sector].activated[action_card_player-1] == 1) {
		  return 1;
		}
              },
	      function(sector) {
                imperium_self.addMove("purchase\t"+action_card_player+"\tcommand\t"+"1");
                imperium_self.addMove("deactivate\t"+action_card_player+"\t"+sector);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " deactivates " + imperium_self.game.sectors[sector].name);
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('in-the-silence-of-space', {
  	name : "In the Silence of Space" ,
  	type : "instant" ,
  	text : "Your ships may move through sectors with other player ships this turn: " ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_move_through_sectors_with_opponent_ships = 1;
	  return 1;
	}
    });



    this.importActionCard('upgrade', {
  	name : "Upgrade" ,
  	type : "activate" ,
  	text : "After you activate a system containing one of your ships, place a Dreadnaught from your reinforcements in that sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let sector = imperium_self.game.state.activated_sector;
	  if (imperium_self.doesSectorContainPlayerShips(action_card_player, sector)) {
	    imperium_self.addSpaceUnit(action_card_player, sector, "dreadnaught");
	  }

	  return 1;
	}
    });



    this.importActionCard('disable', {
  	name : "Disable" ,
  	type : "activate" ,
  	text : "Your fleet cannot be hit by PDS fire or Planetary Defense during this invasion" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_immune_to_pds_fire = 1;
	  imperium_self.game.players_info[action_card_player-1].temporary_immune_to_planetary_defense = 1;
	  return 1;
	}
    });





    this.importActionCard('bunker', {
  	name : "Bunker" ,
  	type : "bombardment_defender" ,
  	text : "During this bombardment, attacker gets -4 applied to each bombardment roll." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_bombardment_combat_roll_modifier = -4;
	  }
	  return 1;
	}
    });


    this.importActionCard('thunder-from-the-heavens', {
  	name : "Thunder from the Heavens" ,
  	type : "bombardment_attacker" ,
  	text : "During this bombardment, attacker gets +2 applied to each bombardment roll." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_bombardment_combat_roll_modifier = 2;
	  }
	  return 1;
	}
    });




    this.importActionCard('sabotage1', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage2', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage3', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage4', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });



    this.importActionCard('fire-team', {
  	name : "Fire Team" ,
  	type : "ground_combat" ,
  	text : "Reroll up to 15 dice during this round of ground combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].combat_dice_reroll = 15; // 15 
	  return 1;

	}
    });


    this.importActionCard('parley', {
  	name : "Parley" ,
  	type : "ground_combat" ,
  	text : "Return invading infantry to space if player ships exist in the sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	
	  if (player == action_card_player) {

	    let sector = imperium_self.game.state.ground_combat_sector;
	    let planet_idx = imperium_self.game.state.ground_combat_planet_idx;
	    let attacker = imperium_self.game.state.ground_combat_attacker;

	    let sys = imperium_self.returnSectorAndPlanets(sector);

	    let attacker_infantry = sys.p[planet_idx].units[attacker-1];
	    sys.p[planet_idx].units[attacker-1] = [];;

	    for (let i = 0; i < sys.s.units[attacker-1].length; i++) {
	      while (imperium_self.returnRemainingCapacity(sys.s.units[attacker-1][i]) > 0 && attacker_infantry.length > 0) {
		imperium_self.loadUnitByJSONOntoShip(attacker, sector, i, JSON.stringify(attacker_infantry[0]));
	        attacker_infantry.splice(0, 1);
	      }
	    }

	  }

	  imperium_self.updateSectorGraphics(sector);
	  return 1;

	}

    });




/*****
    this.importActionCard('confusing-legal-text', {
  	name : "Confusing Legal Text" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his votes, pick another player to win if you are the leading candidate" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

//	    imperium_self.game.state.votes_cast[bribing_player-1].votes += goods_spent;

	  if (imperium_self.agenda_cards[card].elect === "player") {

            let winning_options = [];
            for (let i = 0; i < imperium_self.game.state.choices.length; i++) {
              winning_options.push(0);
            }
            for (let i = 0; i < imperium_self.game.players.length; i++) {
              winning_options[imperium_self.game.state.how_voted_on_agenda[i]] += imperium_self.game.state.votes_cast[i];
            }

            //
            // determine winning option
            //
            let max_votes_options = -1;
            let max_votes_options_idx = 0;
            for (let i = 0; i < winning_options.length; i++) {
              if (winning_options[i] > max_votes_options) {
                max_votes_options = winning_options[i];
                max_votes_options_idx = i;
              }
            }

            let total_options_at_winning_strength = 0;
            for (let i = 0; i < winning_options.length; i++) {
              if (winning_options[i] == max_votes_options) { total_options_at_winning_strength++; }
            }

	    if (total_options_at_winning_strength == 1) {

	      //
	      // cast 1000 votes for someone else
	      //
	      if (imperium_self.game.player == action_card_player) { 
                html = '<div class="sf-readable">Who do you wish to be elected instead? </div><ul>';
	        for (let i = 0; i < imperium_self.game.state.choices.length; i++) {
		  if (imperium_self.game.state.choices[i] != imperium_self.game.player) {
		    html += '<li class="options textchoice" id="'+imperium_self.game.state.choices[i]+'">'+imperium_self.returnFaction(imperium_self.game.state.choices[i])+'</li>';
		  }
	        }
		html += '</ul>';
	      }

      	      $('.textchoice').off();
	      $('.textchoice').on('click', function() {

		let action = $(this).attr("id");

		imperium_self.addMove("vote\t"+imperium_self.returnActiveAgenda()+"\t"+action+"\t"+"1000");
		imperium_self.endTurn();
		return 0;

	      });
	
	      return 0;
	    } else {
	      return 1;
	    }
	  }
	  return 1;
	}
    });
****/


    this.importActionCard('distinguished-councillor', {
  	name : "Distinguished Coucillor" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his votes, cast an additional 5 votes" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          imperium_self.game.state.votes_cast[action_card_player-1] += 5;
	  imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " casts an additional 5 votes with Distinguished Councillor");

	  return 1;

	}
    });


    this.importActionCard('bribery', {
  	name : "Bribery" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his vote, spend any number of trade goods to purchase the same number of additional voutes" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

	    let html  = '<div class="sf-readable">Spend any number of trade goods to purchase additional votes: </div><ul>';
	    if (imperium_self.game.players_info[action_card_player-1].goods > 0) {
	      html   += '<li class="textchoice" id="0">0 votes</li>';
	      for (let i = 1; i <= imperium_self.game.players_info[action_card_player-1].goods+1; i++) {
	        if (i == 1) { html   += '<li class="textchoice" id="1">'+i+' vote</li>'; }
	        else { html   += '<li class="textchoice" id="'+i+'">'+i+' votes</li>'; }
	      }
	    } else {
	      html   += '<li class="textchoice" id="0">0 votes</li>';
            }
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.textchoice').off();
	    $('.textchoice').on('click', function() {

	      let action = $(this).attr("id");

	      imperium_self.addMove("bribery\t"+action_card_player+"\t"+action);
	      imperium_self.endTurn();
	    });

	  }

	  return 0;

	},
	handleGameLoop : function(imperium_self, qe, mv) {

	  if (mv[0] == "bribery") {

	    let bribing_player = parseInt(mv[1]);
	    let goods_spent = parseInt(mv[2]);
	    imperium_self.game.queue.splice(qe, 1);

	    imperium_self.game.state.votes_cast[bribing_player-1].votes += goods_spent;
	    imperium_self.game.players_info[bribing_player-1].goods -= goods_spent;
	    if (goods_spent == 1) {
	      imperium_self.updateLog(imperium_self.returnFaction(bribing_player) + " bribes the Council for " + goods_spent + " additional vote");
	    } else {
	      imperium_self.updateLog(imperium_self.returnFaction(bribing_player) + " bribes the Council for " + goods_spent + " additional votes");
	    }

	    return 1;
	  }

	  return 1;

	}
    });






    //
    // invisible and unwinnable rider attached to prevent voting
    //
    this.importActionCard('assassinate-representative', {
  	name : "Assassinate Representative" ,
  	type : "pre_agenda" ,
  	text : "Choose a player. That player cannot vote on the Agenda" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectPlayerWithFilter(
              "Select a player who will not be able to vote on this Agenda: " ,
              function(player) {
                if (player != imperium_self.game.player) { return 1; } return 0;
              },
              function(player) {
                imperium_self.addMove("rider\t"+player+"\tassassinate-representative\t-1");
                //imperium_self.addMove("assassinate_representative\t"+imperium_self.game.player+"\t"+player);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " assassinates the voting representative of " + imperium_self.returnFaction(player));
                imperium_self.endTurn();
                return 0;
              },
              null,
            );
	  }
	  return 0;
        },
    });




    this.importActionCard('ancient-burial-sites', {
  	name : "Ancient Burial Sites" ,
  	type : "pre_agenda" ,
  	text : "Chose a player. That player loses a maximum of four votes on this agenda" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectPlayerWithFilter(
              "Select a player to lose 4 votes: " ,
              function(player) {
                if (player != imperium_self.game.player) { return 1; } return 0;
              },
              function(player) {
                imperium_self.addMove("ancient_burial\t"+imperium_self.game.player+"\t"+player);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " finds soe dirt on the voting representative of " + imperium_self.returnFaction(player));
                imperium_self.endTurn();
                return 0;
              },
              null,
            );
	  }
	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "ancient_burial") {

            let player = parseInt(mv[1]);
            let target = parseInt(mv[2]);
            imperium_self.game.queue.splice(qe, 1);

            imperium_self.game.state.votes_available[target-1] -= 4;
            if (imperium_self.game.state.votes_available[target-1] < 0) { 
              imperium_self.game.state.votes_available[target-1] = 0;
            }

            return 1;
          }

	  return 1;
        }

    });







    this.importActionCard('leadership-rider', {
  	name : "Leadership Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to gain two strategy tokens and 1 command token" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
            let msg  = 'On which choice do you wish to place your Leadership rider?';
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"diplomacy-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium.self.game.player)+" has placed a Leadership Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
          imperium_self.game.players_info[action_card_player-1].strategy_tokens += 2;
          imperium_self.game.players_info[action_card_player-1].command_tokens += 1;
	  imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " gains 2 strategy tokens and 1 command token");
	  return 1;
	}
    });






    this.importActionCard('diplomacy-rider', {
  	name : "Diplomacy Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to have others activate system with planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg  = 'On which choice do you wish to place your Diplomacy rider?';
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"diplomacy-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Diplomacy Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {

	  //
	  // rider is executed
	  //
	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectSectorWithFilter(
              "Select a sector with a planet you control to mire in diplomatic conflict: ",
              function(sector) {
		for (let i = 0; i < imperium_self.game.sectors[sector].planets.length; i++) {
  		  if (imperium_self.game.planets[imperium_self.game.sectors[sector].planets[i]].owner == imperium_self.game.player) { return 1; } return 0;
                }
              },
              function(sector) {
                for (let b = 0; b < imperium_self.game.players_info.length; b++) {
                  imperium_self.addMove("activate\t"+(b+1)+"\t"+sector);
                }
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFactionNickname(imperium_self.game.player) + " uses Diplomacy Rider to protect " + sector);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	  }
	  return 0;
	}
    });





    this.importActionCard('politics-rider', {
  	name : "Politics Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to gain three action cards and the speaker token" ,
        playActionCard : function(imperium_self, player, action_card_player, card) {
          if (imperium_self.game.player == action_card_player) {
            let active_agenda = imperium_self.returnActiveAgenda();
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;
            let msg  = 'On which choice do you wish to place your Politics rider?';
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"politics-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Politics Rider on "+choices[choice]);
              imperium_self.endTurn();
            });
          }
          return 0;
        },
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	
	  if (imperium_self.game.player == action_card_player) {

	    // three action cards
            imperium_self.addMove("gain\t"+imperium_self.game.player+"\taction_cards\t3");
            imperium_self.addMove("DEAL\t2\t"+imperium_self.game.player+"\t3");
            imperium_self.addMove("NOTIFY\tdealing two action cards to player "+player);

	    // and change speaker
	    let html = 'Make which player the speaker? <ul>';
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              html += '<li class="textchoice" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
            }
            html += '</ul>';
            imperium_self.updateStatus(html);

            let chancellor = imperium_self.game.player;

            $('.textchoice').off();
            $('.textchoice').on('click', function() {
              let chancellor = (parseInt($(this).attr("id")) + 1);
	      imperium_self.addMove("change_speaker\t"+chancellor);
	      imperium_self.endTurn();
	    });
	  } 

 	  return 0;
	}
    });




    this.importActionCard('construction-rider', {
  	name : "Construction Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to place a space dock on a planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (action_card_player == imperium_self.game.player) {

            let active_agenda = imperium_self.returnActiveAgenda();
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg = 'On which choice do you wish to place the Construction rider?';
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"construction-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Construction Rider on "+choices[choice]);
              imperium_self.endTurn();
            });

	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	  if (action_card_player == imperium_self.game.player) {
            imperium_self.playerSelectPlanetWithFilter(
              "Select a planet you control without a Space Dock: ",
              function(planet) {
  		if (imperium_self.game.planets[planet].owner == imperium_self.game.player && imperium_self.doesPlanetHaveSpaceDock(planet) == 0) { return 1; } return 0;
              },
              function(planet) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t"+imperium_self.game.planets[planet].idx+"\t"+"spacedock"+"\t"+imperium_self.game.planets[planet].sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " builds a Space Dock in " + imperium_self.game.sectors[imperium_self.game.planets[planet].sector].name);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	  }
	  return 0;
	}
    });



    this.importActionCard('trade-rider', {
  	name : "Trade Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to receive 5 trade goods" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();

            let html  = 'On which choice do you wish to place your Trade rider?';
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
	    imperium_self.playerSelectChoice(html, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"trade-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Trade Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
 
 	  return 0;
	},
	playActionCardEvent(imperium_self, player, action_card_player, card) {
	  imperium_self.game.queue.push("purchase\t"+action_card_player+"\t"+"goods"+"\t"+5);
	  imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " gains 5 Trade Goods through their Trade Rider");
	  return 1;
	}
    });




    this.importActionCard('warfare-rider', {
  	name : "Warfare Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to place a dreadnaught in a system with one of your ships: " ,
        playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            let active_agenda = imperium_self.returnActiveAgenda();

            let msg  = 'On which choice do you wish to place your Warfare Rider?';
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"warfare-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Warfare Rider on "+choices[choice]);
              imperium_self.endTurn();
            });
          }

          return 0;
        },
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
              "Select a sector which contains at least one of your ships: ",
              function(sector) {
                return imperium_self.doesSectorContainPlayerShips(action_card_player, sector);
              },
              function(sector) {

                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdreadnaught\t"+sector);
                imperium_self.addMove("NOTIFY\tAdding dreadnaught to board");
                imperium_self.endTurn();
                return 0;

              },
              null
            );
          }
	  return 0;
	}
    });


    this.importActionCard('technology-rider', {
  	name : "Technology Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to research a technology for free" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();

            let msg  = 'On which choice do you wish to place your Technology rider?';
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"technology-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Technology Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
 
 	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    imperium_self.playerResearchTechnology(function(tech) {
	      imperium_self.endTurn();
	    });
	  } 
 	  return 0;
	}
    });


    this.importActionCard('imperial-rider', {
  	name : "Imperial Rider" ,
  	type : "rider" ,
  	text : "Player gains 1 VP" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg = 'On which choice do you wish to place the Imperial rider?';	
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"imperial-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed an Imperial Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });

	  }

	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
          imperium_self.game.players_info[action_card_player-1].vp += 1;
          imperium_self.game.players_info[action_card_player-1].objectives_scored.push("imperial-rider");
	  return 1;
	}
    });







    this.importActionCard('intercept', {
  	name : "Intercept" ,
  	type : "retreat" ,
  	text : "After your opponent declares a retreat in space combat, they cannot retreat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  imperium_self.game.players[action_card_player-1].temporary_opponent_cannot_retreat = 1;
	  return 1;

        }
    });





    this.importActionCard('courageous-to-the-end', {
  	name : "Courageous to the End" ,
  	type : "space_combat_after" ,
  	text : "For one ship lost in last round of space combat, fire twice. With each hit your opponent must destroy a ship of their chosing" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round.length > 0) {

	    let lowest_combat_roll_ship = 10;
	    for (let i = 0; i < imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round[i]; i++) {
	      let unittype = imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round[i];
	      let unit = imperium_self.returnUnit(unittype, player);
	      if (unit.combat < lowest_combat_roll_ship) { lowest_combat_roll_ship = unit.combat; }
	    }

	    let roll1 = imperium_self.rollDice(10);
	    let roll2 = imperium_self.rollDice(10);

	    let counterparty = imperium_self.game.state.space_combat_attacker;
	    if (counterparty == player) { counterparty = imperium_self.game.state.space_combat_defender; }

	    let total_ships_to_destroy = 0;

	    if (roll1 >= lowest_combat_roll_ship) {
	      total_ships_to_destroy++;
	    }
	    if (roll2 >= lowest_combat_roll_ship) {
	      total_ships_to_destroy++;
	    }

	    if (imperium_self.game.player == action_card_player) {
	      imperium_self.addMove("player_destroy_unit"+"\t"+player+"\t"+counterparty+"\t"+total_ships_to_destroy+"\t"+"space"+"\t"+imperium_self.game.state.space_combat_sector+"\t"+0);
	      imperium_self.endTurn();
	    }

	    return 0;

	  }

	  return 1;
        }
    });




    this.importActionCard('salvage', {
  	name : "Salvage" ,
  	type : "space_combat_victory" ,
  	text : "If you win a space combat, opponent gives you all their commodities" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (player == action_card_player) {

  	    let a = imperium_self.game.players_info[imperium_self.game.state.space_combat_attacker];
	    let d = imperium_self.game.players_info[imperium_self.game.state.space_combat_defender];


	    if (d.commodities > 0) {
	      a.goods += d.commodities;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.space_combat_attacker) + " takes " + d.commodities + " in trade goods from commodities lost in combat");
	      d.commodities = 0;
	    }
	  
	    return 1;
	  }
        }
    });



    this.importActionCard('shields-holding1', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding2', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding3', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding4', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });


    this.importActionCard('maneuvering-jets1', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets2', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets3', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets4', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });



    this.importActionCard('emergency-repairs', {
  	name : "Emergency Repairs" ,
  	type : "assign_hits" ,
  	text : "Repair all damaged ships not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // repairs all non-full-strength units for the action_card_player
	  //
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let i = 0; i < sys.s.units[action_card_player-1].length; i++) {
	    if (sys.s.units[action_card_player-1][i].strength < sys.s.units[action_card_player-1][i].max_strength) {
	      sys.s.units[action_card_player-1][i].strength = sys.s.units[action_card_player-1][i].max_strength;
	    }
	  }

	  return 1;

	}

    });

    this.importActionCard('experimental-fighter-prototype', {
  	name : "Experimental Fighter Prototype" ,
  	type : "space_combat" ,
  	text : "Your fighters get +2 on their combat rolls for a single round of space combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units[action_card_player-1].length; p++) {
            let unit = sys.s.units[action_card_player-1][p];
	    if (unit.type == "fighter") {
	      unit.temporary_combat_modifier += 2;
	    }
	  }

	  return 1;

	}

    });

    this.importActionCard('moral-boost', {
  	name : "Moral Boost" ,
  	type : "combat" ,
  	text : "Apply +1 to each of your units' combat rolls during this round of combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.state.space_combat_sector) {
            let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	    for (let i = 0; i < sys.s.units[action_card_player-1].length; i++) {
              let unit = sys.s.units[action_card_player-1][i];
	      unit.temporary_combat_modifier += 1;
	    }
	  }

	  if (imperium_self.game.state.ground_combat_sector) {
	    if (imperium_self.game.state.ground_combat_planet_idx) {
              let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	      for (let p = 0; i < sys.p.length; p++) {
	        for (let i = 0; i < sys.p[p].units[action_card_player-1].length; i++) {
                  let unit = sys.p[p].units[action_card_player-1][i];
	          unit.temporary_combat_modifier += 1;
	        }
	      }
	    }
	  }
	  return 1;
        }
    });



    this.importActionCard('experimental-battlestation', {
  	name : "Experimental Battlestation" ,
  	type : "pre_pds" ,
  	text : "After a player moves ships into a sector, a space dock in that or an adjacent sector can fire 3 PDS shots" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  imperium_self.updateLog("Experimental Battlestation");

	  let sector = imperium_self.game.state.activated_sector;
	  let adjacent_sectors = imperium_self.returnAdjacentSectors(sector);
	  adjacent_sectors.push(sector);

	  let has_experimental_battlestation = 0;

	  for (let n = 0; n < adjacent_sectors.length; n++) {
	    let sys = imperium_self.returnSectorAndPlanets(adjacent_sectors[n]);
	    for (let p = 0; p < sys.p.length; p++) {
	      if (sys.p[p].owner == imperium_self.game.player) {
  	        if (imperium_self.doesPlayerHaveSpaceDock(sys.p[p])) {
		  imperium_self.game.players_info[action_card_player-1].experimental_battlestation = sector;
		  return 1;
		}
	      }
	    }
	  }

	  return 1;
        }
    });










    this.importActionCard('direct-hit1', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit2', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit3', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit4', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });






    this.importActionCard('skilled-retreat1', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "skilled_retreat") {

            let player = parseInt(mv[1]);
            let destination = mv[2];
	    let source = mv[3];
            imperium_self.game.queue.splice(qe, 1);

	    let dsys = imperium_self.returnSectorAndPlanets(destination);
	    let ssys = imperium_self.returnSectorAndPlanets(source);

	    //
	    // move the units over
	    //
	    for (let i = 0; i < ssys.s.units[player-1].length; i++) {
	      dsys.s.units[player-1].push(ssys.s.units[player-1][i]);
	    }
	    ssys.s.units[player-1] = [];

	    imperium_self.saveSystemAndPlanets(dsys);
	    imperium_self.saveSystemAndPlanets(ssys);

	    //
	    // eliminate all commands down to "continue"
	    //
	    for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	      let tmpk = imperium_self.game.queue[i].split("\t");
	      if (tmpk[0] !== "continue") {
		imperium_self.game.queue.splice(i, 1);
	      } else {
		i = -1;
	      }
	    }


	    //
	    // update sector graphics
	    //
	    imperium_self.updateSectorGraphics(ssys.s.sector);
	    imperium_self.updateSectorGraphics(dsys.s.sector);

	    //
	    // handle fleet supply
	    //
	    return imperium_self.handleFleetSupply(player, destination);

          }

          return 1;
        }

    });
    this.importActionCard('skilled-retreat2', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });
    this.importActionCard('skilled-retreat3', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });
    this.importActionCard('skilled-retreat4', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });





    this.importActionCard('public-disgrace', {
  	name : "Public Disgrace" ,
  	type : "activate" ,
  	text : "Force a player who has already picked a strategy card to select another. They select before you do" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  // pick the player

	  // pick the strategy card

	  // insert the card into the strategy_cards list
	  return 0;

	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "public_disgrace") {

            let player = parseInt(mv[1]);
            let target = parseInt(mv[2]);
            let card   = mv[3];
            imperium_self.game.queue.splice(qe, 1);

	    for (let i = 0; i < imperium_self.game.players_info[target-1].strategy.length; i++) {
	      if (imperium_self.game.players_info[target-1].strategy[i] == card) {
		imperium_self.game.players_info[target-1].strategy.splice(i, 1);
	      }
	    }

	    imperium_self.game.queue.push("pickstrategy\t"+player);
	    imperium_self.game.queue.push("reinsert_strategy_card\t"+card);
	    imperium_self.game.queue.push("pickstrategy\t"+target);

	    return 1;

          }

	  if (mv[0] == "reinsert_strategy_card") {

	    let card = mv[1];

            imperium_self.game.state.strategy_cards.push(card);
            imperium_self.game.state.strategy_cards_bonus.push(0);

	    return 1;

	  }
    

          return 1;
        }

    });




returnPlayers(num = 0) {

  var players = [];

  let factions = JSON.parse(JSON.stringify(this.returnFactions()));

  for (let i = 0; i < num; i++) {

    if (i == 0) { col = "color1"; }
    if (i == 1) { col = "color2"; }
    if (i == 2) { col = "color3"; }
    if (i == 3) { col = "color4"; }
    if (i == 4) { col = "color5"; }
    if (i == 5) { col = "color6"; }

    var keys = Object.keys(factions);
    let rf = keys[this.rollDice(keys.length) - 1];

    if (i == 0) {
      if (this.game.options.player1 != undefined) {
        if (this.game.options.player1 != "random") {
          rf = this.game.options.player1;
        }
      }
    }
    if (i == 1) {
      if (this.game.options.player2 != undefined) {
        if (this.game.options.player2 != "random") {
          rf = this.game.options.player2;
        }
      }
    }
    if (i == 2) {
      if (this.game.options.player3 != undefined) {
        if (this.game.options.player3 != "random") {
          rf = this.game.options.player3;
        }
      }
    }
    if (i == 3) {
      if (this.game.options.player4 != undefined) {
        if (this.game.options.player4 != "random") {
          rf = this.game.options.player4;
        }
      }
    }
    if (i == 4) {
      if (this.game.options.player5 != undefined) {
        if (this.game.options.player5 != "random") {
          rf = this.game.options.player5;
        }
      }
    }
    if (i == 5) {
      if (this.game.options.player6 != undefined) {
        if (this.game.options.player6 != "random") {
          rf = this.game.options.player6;
        }
      }
    }

    delete factions[rf];


    players[i] = {};
    players[i].can_intervene_in_action_card = 0;
    players[i].secret_objectives_in_hand = 0;
    players[i].action_cards_in_hand = 0;
    players[i].action_cards_per_round = 1;
    players[i].action_card_limit = 7;
    players[i].action_cards_played = [];
    players[i].new_tokens_per_round = 2;
    players[i].command_tokens = 3;
    players[i].strategy_tokens = 2;
    players[i].fleet_supply = 3;
    players[i].fleet_supply_limit = 16;
    players[i].faction = rf;
    players[i].homeworld = "";
    players[i].color = col;
    players[i].goods = 0;
    players[i].commodities = 0;
    players[i].commodity_limit = 3;
    players[i].vp = 0;
    players[i].passed = 0;
    players[i].strategy_cards_played = [];
    players[i].strategy_cards_retained = [];
    players[i].cost_of_technology_primary = 6;
    players[i].cost_of_technology_secondary = 4;
    players[i].promissary_notes = [];

    //
    // unit limits
    //
    players[i].infantry_limit = 30;
    players[i].fighter_limit = 30;
    players[i].carrier_limit = 4;
    players[i].destroyer_limit = 8;
    players[i].cruiser_limit = 8;
    players[i].dreadnaught_limit = 5;
    players[i].flagship_limit = 1;
    players[i].warsun_limit = 2;
    players[i].pds_limit = 4;
    players[i].spacedock_limit = 3;


    players[i].traded_this_turn = 0;


    //
    // gameplay modifiers (action cards + tech)
    //
    players[i].new_token_bonus_when_issued = 0;
    players[i].action_cards_bonus_when_issued = 0;
    players[i].new_tokens_bonus_when_issued = 0;
    players[i].fleet_move_bonus = 0;
    players[i].temporary_fleet_move_bonus = 0;
    players[i].ship_move_bonus = 0;
    players[i].temporary_ship_move_bonus = 0;
    players[i].fly_through_asteroids = 0;
    players[i].fly_through_nebulas = 0;
    players[i].fly_through_supernovas = 0;
    players[i].move_into_supernovas = 0;
    players[i].reinforce_infantry_after_successful_ground_combat = 0;
    players[i].bacterial_weapon = 0;
    players[i].evasive_bonus_on_pds_shots = 0;
    players[i].perform_two_actions = 0;
    players[i].move_through_sectors_with_opponent_ships = 0;
    players[i].temporary_move_through_sectors_with_opponent_ships = 0;
    players[i].assign_pds_hits_to_non_fighters = 0;
    players[i].reallocate_four_infantry_per_round = 0;
    players[i].may_produce_after_gaining_planet = 0;
    players[i].extra_roll_on_bombardment_or_pds = 0;
    players[i].stasis_on_opponent_combat_first_round = 0;
    players[i].may_repair_damaged_ships_after_space_combat = 0;
    players[i].may_assign_first_round_combat_shot = 0;
    players[i].production_bonus = 0;
    players[i].may_player_produce_without_spacedock = 0;
    players[i].may_player_produce_without_spacedock_production_limit = 0;
    players[i].may_player_produce_without_spacedock_cost_limit = 0;
    players[i].may_produce_warsuns = 0;

    //
    // must target certain units when assigning hits, if possible
    //
    players[i].target_units = [];
    players[i].planets_conquered_this_turn = [];
    players[i].objectives_scored_this_round = [];
    players[i].must_exhaust_at_round_start = [];


    //
    // faction-inspired gameplay modifiers 
    //
    players[i].deep_space_conduits = 0; // treat all systems adjacent to activated system
    players[i].resupply_stations = 0; // gain trade goods on system activation if contains ships 
    players[i].turn_nullification = 0; // after player activates system with ships, can end turn ...

    //
    // roll modifiers
    //
    players[i].space_combat_roll_modifier = 0;
    players[i].ground_combat_roll_modifier = 0;
    players[i].pds_combat_roll_modifier = 0;
    players[i].bombardment_combat_roll_modifier = 0;
    players[i].space_combat_roll_bonus_shots = 0;
    players[i].ground_combat_roll_bonus_shots = 0;
    players[i].pds_combat_roll_bonus_shots = 0;
    players[i].bombardment_combat_roll_bonus_shots = 0;

    players[i].ground_combat_dice_reroll = 0;
    players[i].space_combat_dice_reroll = 0;
    players[i].pds_combat_dice_reroll = 0;
    players[i].bombardment_combat_dice_reroll = 0;
    players[i].combat_dice_reroll = 0;

    players[i].temporary_immune_to_pds_fire = 0;
    players[i].temporary_immune_to_planetary_defense = 0;

    players[i].temporary_space_combat_roll_modifier = 0;
    players[i].temporary_ground_combat_roll_modifier = 0;
    players[i].temporary_pds_combat_roll_modifier = 0;
    players[i].temporary_bombardment_combat_roll_modifier = 0;

    players[i].units_i_destroyed_this_combat_round = [];
    players[i].units_i_destroyed_last_combat_round = [];
    players[i].my_units_destroyed_this_combat_round = [];
    players[i].my_units_destroyed_last_combat_round = [];

    //
    // tech upgrades
    //
    players[i].temporary_green_tech_prerequisite = 0;
    players[i].temporary_yellow_tech_prerequisite = 0;
    players[i].temporary_red_tech_prerequisite = 0;
    players[i].temporary_blue_tech_prerequisite = 0;
    players[i].permanent_green_tech_prerequisite = 0;
    players[i].permanent_yellow_tech_prerequisite = 0;
    players[i].permanent_red_tech_prerequisite = 0;
    players[i].permanent_blue_tech_prerequisite = 0;
    players[i].temporary_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 0;
    players[i].permanent_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 0;
    players[i].temporary_infiltrate_infrastructure_on_invasion = 0;
    players[i].permanent_infiltrate_infrastructure_on_invasion = 0;
    players[i].temporary_opponent_cannot_retreat = 0;
    players[i].permanent_opponent_cannot_retreat = 0;
    players[i].permanent_research_technology_card_must_not_spend_resources = 0;

    if (i == 1) { players[i].color = "yellow"; }
    if (i == 2) { players[i].color = "green"; }
    if (i == 3) { players[i].color = "blue"; }
    if (i == 4) { players[i].color = "purple"; }
    if (i == 5) { players[i].color = "black"; }

    players[i].planets = [];
    players[i].tech = [];
    players[i].tech_exhausted_this_turn = [];
    players[i].upgrades = [];
    players[i].strategy = [];        // strategy cards  

    // scored objectives
    players[i].objectives_scored = [];


    // random
    players[i].lost_planet_this_round = -1; // is player to whom lost

  }

  return players;

}








playerTurn(stage = "main") {

  let html = '';
  let imperium_self = this;
  let technologies = this.returnTechnology();
  let relevant_action_cards = ["action", "main", "instant"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  this.updateLeaderboard();
  this.updateTokenDisplay();

  if (stage == "main") {

    let playercol = "player_color_" + this.game.player;

    let html = '';
    html += '<div class="terminal_header2 sf-readable"><div class="player_color_box ' + playercol + '"></div>' + this.returnFaction(this.game.player) + ":</div><p><ul class='terminal_header3'>";

    if (this.canPlayerPass(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 1) {
        //
        // if we have already moved, we end turn rather than pass
        //
        html += '<li class="option" id="endturn">end turn</li>';
      } else {
        //
        // otherwise we pass
        //
        html += '<li class="option" id="pass">pass</li>';
      }
    } else {
      if (this.game.state.active_player_moved == 1) {
        //
        // if we have already moved, we end turn rather than pass
        //
        html += '<li class="option" id="endturn">end turn</li>';
      }
    }

    if (this.game.state.round == 1 && this.game.state.active_player_moved == 0) {
      if (this.tutorial_move_clicked == 0) {
        html += '<li class="option" id="tutorial_move_ships">move ships</li>';
      }
      if (this.tutorial_produce_clicked == 0) {
        html += '<li class="option" id="tutorial_produce_units">produce units</li>';
      }
    }

    if (this.game.players_info[this.game.player - 1].command_tokens > 0) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="activate">activate sector</li>';
      }
    }
    if (this.canPlayerPlayStrategyCard(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="select_strategy_card">play strategy card</li>';
      }
    }
    if (ac.length > 0 && this.game.tracker.action_card == 0 && this.canPlayerPlayActionCard(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="action">play action card</li>';
      }
    }
    if (this.game.tracker.trade == 0 && this.canPlayerTrade(this.game.player) == 1) {
      html += '<li class="option" id="trade">trade</li>';
    }

    //
    // add tech and factional abilities
    //
    let tech_attach_menu_events = 0;
    let tech_attach_menu_triggers = [];
    let tech_attach_menu_index = [];
    let z = this.returnEventObjects();

    if (this.game.state.active_player_moved == 0) {
      for (let i = 0; i < z.length; i++) {
        if (z[i].menuOptionTriggers(this, "main", this.game.player) == 1) {
          let x = z[i].menuOption(this, "main", this.game.player);
          html += x.html;
          tech_attach_menu_index.push(i);
          tech_attach_menu_triggers.push(x.event);
          tech_attach_menu_events = 1;
        }
      }
    }



    html += '</ul></p>';

    this.updateStatus(html);

    $('.option').on('click', function () {

      let action2 = $(this).attr("id");

      //
      // respond to tech and factional abilities
      //
      if (tech_attach_menu_events == 1) {
        for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
          if (action2 == tech_attach_menu_triggers[i]) {
            $(this).remove();
            imperium_self.game.state.active_player_moved = 1;
            z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "main", imperium_self.game.player);
            return;
          }
        }
      }

      if (action2 == "activate") {
        imperium_self.playerActivateSystem();
      }

      if (action2 == "tutorial_move_ships") {
        imperium_self.tutorial_move_clicked = 1;
        imperium_self.playerAcknowledgeNotice("To move ships select \"activate sector\". Be careful as most ships can only move 1-hexagon and you cannot move ships from sectors that are already activated. You will be able to choose the ships to move, and load infantry and fighters into units that can carry them.", function () {
          imperium_self.playerTurn();
        });
        return;
      }
      if (action2 == "tutorial_produce_units") {
        imperium_self.tutorial_produce_clicked = 1;
        imperium_self.playerAcknowledgeNotice("To produce units, select \"activate sector\" and activate a sector with a space dock (like your home system). You can only have as many non-fighter ships in any sector as your fleet supply, so move your ships out before producing more!", function () {
          imperium_self.playerTurn();
        });
        return;
      }

      if (action2 == "select_strategy_card") {
        imperium_self.playerSelectStrategyCard(function (success) {
          imperium_self.game.state.active_player_moved = 1;
          imperium_self.addMove("strategy_card_after\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.addMove("strategy\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.addMove("strategy_card_before\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.endTurn();
        });
      }
      if (action2 == "action") {
        imperium_self.playerSelectActionCard(function (card) {
          if (imperium_self.action_cards[card].type == "action") { imperium_self.game.state.active_player_moved = 1; }
          imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
          imperium_self.endTurn();
        }, function () { imperium_self.playerTurn(); },
          relevant_action_cards);
      }
      if (action2 == "trade") {
        imperium_self.playerTrade();
        return 0;
      }
      if (action2 == "pass") {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
        imperium_self.addMove("pass\t" + imperium_self.game.player);
        imperium_self.endTurn();
      }
      if (action2 == "endturn") {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
        imperium_self.endTurn();
      }
    });
  }
}




playerPlayActionCardMenu(action_card_player, card, action_cards_played = []) {

  let imperium_self = this;
  let relevant_action_cards = ["counter"];

  for (let i = 0; i < this.game.deck[1].hand.length; i++) {
    if (this.game.deck[1].hand[i].indexOf("sabotage") > -1) {
      this.game.players_info[this.game.player - 1].can_intervene_in_action_card = 1;
    }
  }

  if (this.game.players_info[this.game.player - 1].can_intervene_in_action_card) {

    let html = '<div class="action_card_instructions_hud">' + this.returnFaction(action_card_player) + ' has played an action card:</div>';
    html += '<div class="action_card_name_hud">' + imperium_self.action_cards[card].name + '</div>';
    html += '<div class="action_card_text_hud">';
    html += this.action_cards[card].text;
    html += '</div>';
    html += '<ul>';

    let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);
    if (ac.length > 0) {
      html += '<li class="option" id="cont">continue</li>';
      html += '<li class="option" id="action">play action card</li>';
    } else {
      html += '<li class="option" id="cont">continue</li>';
    }

    let tech_attach_menu_events = 0;
    let tech_attach_menu_triggers = [];
    let tech_attach_menu_index = [];

    let z = this.returnEventObjects();
    for (let i = 0; i < z.length; i++) {
      if (z[i].menuOptionTriggers(this, "action_card", this.game.player) == 1) {
        let x = z[i].menuOption(this, "action_card", this.game.player);
        html += x.html;
        tech_attach_menu_index.push(i);
        tech_attach_menu_triggers.push(x.event);
        tech_attach_menu_events = 1;
      }
    }
    html += '</ul>';

    this.updateStatus(html);

    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");

      //
      // respond to tech and factional abilities
      //
      if (tech_attach_menu_events == 1) {
        for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
          if (action2 == tech_attach_menu_triggers[i]) {
            $(this).remove();
            z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "action_card", imperium_self.game.player);
          }
        }
      }

      if (action2 == "action") {
        imperium_self.playerSelectActionCard(function (card) {
          imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(card);
          imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
          imperium_self.playerPlayActionCardMenu(action_card_player, card);
        }, function () {
          imperium_self.playerPlayActionCardMenu(action_card_player, card);
        }, relevant_action_cards);
      }

      if (action2 == "cont") {
        imperium_self.endTurn();
      }
      return 0;
    });

  } else {

    let notice = '<div class="action_card_instructions_hud">' + this.returnFaction(action_card_player) + ' has played an action card:</div>';
    notice += '<div class="action_card_name_hud">' + imperium_self.action_cards[card].name + '</div>';
    notice += '<div class="action_card_text_hud">';
    notice += this.action_cards[card].text;
    notice += '</div>';

    this.playerAcknowledgeNotice(notice, function () { imperium_self.endTurn(); });
    return 0;
  }

}





playerPlayBombardment(attacker, sector, planet_idx) {

  let imperium_self = this;

  this.game.state.bombardment_sector = sector;
  this.game.state.bombardment_planet_idx = planet_idx;

  let sys = imperium_self.returnSectorAndPlanets(sector);


  //
  // some laws prohibit bombardment against
  //
  if (this.game.state.bombardment_against_cultural_planets == 0 && sys.p[planet_idx].type == "cultural") {
    this.updateLog("Bombardment not possible against cultural planets. Skipping.");
    this.endTurn();
  }
  if (this.game.state.bombardment_against_industrial_planets == 0 && sys.p[planet_idx].type == "industrial") {
    this.updateLog("Bombardment not possible against industrial planets. Skipping.");
    this.endTurn();
  }
  if (this.game.state.bombardment_against_hazardous_planets == 0 && sys.p[planet_idx].type == "hazardous") {
    this.updateLog("Bombardment not possible against hazardous planets. Skipping.");
    this.endTurn();
  }
  //
  // no bombardment of my own planets (i.e. if parlay ends invasion)
  //
  if (sys.p[planet_idx].owner == imperium_self.game.player) {
    imperium_self.endTurn();
    return 0;
  }
  //
  // no bombardment of PDS-defended territories
  //
  if (this.doesPlanetHavePDS(sys.p[planet_idx])) {
    this.updateLog("Bombardment not possible against PDS-defended planets. Skipping.");
    imperium_self.endTurn();
    return 0;
  }

  html = '<div class="sf-readable">Do you wish to bombard ' + sys.p[planet_idx].name + '? </div><ul>';

  let ac = this.returnPlayerActionCards(this.game.player, ["pre_bombardment"]);
  if (ac.length > 0) {
    html += '<li class="option" id="bombard">bombard planet</li>';
    html += '<li class="option" id="action">play action card</li>';
    html += '<li class="option" id="skip">skip bombardment</li>';
  } else {
    html += '<li class="option" id="bombard">bombard planet</li>';
    html += '<li class="option" id="skip">skip bombardment</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pre_bombardment", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pre_bombardment", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pre_bombardment", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.game.players_info[this.game.player - 1].action_cards_played.push(card);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, function () {
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, ["pre_bombardment"]);
    }

    if (action2 == "bombard") {
      imperium_self.addMove("bombard\t" + imperium_self.game.player + "\t" + sector + "\t" + planet_idx);
      imperium_self.endTurn();
    }
    if (action2 == "skip") {
      imperium_self.endTurn();
    }
    return 0;
  });


}


playerAcknowledgeNotice(msg, mycallback) {

  let html = '<div class="sf-readable">' + msg + "</div><ul>";
  html += '<li class="textchoice" id="confirmit">I understand...</li>';
  html += '</ul></p>';

  this.updateStatus(html);

  try {
  $('.textchoice').off();
  $('.textchoice').on('click', function () { mycallback(); });
  } catch (err) {}

  return 0;

}

//
// assign hits to capital ships without triggering events or special abilities
//  -- this is used by special abilities that assign damage outside combat, where they
//  -- cannot be removed by normal factional abilities, etc.
//
 playerAssignHitsCapitalShips(player, sector, total_hits) {

  let imperium_self = this;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let total_targetted_units = 0;

  let targetted_units = ["destroyer","cruiser","carrier","dreadnaught","warsun","flagship"];

  html = '<div class="sf-readable">You must assign ' + total_hits + ' to your capital ships (if possible):</div><ul>';
  html += '<li class="option" id="assign">continue</li>';
  html += '</ul>';
  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "assign") {

      let sys = imperium_self.returnSectorAndPlanets(sector);

      let html = '';
      html += '<div class="sf-readable">Assign <div style="display:inline" id="total_hits_to_assign">' + total_hits + '</div> hits:</div>';
      html += '<ul>';

      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].destroyed == 0 && sys.s.units[imperium_self.game.player - 1][i].strength > 0) {

          let unit = sys.s.units[imperium_self.game.player - 1][i];
          maximum_assignable_hits++;
          if (targetted_units.includes(unit.type)) { total_targetted_units++; }
          html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name;
          if (unit.capacity >= 1) {
	    let fleet = '';
            let fighters = 0;
            let infantry = 0;
            for (let ii = 0; ii < sys.s.units[imperium_self.game.player-1][i].storage.length; ii++) {
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "infantry") {
                infantry++;
              }
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
                fighters++;
              }
            }
            if (infantry > 0 || fighters > 0) {
              fleet += ' ';
              if (infantry > 0) { fleet += infantry + "i"; }
              if (fighters > 0) {
                if (infantry > 0) { fleet += ", "; }
                fleet += fighters + "f";
              }
              fleet += ' ';
            }
	    html += fleet;
	  }
          if (unit.strength > 1) {
            maximum_assignable_hits += (unit.strength - 1);
            html += ' <div style="display:inline" id="player_ship_' + i + '_hits">(';
            for (let bb = 1; bb < unit.strength; bb++) { html += '*'; }
            html += ')';
	    html += '</div>'
          }
          html += '</li>';
        }

      }
      html += '</ul>';

      if (maximum_assignable_hits == 0) {
        imperium_self.endTurn();
        return 0;
      }

      imperium_self.updateStatus(html);

      $('.textchoice').off();
      $('.textchoice').on('click', function () {

        let ship_idx = $(this).attr("id");
        let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

        if (total_targetted_units > 0) {
          if (!targetted_units.includes(selected_unit.type)) {
            salert("You must first assign hits to the required unit types");
            return;
          } else {
            total_targetted_units--;
          }
        }

        imperium_self.addMove("assign_hit\t" + player + "\t" + player + "\t" + imperium_self.game.player + "\tship\t" + sector + "\t" + ship_idx + "\t0"); // last argument --> player should not assign again 


        total_hits--;
        hits_assigned++;

        $('#total_hits_to_assign').innerHTML = total_hits;

        if (selected_unit.strength > 1) {
          selected_unit.strength--;
          let ship_to_reduce = "#player_ship_" + ship_idx + '_hits';
          let rhtml = '';
          if (selected_unit.strength > 1) {
            html += '(';
            for (let bb = 1; bb < selected_unit.strength; bb++) {
              rhtml += '*';
            }
            rhtml += ')';
          }
          $(ship_to_reduce).html(rhtml);
        } else {
          selected_unit.strength = 0;
          selected_unit.destroyed = 0;
          $(this).remove();
        }

        //
        // we have assigned damage, so make sure sys is updated
        //
        imperium_self.saveSystemAndPlanets(sys);

        if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
          imperium_self.updateStatus("Notifying players of hits assignment...");
          imperium_self.endTurn();
          imperium_self.updateStatus("Hits taken...");
        }

      });
    }

  });

}



//
// assign hits to my forces
//
 playerAssignHits(attacker, defender, type, sector, details, total_hits, source = "") {

  let imperium_self = this;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let relevant_action_cards = ["assign_hits"];
  if (details == "pds") { relevant_action_cards = ["post_pds"]; }

  html = '<div class="sf-readable">You must assign ' + total_hits + ' to your fleet:</div><ul>';

  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);
  if (ac.length > 0) {
    html += '<li class="option" id="assign">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="assign">continue</li>';
  }

  let menu_type = "";
  if (details == "pds") { menu_type = "assign_hits_pds"; }
  if (menu_type == "" && type == "space") { menu_type = "assign_hits_space"; }
  if (type == "ground") { menu_type = "assign_hits_ground"; }
  if (type == "anti_fighter_barrage") { menu_type = "assign_hits_anti_fighter_barrage"; }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, menu_type, this.game.player) == 1) {
      let x = z[i].menuOption(this, menu_type, this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          let mytech = this.tech[imperium_self.game.players_info[imperium_self.game.player - 1].tech[tech_attach_menu_index]];
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, menu_type, imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove(imperium_self.game.state.assign_hits_queue_instruction);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
        imperium_self.updateStatus("playing action card before hits assignment");
      }, function () {
        imperium_self.playerAssignHits(attacker, defender, type, sector, details, total_hits, source);
      }, relevant_action_cards);
    }

    if (action2 == "assign") {

      if (imperium_self.game.state.assign_hits_to_cancel > 0) {
        total_hits -= imperium_self.game.state.assign_hits_to_cancel;
        if (total_hits < 0) { total_hits = 0; }
        if (total_hits == 0) {
          imperium_self.updateLog("NOTIFY\t" + imperium_self.returnFactionNickname(imperium_self.game.player) + " does not take any hits");
          imperium_self.endTurn();
          return 0;
        }
      }

      let sys = imperium_self.returnSectorAndPlanets(sector);

      let html = '';
      html += '<div class="sf-readable">Assign <div style="display:inline" id="total_hits_to_assign">' + total_hits + '</div> hits:</div>';
      html += '<ul>';

      let total_targetted_units = 0;
      let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;
      if (type == "anti_fighter_barrage") {
	//
	// overwrite
	//
	targetted_units = [	"fighter", "fighter", "fighter" , "fighter" , "fighter" , 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter" ];
      }

      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].destroyed == 0 && sys.s.units[imperium_self.game.player - 1][i].strength > 0) {

          let unit = sys.s.units[imperium_self.game.player - 1][i];
          maximum_assignable_hits++;
          if (targetted_units.includes(unit.type)) { total_targetted_units++; }
          html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name;
          if (unit.capacity >= 1) {
	    let fleet = '';
            let fighters = 0;
            let infantry = 0;
            for (let ii = 0; ii < sys.s.units[imperium_self.game.player-1][i].storage.length; ii++) {
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "infantry") {
                infantry++;
              }
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
                fighters++;
              }
            }
            if (infantry > 0 || fighters > 0) {
              fleet += ' ';
              if (infantry > 0) { fleet += infantry + "i"; }
              if (fighters > 0) {
                if (infantry > 0) { fleet += ", "; }
                fleet += fighters + "f";
              }
              fleet += ' ';
            }
	    html += fleet;
	  }
          if (unit.strength > 1) {
            maximum_assignable_hits += (unit.strength - 1);
            html += ' <div style="display:inline" id="player_ship_' + i + '_hits">(';
            for (let bb = 1; bb < unit.strength; bb++) { html += '*'; }
            html += ')';
	    html += '</div>'
          }
          html += '</li>';
        }

      }
      html += '</ul>';

      if (maximum_assignable_hits == 0) {
        console.log("ERROR: you had no hits left to assign, bug?");
        console.log("SHIPS: " + JSON.stringify(sys.s.units[imperium_self.game.player - 1]));
//        imperium_self.eliminateDestroyedUnitsInSector(imperium_self.game.player, sector);
//        imperium_self.saveSystemAndPlanets(sys);
//        imperium_self.updateSectorGraphics(sector);
        imperium_self.endTurn();
        return 0;
      }

      imperium_self.updateStatus(html);

      $('.textchoice').off();
      $('.textchoice').on('click', function () {

        let ship_idx = $(this).attr("id");
        let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

        if (total_targetted_units > 0) {
          if (!targetted_units.includes(selected_unit.type)) {
            salert("You must first assign hits to the required unit types");
            return;
          } else {
            total_targetted_units--;
          }
        }

        imperium_self.addMove("assign_hit\t" + attacker + "\t" + defender + "\t" + imperium_self.game.player + "\tship\t" + sector + "\t" + ship_idx + "\t0"); // last argument --> player should not assign again 

        total_hits--;
        hits_assigned++;

        $('#total_hits_to_assign').innerHTML = total_hits;

        if (selected_unit.strength > 1) {
          selected_unit.strength--;
          let ship_to_reduce = "#player_ship_" + ship_idx + '_hits';
          let rhtml = '';
          if (selected_unit.strength > 1) {
            html += '(';
            for (let bb = 1; bb < selected_unit.strength; bb++) {
              rhtml += '*';
            }
            rhtml += ')';
          }
          $(ship_to_reduce).html(rhtml);
        } else {
          selected_unit.strength = 0;
          selected_unit.destroyed = 0;
          $(this).remove();
        }

        //
        // we have assigned damage, so make sure sys is updated
        //
        imperium_self.saveSystemAndPlanets(sys);

        if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
          imperium_self.updateStatus("Notifying players of hits assignment...");
          imperium_self.endTurn();
          imperium_self.updateStatus("Hits taken...");
        }

      });
    }

  });
}





//
// destroy units
//
playerDestroyUnits(player, total, sector, capital = 0) {

  let imperium_self = this;
  let total_hits = total;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  html = '<div class="sf-readable">You must destroy ' + total + ' units in sector: ' + imperium_self.game.sectors[sector].name + ':</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
    let unit = sys.s.units[imperium_self.game.player - 1][i];
    maximum_assignable_hits++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  for (let p = 0; i < sys.p.length; p++) {
    for (let i = 0; i < sys.p[p].units[imperium_self.game.player - 1].length; i++) {
      let unit = sys.p[p].units[imperium_self.game.player - 1][i];
      maximum_assignable_hits++;
      if (targetted_units.includes(unit.type)) { total_targetted_units++; }
      html += '<li class="textchoice player_unit_' + p + '_' + i + '" id="ground_unit_' + p + '_' + i + '">' + unit.name + '</li>';
    }
  }
  html += '</ul>';

  if (maximum_assignable_hits == 0) {
    this.addMove("NOTIFY\t" + this.returnFaction(player) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }


  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {


    let ship_idx = $(this).attr("id");
    let planet_idx = 0;
    let unit_idx = 0;
    let unit_type = "ship";

    if (ship_idx.indexOf("_unit_") > 0) {
      unit_type = "ground";
      let tmpk = ship_idx.split("_");
      planet_idx = tmpk[1];
      unit_idx = tmpk[2];

    }

    let selected_unit = null;
    if (unit_type == "ship") {
      selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];
    } else {
      selected_unit = sys.p[planet_idx].units[imperium_self.game.player - 1][unit_idx];
    }

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    if (unit_type == "ship") {
      imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");
    } else {
      imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "ground\t" + sector + "\t" + planet_idx + "\t" + unit_idx + "\t1");
    }

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total_hits--;
    hits_assigned++;

    if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
      imperium_self.updateStatus("Notifying players of units destroyed...");
      imperium_self.endTurn();
    }

  });
}





//
// destroy ships
//
playerDestroyShips(player, total, sector, capital = 0) {

  let imperium_self = this;
  let total_hits = total;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  html = '<div class="sf-readable">You must destroy ' + total + ' ships in your fleet:</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
    let unit = sys.s.units[imperium_self.game.player - 1][i];
    maximum_assignable_hits++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  html += '</ul>';

  if (maximum_assignable_hits == 0) {
    this.addMove("NOTIFY\t" + this.returnFaction(player) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }


  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let ship_idx = $(this).attr("id");
    let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total_hits--;
    hits_assigned++;

    if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
      imperium_self.updateStatus("Notifying players of hits assignment...");
      imperium_self.endTurn();
    }

  });
}


//
// destroy opponent ships (not assigning hits)
//
playerDestroyOpponentShips(player, total, sector, capital = 0) {

  let imperium_self = this;
  let ships_destroyed = 0;
  let maximum_destroyable_ships = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  let opponent = imperium_self.returnOpponentInSector(player, sector);

  if (opponent == -1) {
    this.addMove("NOTIFY\t" + this.returnFactionNickname(opponent) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }

  html = '<div class="sf-readable">You may destroy ' + total + ' ships in opponent fleet:</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[opponent-1].length; i++) {
    let unit = sys.s.units[opponent-1][i];
    maximum_destroyable_ships++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  html += '</ul>';

  if (maximum_destroyable_ships == 0) {
    this.addMove("NOTIFY\t" + this.returnFactionNickname(opponent) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }

  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

   let ship_idx = $(this).attr("id");
    let selected_unit = sys.s.units[opponent - 1][ship_idx];

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    imperium_self.addMove("destroy_unit\t" + player + "\t" + opponent + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total--;
    ships_destroyed++;

    if (total == 0 || ships_destroyed >= maximum_destroyable_ships) {
      imperium_self.updateStatus("Notifying players of destroyed ships...");
      imperium_self.endTurn();
    }

  });
}








//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlaySpaceCombat(attacker, defender, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let html = '';
  let relevant_action_cards = ["space_combat"];
  if (this.game.state.space_combat_round > 1) {
    relevant_action_cards.push("space_combat_post");
  }

  let opponent = attacker;
  if (imperium_self.game.player == attacker) { opponent = defender; }

  this.game.state.space_combat_sector = sector;

  html = '<div class="sf-readable"><b>Space Combat: round ' + this.game.state.space_combat_round + ':</b><div class="combat_attacker">' + this.returnFaction(attacker) + '</div><div class="combat_attacker_fleet">' + this.returnPlayerFleetInSector(attacker, sector) + '</div><div class="combat_defender">' + this.returnFaction(defender) + '</div><div class="combat_defender_fleet">' + this.returnPlayerFleetInSector(defender, sector) + '</div><ul>';

  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards)
  if (ac.length > 0) {
    html += '<li class="option" id="attack">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="attack">continue</li>';
  }

  //
  // can I retreat
  //
  if (this.canPlayerRetreat(imperium_self.game.player, attacker, defender, sector)) {
    html += '<li class="option" id="retreat">announce retreat</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "space_combat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "space_combat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }, function () {
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }, relevant_action_cards);
    }

    if (action2 == "attack") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.prependMove("ships_fire\t" + attacker + "\t" + defender + "\t" + sector);
      imperium_self.endTurn();
    }

    if (action2 == "retreat") {
      if (imperium_self.canPlayerRetreat(imperium_self.game.player, attacker, defender, sector)) {
        let retreat_options = imperium_self.returnSectorsWherePlayerCanRetreat(imperium_self.game.player, sector);

        let html = '<div clss="sf-readable">Retreat into which Sector? </div><ul>';
        for (let i = 0; i < retreat_options.length; i++) {
	  let sys = imperium_self.returnSectorAndPlanets(retreat_options[i]);
          html += '<li class="option" id="' + i + '">' + sys.s.name + '</li>';
        }
        html += '</ul>';

        imperium_self.updateStatus(html);

        $('.option').off();
        $('.option').on('click', function () {

          let opt = $(this).attr("id");
          let retreat_to_sector = retreat_options[opt];

          imperium_self.addMove("announce_retreat\t" + imperium_self.game.player + "\t" + opponent + "\t" + sector + "\t" + retreat_to_sector);
          imperium_self.endTurn();
          return 0;
        });


      } else {
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }
    }

  });
}




playerRespondToRetreat(player, opponent, from, to) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(to);
  let relevant_action_cards = ["retreat"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);

  let html = '<div class="sf-readable">Your opponent has announced a retreat into ' + sys.s.name + ' at the end of this round of combat: </div><p></p><ul>';
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  html += '<li class="option" id="permit">permit retreat</li>';
  html += '</ul>';

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "retreat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "retreat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';


  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerRespondToRetreat(player, opponent, from, to);
      }, function () {
        imperium_self.playerRespondToRetreat(player, opponent, from, to);
      }.relevant_action_cards);
    }


    if (action2 == "permit") {
      imperium_self.endTurn();
    }
  });
}






//
// ground combat is over -- provide options for scoring cards, action cards
//
playerPlayGroundCombatOver(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let relevant_action_cards = ["ground_combat_victory", "ground_combat_over", "ground_combat_loss"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);

  let html = '';
  let win = 0;

  if (player == sys.p[planet_idx].owner) {
    html = '<div class="sf-readable">Ground Combat is Over (you win): </div><ul>';
    win = 1;
  } else {
    html = '<div class="sf-readable">Space Combat is Over (you lose): </div><ul>';
  }

  if (ac.length > 0) {
    html += '<li class="option" id="ok">acknowledge</li>';
    html += '<li class="option" id="action">action card</li>';
  } else {
    html += '<li class="option" id="ok">acknowledge</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "ground_combat_over", this.game.player) == 1) {
      let x = z[i].menuOption(this, "ground_combat_over", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 === "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayGroundCombatOver(player, sector, planet_idx);
      }, function () {
        imperium_self.playerPlayGroundCombatOver(player, sector, planet_idx);
      });
    }

    if (action2 === "ok") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.endTurn();
    }

  });
}




//
// space combat is over -- provide options for scoring cards, action cards
//
playerPlaySpaceCombatOver(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let relevant_action_cards = ["space_combat_victory", "space_combat_over", "space_combat_loss"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);
  let html = '';
  let win = 0;

  if (this.doesPlayerHaveShipsInSector(player, sector)) {
    html = '<div class="sf-readable">Space Combat is Over (you win): </div><ul>';
    win = 1;
  } else {
    html = '<div class="sf-readable">Space Combat is Over (you lose): </div><ul>';
  }

  if (ac.length > 0) {
    html += '<li class="option" id="ok">acknowledge</li>';
    html += '<li class="option" id="action">action card</li>';
  } else {
    html += '<li class="option" id="ok">acknowledge</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "space_combat_over", this.game.player) == 1) {
      let x = z[i].menuOption(this, "space_combat_over", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat_over", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlaySpaceCombatOver(player, sector, planet_idx);
      }, function () {
        imperium_self.playerPlaySpaceCombatOver(player, sector, planet_idx);
      });
    }

    if (action2 === "ok") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.endTurn();
    }

  });
}







//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayGroundCombat(attacker, defender, sector, planet_idx) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let html = '';

  this.game.state.ground_combat_sector = sector;
  this.game.state.ground_combat_planet_idx = planet_idx;

  let attacker_forces = this.returnNumberOfGroundForcesOnPlanet(attacker, sector, planet_idx);
  let defender_forces = this.returnNumberOfGroundForcesOnPlanet(defender, sector, planet_idx);

  if (sys.p[planet_idx].owner != attacker) {
    html = '<div class="sf-readable">'+this.returnFactionNickname(attacker)+' are invading ' + sys.p[planet_idx].name + ' with ' + attacker_forces + ' infantry. ' + this.returnFactionNickname(defender) + ' is defending with ' + defender_forces + ' infantry. This is round ' + this.game.state.ground_combat_round + ' of ground combat. </div><ul>';
  } else {
    html = '<div class="sf-readable">' + this.returnFactionNickname(defender) + ' are invading ' + sys.p[planet_idx].name + ' with ' + defender_forces + ' infantry. You have ' + attacker_forces + ' infantry remaining. This is round ' + this.game.state.ground_combat_round + ' of ground combat. </div><ul>';
  }

  let ac = this.returnPlayerActionCards(this.game.player, ["combat", "ground_combat"])
  if (ac.length > 0) {
    html += '<li class="option" id="attack">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="attack">continue</li>';
  }


  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "ground_combat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "ground_combat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "ground_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayGroundCombat(attacker, defender, sector, planet_idx);
      }, function () {
        imperium_self.playerPlayGroundCombat(attacker, defender, sector, planet_idx);
      });
    }

    if (action2 == "attack") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.prependMove("infantry_fire\t" + attacker + "\t" + defender + "\t" + sector + "\t" + planet_idx);
      imperium_self.endTurn();
    }

  });
}







//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPDSAttack(player, attacker, sector) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_pds"];
  let can_target_with_pds_fire = 1;

  let defender = -1;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  for (let i = 0; i < sys.s.units.length; i++) {
    if ((i + 1) != attacker) {
      if (sys.s.units[i].length > 0) {
        defender = (i + 1);
      }
    }
  }

  html = '<div class="sf-readable">Do you wish to fire your PDS before moving into the sector?</div><ul>';

  //
  // skip if attacker is immune
  //
  if (defender != -1) {
    if (imperium_self.game.players_info[defender - 1].temporary_immune_to_pds_fire) {
      html = '<div class="sf-readable">' + imperium_self.returnFaction(defender) + ' cannot be targeted by PDS fire during this invasion:</div><ul>';
      can_target_with_pds_fire = 0;
    }
  } else {
    html = '<div class="sf-readable">You cannot target any ships with PDS fire and must skip firing:</div><ul>';
    can_target_with_pds_fire = 0;
  }


  let ac = this.returnPlayerActionCards(player, relevant_action_cards);
  if (1 == 1) {
    html += '<li class="option" id="skip">skip PDS</li>';
  }
  if (can_target_with_pds_fire == 1) {
    html += '<li class="option" id="fire">fire PDS</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pds", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pds", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pds", imperium_self.game.player);
        }
      }
    }


    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPDSAttack(player, attacker, sector);
      }, function () {
        imperium_self.playerPlayPDSAttack(player, attacker, sector);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

    if (action2 == "fire") {
      // prepend so it happens after the modifiers -- defender instead of attacker here
      imperium_self.prependMove("pds_fire\t" + imperium_self.game.player + "\t" + defender + "\t" + sector);
      imperium_self.endTurn();
    };

  });

}


//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPDSDefense(player, attacker, sector) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_pds"];
  let can_target_with_pds_fire = 1;

  html = '<div class="sf-readable">Do you wish to fire your PDS?</div><ul>';

  //
  // skip if attacker is immune
  //
  if (imperium_self.game.players_info[attacker - 1].temporary_immune_to_pds_fire) {
    html = '<div class="sf-readable">Your attacker cannot be targeted by PDS fire during this invasion:</div><ul>';
    can_target_with_pds_fire = 0;
  }


  let ac = this.returnPlayerActionCards(player, relevant_action_cards);
  if (1 == 1) {
    html += '<li class="option" id="skip">skip PDS</li>';
  }
  if (can_target_with_pds_fire == 1) {
    html += '<li class="option" id="fire">fire PDS</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pds", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pds", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pds", imperium_self.game.player);
        }
      }
    }


    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPDSDefense(player, attacker, sector);
      }, function () {
        imperium_self.playerPlayPDSDefense(player, attacker, sector);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

    if (action2 == "fire") {
      // prepend so it happens after the modifiers
      imperium_self.prependMove("pds_fire\t" + imperium_self.game.player + "\t" + attacker + "\t" + sector);
      imperium_self.endTurn();
    };

  });

}


//
// reaching this implies that the player can choose to fire / not-fire
//
playerResolveDeadlockedAgenda(agenda, choices) {

  let imperium_self = this;
  let html = '';

  html = '<div class="sf-readable">The agenda has become deadlocked in the Senate. You - the Speaker - must resolve it: </div><ul>';
  for (let i = 0; i < choices.length; i++) {
    html += '<li class="option" id="' + i + '">' + this.returnNameFromIndex(choices[i]) + '</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    imperium_self.addMove("resolve_agenda\t" + agenda + "\tspeaker\t" + choices[action2]);
    imperium_self.endTurn();
    return 0;

  });
}




//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPreAgendaStage(player, agenda, agenda_idx) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_agenda", "rider"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  if (this.doesPlayerHaveRider(imperium_self.game.player)) {
    html = '<div class="sf-readable">With your riders depending on how the other factions vote, your emissaries track the mood in the Senate closely...:</div><ul>';
  } else {
    html = '<div class="sf-readable">As the Senators gather to vote on ' + this.agenda_cards[agenda].name + ', your emissaries nervously tally the votes in their head:</div><ul>';
  }

  if (1 == 1) {
    html += '<li class="option" id="skip">proceed into Senate</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pre_agenda", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pre_agenda", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "agenda", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPreAgendaStage(player, agenda, agenda_idx);
      }, function () {
        imperium_self.playerPlayPreAgendaStage(player, agenda, agenda_idx);
      }, ["pre_agenda", "rider"]);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

  });

}
playerPlayPostAgendaStage(player, agenda, array_of_winning_options) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["post_agenda"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  if (array_of_winning_options.length > 0) {
    html = '<div class="sf-readable">The Senate has apparently voted for "' + this.returnNameFromIndex(array_of_winning_options[0]) + '". As the Speaker confirms the final tally, you get the feeling the issue may not be fully settled:</div><ul>';
  } else {
    html = '<div class="sf-readable">No-one in the Senate bothered to show-up and vote, leaving the matter to be decided by the Speaker:</div><ul>';
  }
  if (array_of_winning_options.length > 1) {
    html = '<div class="sf-readable">The voting has concluded in deadlock. The Speaker must resolve the agenda:</div><ul>';
  }

  if (1 == 1) {
    html += '<li class="option" id="skip">await results</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "post_agenda", this.game.player) == 1) {
      let x = z[i].menuOption(this, "post_agenda", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "post_agenda", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPostAgendaStage(player, agenda, array_of_winning_options);
      }, function () {
        imperium_self.playerPlayPostAgendaStage(player, agenda, array_of_winning_options);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

  });

}



playerContinueTurn(player, sector) {

  let imperium_self = this;
  let options_available = 0;

  if (this.game.tracker.invasion == undefined) { this.game.tracker = this.returnPlayerTurnTracker(); this.game.tracker.activate_system = 1; }

  //
  // check to see if any ships survived....
  //
  let playercol = "player_color_" + this.game.player;
  let html = "<div class='sf-readable'><div class='player_color_box " + playercol + "'></div>" + this.returnFaction(player) + ": </div><ul>";

  if (this.canPlayerScoreActionStageVictoryPoints(player) != "") {
    html += '<li class="option" id="score">score secret objective</li>';
    options_available++;
  }
  if (this.canPlayerProduceInSector(player, sector) && this.game.tracker.production == 0) {
    html += '<li class="option" id="produce">produce units</li>';
    options_available++;
  }

  if (this.canPlayerInvadePlanet(player, sector) && this.game.tracker.invasion == 0) {
    if (sector == "new-byzantium" || sector == "4_4") {
      if ((imperium_self.game.planets['new-byzantium'].owner != -1) || (imperium_self.returnAvailableInfluence(imperium_self.game.player) + imperium_self.game.players_info[imperium_self.game.player - 1].goods) >= 6) {
        html += '<li class="option" id="invade">invade planet</li>';
        options_available++;
      }
    } else {
      html += '<li class="option" id="invade">invade planet</li>';
      options_available++;
    }
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">reassign infantry</li>';
    options_available++;
  }
  if (this.game.tracker.trade == 0 && this.canPlayerTrade(this.game.player) == 1) {
    html += '<li class="option" id="trade">trade</li>';
  }

  //if (this.canPlayerPlayActionCard(player) && this.game.tracker.action_card == 0) {
  //  html += '<li class="option" id="action">action card</li>';
  //  options_available++;
  //}

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "continue", this.game.player) == 1) {
      let x = z[i].menuOption(this, "continue", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }

  html += '<li class="option" id="endturn">end turn</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "continue", imperium_self.game.player);
        }
      }
    }

    if (action2 == "endturn") {
      imperium_self.addMove("resolve\tplay");
      imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
      imperium_self.endTurn();
      return 0;
    }

    if (action2 == "trade") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerTurn();
      return 0;
    }

    if (action2 == "land") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerSelectInfantryToLand(sector);
      return 0;
    }

    if (action2 == "produce") {

      //
      // check the fleet supply and NOTIFY users if they are about to surpass it
      //
      let fleet_supply_in_sector = imperium_self.returnSpareFleetSupplyInSector(imperium_self.game.player, sector);
      if (fleet_supply_in_sector <= 1) {
        let notice = "You have no spare fleet supply in this sector. Do you still wish to produce more ships?";
        if (fleet_supply_in_sector == 1) {
          notice = "You have fleet supply for 1 additional capital ship in this sector. Do you still wish to produce more ships?";
        }
        let c = sconfirm(notice);
        if (c) {
          imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
          imperium_self.playerProduceUnits(sector);
        }
        return;
      }
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerProduceUnits(sector);
    }

    if (action2 == "invade") {

      //
      // New Byzantium requires 6 influence to conquer
      //
      if (sector === "new-byzantium" || sector == "4_4") {
        if (imperium_self.game.planets['new-byzantium'].owner == -1) {
          if (imperium_self.returnAvailableInfluence(imperium_self.game.player) >= 6) {
            imperium_self.playerSelectInfluence(6, function (success) {
              imperium_self.game.tracker.invasion = 1;
              imperium_self.playerInvadePlanet(player, sector);
            });
          } else {
            salert("The first conquest of New Byzantium requires spending 6 influence, which you lack.");
            return;
          }
          return;
        }
      }

      imperium_self.game.tracker.invasion = 1;
      imperium_self.playerInvadePlanet(player, sector);
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.game.tracker.action_card = 1;
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
      }, function () {
        imperium_self.playerContinueTurn(player, sector);
        return;
      });
    }

    if (action2 == "score") {
      imperium_self.playerScoreActionStageVictoryPoints(imperium_self, function (imperium_self, vp, objective) {
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
        if (vp > 0) { imperium_self.addMove("score\t" + imperium_self.game.player + "\t" + vp + "\t" + objective); }
        imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.push(objective);
        imperium_self.endTurn();
        return;
      });
    }
  });
}





////////////////
// Production //
////////////////
playerBuyTokens(stage = 0, resolve = 1) {

  let imperium_self = this;

  if (this.returnAvailableInfluence(this.game.player) <= 2) {
    this.updateLog("You skip the initiative secondary, as you lack adequate influence...");
    this.updateStatus("Skipping purchase of tokens as insufficient influence...");
    if (resolve == 1) {
      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
    }
    this.endTurn();
    return 0;
  }

  let html = '<div class="sf-readable">Do you wish to purchase any command or strategy tokens, or increase your fleet supply?</div><ul>';

  if (stage == 2) {
    html = '<div class="sf-readable">Leadership has been played. Do you wish to purchase any additional command or strategy tokens, or increase your fleet supply?</div><ul>';
    if (imperium_self.game.state.round == 1)  {
      html = `The Leadership strategy card has been played. This lets you spend 3 influence to purchase additional command tokens, strategy tokens or fleet supply. Do you wish to purchase any additional tokens: </p><ul>`;
    }
  }

  html += '<li class="buildchoice textchoice" id="skip">Do Not Purchase</li>';
  html += '<li class="buildchoice textchoice" id="command">Command Tokens  +<span class="command_total">0</span></li>';
  html += '<li class="buildchoice textchoice" id="strategy">Strategy Tokens +<span class="strategy_total">0</span></li>';
  html += '<li class="buildchoice textchoice" id="fleet">Fleet Supply  +<span class="fleet_total">0</span></li>';
  html += '</ul></p>';
  html += '';
  html += '<div id="buildcost" class="buildcost"><span class="buildcost_total">0</span> influence</div>';
  html += '<div id="confirm" class="buildchoice">click here to finish</div>';

  this.updateStatus(html);


  let command_tokens = 0;
  let strategy_tokens = 0;
  let fleet_supply = 0;
  let total_cost = 0;

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let id = $(this).attr("id");

    if (id == "skip") {
      if (resolve == 1) {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      }
      imperium_self.endTurn();
      return;
    }

    if (id == "confirm") {

      total_cost = 3 * (fleet_supply + command_tokens + strategy_tokens);

      if (resolve == 1) {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
        imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      }

      imperium_self.playerSelectInfluence(total_cost, function (success) {

        if (success == 1) {
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tcommand\t" + command_tokens);
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tcommand\t" + strategy_tokens);
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tfleetsupply\t" + fleet_supply);
          imperium_self.endTurn();
          return;
        } else {
          imperium_self.endTurn();
        }
      });
    };

    //
    //  figure out if we need to load infantry / fighters
    //
    if (id == "command") { command_tokens++; }
    if (id == "strategy") { strategy_tokens++; }
    if (id == "fleet") { fleet_supply++; }

    let divtotal = "." + id + "_total";
    let x = parseInt($(divtotal).html());
    x++;
    $(divtotal).html(x);

    total_cost = 3 * (command_tokens + strategy_tokens + fleet_supply);
    $('.buildcost_total').html(total_cost);


    let return_to_zero = 0;
    if (total_cost > imperium_self.returnAvailableInfluence(imperium_self.game.player)) {
      salert("You cannot buy more tokens than you have influence available to pay");
      return_to_zero = 1;
    }
    if (return_to_zero == 1) {
      total_cost = 0;
      command_tokens = 0;
      strategy_tokens = 0;
      fleet_supply = 0;
      $('.command_total').html(0);
      $('.strategy_total').html(0);
      $('.fleet_total').html(0);
      return;
    }

  });
}





 playerBuyActionCards(stage = 0, resolve = 1) {

  let imperium_self = this;

  let html = '<div class="sf-readable">Do you wish to spend 1 strategy token to purchase 2 action cards?</div><ul>';
  if (stage == 2) {
    html = '<div class="sf-readable">Politics has been played: do you wish to spend 1 strategy token to purchase 2 action cards?</div><ul>';
    if (imperium_self.game.state.round == 1) {
      html = `${imperium_self.returnFaction(imperium_self.game.player)} has played the Politics strategy card. This lets you to spend 1 strategy token to purchase 2 action cards, which provide special one-time abilities. You have ${imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens} strategy tokens. Purchase action cards: </p><ul>`;
    }
  }
  html += '<li class="buildchoice textchoice" id="yes">Purchase Action Cards</li>';
  html += '<li class="buildchoice textchoice" id="no">Do Not Purchase Action Cards</li>';
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let id = $(this).attr("id");

    if (id == "yes") {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " gets action cards");
      imperium_self.addMove("gain\t" + imperium_self.game.player + "\taction_cards\t2");
      imperium_self.addMove("DEAL\t2\t" + imperium_self.game.player + "\t2");
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    } else {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    }
  });

 }




 playerBuySecretObjective(stage = 0, resolve = 1) {

  let imperium_self = this;

  let html = '<div class="sf-readable">Do you wish to spend 1 strategy token to purchase a Secret Objective?</div><ul>';
  if (stage == 2) {
    html = '<div class="sf-readable">The Imperial Strategy card has been played: do you wish to spend 1 strategy token to purchase a Secret Objective?</div><ul>';
    if (imperium_self.game.state.round == 1) {
      html = `${imperium_self.returnFaction(imperium_self.game.player)} has played the Imperial strategy card. This lets you to spend 1 strategy token to purchase an additional secret bjective. You have ${imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens} strategy tokens. Purchase secret objective: </p><ul>`;
    }
  }
  html += '<li class="buildchoice textchoice" id="yes">Purchase Secret Objective</li>';
  html += '<li class="buildchoice textchoice" id="no">Do Not Purchase</li>';
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let id = $(this).attr("id");

    if (id == "yes") {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.addMove("gain\t" + imperium_self.game.player + "\tsecret_objective\t1");
      imperium_self.addMove("DEAL\t6\t" + imperium_self.game.player + "\t1");
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    } else {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    }
  });

}





playerResearchTechnology(mycallback) {

  let imperium_self = this;
  let html = '<div class="sf-readable">You are eligible to upgrade to the following technologies: </div><ul>';

  for (var i in this.tech) {
    if (this.canPlayerResearchTechnology(i)) {
      html += '<li class="option" id="' + i + '">' + this.tech[i].name + '</li>';
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showTechCard(s); });
  $('.option').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideTechCard(s); });
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let i = $(this).attr("id");
    imperium_self.hideTechCard(i);

    //
    // handle prerequisites
    //
    imperium_self.exhaustPlayerResearchTechnologyPrerequisites(i);
    mycallback($(this).attr("id"));

  });

}


//
// return string if YES, empty string if NO
//
canPlayerScoreActionStageVictoryPoints(player) {

  let imperium_self = this;
  let html = "";

  //
  // Secret Objectives - Action Phase
  //
  for (let i = 0; i < imperium_self.game.deck[5].hand.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (imperium_self.secret_objectives[imperium_self.game.deck[5].hand[i]].phase === "action") {
          html += '<li class="option secret3" id="' + imperium_self.game.deck[5].hand[i] + '">' + imperium_self.secret_objectives[imperium_self.game.deck[5].hand[i]].name + '</li>';
        }
      }
    }
  }

  return html;

}




playerScoreActionStageVictoryPoints(imperium_self, mycallback, stage = 0) {

  let html = '';
  let player = imperium_self.game.player;

  html += '<div class="sf-readable">Do you wish to score a secret objective? </div><ul>';

  html += this.canPlayerScoreActionStageVictoryPoints(player);
  html += '<li class="option cancel" id="cancel">cancel</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);
  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    let objective_type = 3;

    if ($(this).hasClass("stage1")) { objective_type = 1; }
    if ($(this).hasClass("stage2")) { objective_type = 2; }
    if ($(this).hasClass("secret3")) { objective_type = 3; }

    if (action === "no") {
      mycallback(imperium_self, 0, "");

    } else {

      let objective = action;
      let vp = 1;
      if (imperium_self.secret_objectives[objective]) {
        if (imperium_self.secret_objectives[objective].vp > 1) { vp = imperium_self.stage_ii_objectives[objective].vp; }
      }

      mycallback(imperium_self, vp, objective);

    }
  });
}



canPlayerScoreVictoryPoints(player, card = "", deck = 1) {

  if (card == "") { return 0; }

  let imperium_self = this;

  // deck 1 = primary
  // deck 2 = secondary
  // deck 3 = secret

  if (deck == 1) {
    let objectives = this.returnStageIPublicObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  if (deck == 2) {
    let objectives = this.returnStageIIPublicObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  if (deck == 3) {
    let objectives = this.returnSecretObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  return 0;

}




playerScoreSecretObjective(imperium_self, mycallback, stage = 0) {

  let html = '';
  let can_score = 0;

  html += '<div class="sf-readable">Do you wish to score any Secret Objectives? </div><ul>';

  // Secret Objectives
  for (let i = 0; i < imperium_self.game.deck[5].hand.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.deck[5].hand[i])) {
          can_score = 1;
          html += '1 VP Secret Objective: <li class="option secret3" id="' + imperium_self.game.deck[5].hand[i] + '">' + imperium_self.game.deck[5].cards[imperium_self.game.deck[5].hand[i]].name + '</li>';
        }
      }
    }
  }

  html += '<li class="option" id="no">I choose not to score...</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);

  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    if (action == "no") {
      mycallback(imperium_self, 0, "");
    } else {
      let objective = action;
      let vp = 1;
      if (imperium_self.secret_objectives[objective]) {
        if (imperium_self.secret_objectives[objective].vp > 1) { vp = imperium_self.secret_objectives[objective].vp; }
      }
      mycallback(imperium_self, vp, objective);
    }
  });
}


playerScoreVictoryPoints(imperium_self, mycallback, stage = 0) {

  let html = '';
  html += '<div class="sf-readable">Do you wish to score any public objectives? </div><ul>';

  // Stage I Public Objectives
  for (let i = 0; i < imperium_self.game.state.stage_i_objectives.length; i++) {

    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.state.stage_i_objectives[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.state.stage_i_objectives[i], 1)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.state.stage_i_objectives[i])) {
          html += '1 VP Public Objective: <li class="option stage1" id="' + imperium_self.game.state.stage_i_objectives[i] + '">' + imperium_self.game.deck[3].cards[imperium_self.game.state.stage_i_objectives[i]].name + '</li>';
        }
      }
    }
  }

  // Stage II Public Objectives
  for (let i = 0; i < imperium_self.game.state.stage_ii_objectives.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.state.stage_ii_objectives[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.state.stage_ii_objectives[i], 2)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.state.stage_ii_objectives[i])) {
          html += '2 VP Public Objective: <li class="option stage2" id="' + imperium_self.game.state.stage_ii_objectives[i] + '">' + imperium_self.game.deck[4].cards[imperium_self.game.state.stage_ii_objectives[i]].name + '</li>';
        }
      }
    }
  }

  /***
      // Secret Objectives
      for (let i = 0 ; i < imperium_self.game.deck[5].hand.length; i++) {
        if (!imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
          if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (!imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.includes(imperium_self.game.deck[5].hand[i])) {
              html += '1 VP Secret Objective: <li class="option secret3" id="'+imperium_self.game.deck[5].hand[i]+'">'+imperium_self.game.deck[5].cards[imperium_self.game.deck[5].hand[i]].name+'</li>';
            }
          }
        }
      }
  ***/

  html += '<li class="option" id="no">I choose not to score...</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);
  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    let objective_type = 3;

    if ($(this).hasClass("stage1")) { objective_type = 1; }
    if ($(this).hasClass("stage2")) { objective_type = 2; }
    if ($(this).hasClass("secret3")) { objective_type = 3; }

    if (action === "no") {
      mycallback(imperium_self, 0, "");
    } else {
      let objective = action;
      let vp = 1;
      if (imperium_self.stage_ii_objectives[objective]) {
        if (imperium_self.stage_ii_objectives[objective].vp > 1) { vp = imperium_self.stage_ii_objectives[objective].vp; }
      }
      mycallback(imperium_self, vp, objective);

    }
  });
}




 playerBuildInfrastructure(mycallback, stage = 1) {

  let imperium_self = this;

  let html = '';

  if (stage == 1) { html += "<div class='sf-readable'>Which would you like to build: </div><ul>"; }
  else { html += "<div class='sf_readable'>You may also build an additional PDS: </div><ul>"; }

  html += '<li class="buildchoice" id="pds">Planetary Defense System</li>';
  if (stage == 1) {
    html += '<li class="buildchoice" id="spacedock">Space Dock</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  let stuff_to_build = [];

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showUnit(s); });
  $('.buildchoice').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideUnit(s); });
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();
    $('.buildchoice').off();

    let id = $(this).attr("id");

    imperium_self.playerSelectPlanetWithFilter(
      "Select a planet on which to build: ",
      function (planet) {
        let existing_units = 0;
        if (imperium_self.game.planets[planet].owner == imperium_self.game.player) {
          for (let i = 0; i < imperium_self.game.planets[planet].units[imperium_self.game.player - 1].length; i++) {
            if (imperium_self.game.planets[planet].units[imperium_self.game.player - 1][i].type == id) {
              existing_units++;
            }
          }
          if (id === "pds") {
            if (existing_units >= imperium_self.game.state_pds_limit_per_planet) { return 0; }
          }
          if (id === "spacedock") {
            if (existing_units >= 1) { return 0; }
          }
          return 1;
        }
        return 0;
      },
      function (planet) {
        if (id == "pds") {
          imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + imperium_self.game.planets[planet].idx + "\tpds\t" + imperium_self.game.planets[planet].sector);
          mycallback(imperium_self.game.planets[planet].sector);
        }
        if (id == "spacedock") {
          imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + imperium_self.game.planets[planet].idx + "\tspacedock\t" + imperium_self.game.planets[planet].sector);
          mycallback(imperium_self.game.planets[planet].sector);
        }
      },
      function() {
        imperium_self.unlockInterface();
        imperium_self.playerBuildInfrastructure(mycallback, stage);
      },
    );
  });

}


 playerProduceUnits(sector, production_limit = 0, cost_limit = 0, stage = 0, warfare = 0) {

  let imperium_self = this;

  let player_fleet = this.returnPlayerFleet(imperium_self.game.player);
  let player_build = {};
  player_build.infantry = 0;
  player_build.fighters = 0;
  player_build.carriers = 0;
  player_build.cruisers = 0;
  player_build.dreadnaughts = 0;
  player_build.destroyers = 0;
  player_build.flagships = 0;
  player_build.warsuns = 0;

  //
  // determine production_limit from sector
  //
  let sys = this.returnSectorAndPlanets(sector);
  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
  available_resources += imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;

  let calculated_production_limit = 0;
  for (let i = 0; i < sys.s.units[this.game.player - 1].length; i++) {
    calculated_production_limit += sys.s.units[this.game.player - 1][i].production;
  }
  for (let p = 0; p < sys.p.length; p++) {
    for (let i = 0; i < sys.p[p].units[this.game.player - 1].length; i++) {
      calculated_production_limit += sys.p[p].units[this.game.player - 1][i].production;
      if (sys.p[p].units[this.game.player - 1][i].type === "spacedock") {
        calculated_production_limit += sys.p[p].resources;
      }
    }
  }

  if (this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock == 1) {
    if (production_limit == 0 && this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_production_limit >= 0) { production_limit = this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_production_limit; }
    if (cost_limit == 0 && this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_cost_limit >= 0) { cost_limit = this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_cost_limit; }
  };

  if (calculated_production_limit > production_limit) { production_limit = calculated_production_limit; }


  let html = '<div class="sf-readable">Produce Units in this Sector: ';
  if (production_limit != 0) { html += '(' + production_limit + ' units max)'; }
  if (cost_limit != 0) { html += '(' + cost_limit + ' cost max)'; }
  html += '</div><ul>';
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="infantry">Infantry - <span class="infantry_total">0</span></li>';
  }
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="fighter">Fighter - <span class="fighter_total">0</span></li>';
  }
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="destroyer">Destroyer - <span class="destroyer_total">0</span></li>';
  }
  if (available_resources >= 3) {
    html += '<li class="buildchoice" id="carrier">Carrier - <span class="carrier_total">0</span></li>';
  }
  if (available_resources >= 2) {
    html += '<li class="buildchoice" id="cruiser">Cruiser - <span class="cruiser_total">0</span></li>';
  }
  if (available_resources >= 4) {
    html += '<li class="buildchoice" id="dreadnaught">Dreadnaught - <span class="dreadnaught_total">0</span></li>';
  }
  if (available_resources >= 8 && this.canPlayerProduceFlagship(imperium_self.game.player)) {
    html += '<li class="buildchoice" id="flagship">Flagship - <span class="flagship_total">0</span></li>';
  }
  if (imperium_self.game.players_info[imperium_self.game.player - 1].may_produce_warsuns == 1) {
    if (available_resources >= 12) {
      html += '<li class="buildchoice" id="warsun">War Sun - <span class="warsun_total">0</span></li>';
    }
  }
  html += '</ul>';
  html += '</p>';
  html += '<div id="buildcost" class="buildcost"><span class="buildcost_total">0 resources</span></div>';
  html += '<div id="confirm" class="buildchoice">click here to build</div>';

  this.updateStatus(html);

  let stuff_to_build = [];

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showUnit(s); });
  $('.buildchoice').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideUnit(s); });
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let id = $(this).attr("id");

    //
    // submit when done
    //
    if (id == "confirm") {

      $('.buildchoice').off();

      let total_cost = 0;
      for (let i = 0; i < stuff_to_build.length; i++) {
        total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
      }

      if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
        total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
      }

      if (warfare == 0) {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      } else {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
        imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      }

      imperium_self.playerSelectResources(total_cost, function (success) {

        if (success == 1) {
          imperium_self.addMove("post_production\t" + imperium_self.game.player + "\t" + sector + "\t" + JSON.stringify(stuff_to_build));
          for (let y = 0; y < stuff_to_build.length; y++) {
            let planet_idx = imperium_self.returnPlayersLeastDefendedPlanetInSector(imperium_self.game.player, sector);
            if (stuff_to_build[y] != "infantry") { planet_idx = -1; }
            imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + planet_idx + "\t" + stuff_to_build[y] + "\t" + sector);
            imperium_self.addMove("setvar"+"\t"+"state"+"\t"+"0"+"\t"+"active_player_has_produced"+"\t"+1)
            imperium_self.game.tracker.production = 1;
          }
          imperium_self.endTurn();
          return;
        } else {
          salert("failure to find appropriate influence");
        }
      });

      return;
    };


    let calculated_total_cost = 0;
    for (let i = 0; i < stuff_to_build.length; i++) {
      calculated_total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
    }
    calculated_total_cost += imperium_self.returnUnitCost(id, imperium_self.game.player);

    //
    // reduce production costs if needed
    //
    if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
      calculated_total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
    }




    //
    // respect production / cost limits
    //
    let return_to_zero = 0;
    if (id == "fighter" && (player_build.fighters + player_fleet.fighters) > imperium_self.game.players_info[imperium_self.game.player - 1].fighter_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].fighter_limit + " fighters on the board");
      return_to_zero = 1;
    }
    if (id == "infantry" && (player_build.infantry + player_fleet.infantry) > imperium_self.game.players_info[imperium_self.game.player - 1].infantry_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].infantry_limit + " infantry on the board");
      return_to_zero = 1;
    }
    if (id == "destroyer" && (player_build.destroyers + player_fleet.destroyers) > imperium_self.game.players_info[imperium_self.game.player - 1].destroyer_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].destroyer_limit + " destroyers on the board");
      return_to_zero = 1;
    }
    if (id == "carrier" && (player_build.carriers + player_fleet.carriers) > imperium_self.game.players_info[imperium_self.game.player - 1].carrier_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].carrier_limit + " carriers on the board");
      return_to_zero = 1;
    }
    if (id == "cruiser" && (player_build.cruisers + player_fleet.cruisers) > imperium_self.game.players_info[imperium_self.game.player - 1].cruiser_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].cruiser_limit + " cruisers on the board");
      return_to_zero = 1;
    }
    if (id == "dreadnaught" && (player_build.dreadnaughts + player_fleet.dreadnaughts) > imperium_self.game.players_info[imperium_self.game.player - 1].dreadnaught_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].dreadnaught_limit + " dreadnaughts on the board");
      return_to_zero = 1;
    }
    if (id == "flagship" && (player_build.flagships + player_fleet.flagships) > imperium_self.game.players_info[imperium_self.game.player - 1].flagships_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].flagship_limit + " flagships on the board");
      return_to_zero = 1;
    }
    if (id == "warsun" && (player_build.warsuns + player_fleet.warsuns) > imperium_self.game.players_info[imperium_self.game.player - 1].warsun_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].warsun_limit + " warsuns on the board");
      return_to_zero = 1;
    }
    if (calculated_total_cost > imperium_self.returnAvailableResources(imperium_self.game.player)) {
      salert("You cannot build more than you have available to pay for it.");
      return_to_zero = 1;
    }
    if (production_limit < stuff_to_build.length && production_limit > 0) {
      salert("You cannot build more units than your production limit");
      return_to_zero = 1;
    }
    if (cost_limit < calculated_total_cost && cost_limit > 0) {
      salert("You cannot build units that cost more than your cost limit");
      return_to_zero = 1;
    }
    if ((stuff_to_build.length + 1) > calculated_production_limit) {
      salert("You cannot build more units than your production limit");
      return_to_zero = 1;
    }
    if (return_to_zero == 1) {
      stuff_to_build = [];
      $('.infantry_total').html(0);
      $('.fighter_total').html(0);
      $('.destroyer_total').html(0);
      $('.carrier_total').html(0);
      $('.cruiser_total').html(0);
      $('.dreadnaught_total').html(0);
      $('.flagship_total').html(0);
      $('.warsun_total').html(0);
      player_build = {};
      player_build.infantry = 0;
      player_build.fighters = 0;
      player_build.carriers = 0;
      player_build.cruisers = 0;
      player_build.dreadnaughts = 0;
      player_build.destroyers = 0;
      player_build.flagships = 0;
      player_build.warsuns = 0;
      return;
    }

    //
    //  figure out if we need to load infantry / fighters
    //
    stuff_to_build.push(id);

    let total_cost = 0;
    for (let i = 0; i < stuff_to_build.length; i++) {
      total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
    }

    let divtotal = "." + id + "_total";
    let x = parseInt($(divtotal).html());
    x++;
    $(divtotal).html(x);

    //
    // reduce production costs if needed
    //
    if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
      total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
      imperium_self.updateLog("Production Costs reduced by 1");
    }

    let resourcetxt = " resources";
    if (total_cost == 1) { resourcetxt = " resource"; }
    $('.buildcost_total').html(total_cost + resourcetxt);

  });

}


playerHandleTradeOffer(faction_offering, their_offer, my_offer, offer_log) {

  let imperium_self = this;

  let goods_offered = 0;
  let goods_received = 0;
  let promissaries_offered = "";
  let promissaries_received = "";

  if (their_offer.promissaries) {
    if (their_offer.promissaries.length > 0) {
      for (let i = 0; i < their_offer.promissaries.length; i++) {
        let pm = their_offer.promissaries[i].promissary;
	let tmpar = pm.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
        if (i > 0) { promissaries_received += ', '; }
        promissaries_received += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }
    }
  }

  if (my_offer.promissaries) {
    if (my_offer.promissaries.length > 0) {
      for (let i = 0; i < my_offer.promissaries.length; i++) {
        let pm = my_offer.promissaries[i].promissary;
	let tmpar = pm.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
        if (i > 0) { promissaries_offered += ', '; }
        promissaries_offered += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }
    }
  }

  let html = '<div class="sf-readable">You have received a trade offer from ' + imperium_self.returnFaction(faction_offering) + '. ';
  html += offer_log;
  html += ': </div><ul>';
  html += `  <li class="option" id="yes">accept trade</li>`;
  html += `  <li class="option" id="no">refuse trade</li>`;
  html += '</ul>';

  imperium_self.updateStatus(html);


  $('.option').off();
  $('.option').on('click', function () {

    let action = $(this).attr("id");

    if (action == "no") {
      imperium_self.addMove("refuse_offer\t" + imperium_self.game.player + "\t" + faction_offering);
      imperium_self.endTurn();
      return 0;
    }

    if (action == "yes") {
      imperium_self.addMove("trade\t" + faction_offering + "\t" + imperium_self.game.player + "\t" + JSON.stringify(their_offer) + "\t" + JSON.stringify(my_offer));
      imperium_self.endTurn();
      return 0;
    }

  });


}


  playerTrade() {

    let imperium_self = this;
    let factions = this.returnFactions();

    let offer_selected = 0;
    let receive_selected = 0;
    let offer_promissaries = [];
    let receive_promissaries = [];
    let max_offer = 0;
    let max_receipt = 0;


    let goodsTradeInterface = function (imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      let receive_promissary_text = 'no promissaries';
      for (let i = 0; i < receive_promissaries.length; i++) {
        if (i == 0) { receive_promissary_text = ''; }
        let pm = receive_promissaries[i];
	let tmpar = pm.promissary.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	if (i > 0) { receive_promissary_text += ', '; }
        receive_promissary_text += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }

      let offer_promissary_text = 'no promissaries';
      for (let i = 0; i < offer_promissaries.length; i++) {
        if (i == 0) { offer_promissary_text = ''; }
        let pm = offer_promissaries[i];
	let tmpar = pm.promissary.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	if (i > 0) { offer_promissary_text += ', '; }
        offer_promissary_text += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }

      let html = "<div class='sf-readable'>Make an Offer: </div><ul>";
      html += '<li id="to_offer" class="option">you give <span class="offer_total">'+offer_selected+'</span> trade goods</li>';
      html += '<li id="to_receive" class="option">you receive <span class="receive_total">'+receive_selected+'</span> trade goods</li>';
      html += '<li id="promissary_offer" class="option">you give <span class="give_promissary">'+offer_promissary_text+'</span></li>';
      html += '<li id="promissary_receive" class="option">you receive <span class="receive_promissary">'+receive_promissary_text+'</span></li>';
      html += '<li id="confirm" class="option">submit offer</li>';
      html += '<li id="cancel" class="option">cancel</li>';
      html += '</ul>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let selected = $(this).attr("id");

        if (selected == "to_offer") { offer_selected++; if (offer_selected > max_offer) { offer_selected = 0; } }
        if (selected == "to_receive") { receive_selected++; if (receive_selected > max_receipt) { receive_selected = 0; } }

	if (selected == "cancel") {
	  imperium_self.playerTurn();
	  return;
	}
	if (selected == "promissary_offer") {
	  promissaryTradeInterface(imperium_self, player, 1, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;
	}
	if (selected == "promissary_receive") {
	  promissaryTradeInterface(imperium_self, player, 2, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;
	}

        if (selected == "confirm") {

          let my_offer = {};
          my_offer.goods = $('.offer_total').html();
	  my_offer.promissaries = offer_promissaries;
          let my_receive = {};
          my_receive.goods = $('.receive_total').html();
	  my_receive.promissaries = receive_promissaries;

          imperium_self.addMove("offer\t" + imperium_self.game.player + "\t" + player + "\t" + JSON.stringify(my_offer) + "\t" + JSON.stringify(my_receive));
          imperium_self.updateStatus("trade offer submitted");
          imperium_self.endTurn();

        }

        $('.offer_total').html(offer_selected);
        $('.receive_total').html(receive_selected);

      });
    }
    //
    // mode = 1 // offer
	      2 // receive
    //
    let promissaryTradeInterface = function (imperium_self, player, mode, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      // offer mine to them
      if (mode == 1) {

        let html = '<div class="sf-readable">Add Promissary to YOUR Offer: </div><ul>';
        for (let i = 0; i < imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes.length; i++) {

	  let pm = imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes[i];
	  let tmpar = pm.split("-");
          let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	  let already_offered = 0;
	  for (let b = 0; b < offer_promissaries.length; b++) {
	    if (offer_promissaries[b].promissary === pm) {
	      already_offered = 1;
	    }
	  }
	  if (already_offered == 0) {
            html += `  <li class="option" id="${i}">${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
        }
        html += `  <li class="option" id="cancel">cancel</li>`;

	imperium_self.updateStatus(html);
        $('.option').off();
        $('.option').on('click', function () {

          let prom = $(this).attr("id");

          if (prom == "cancel") {
            goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
            return 0;
          }
	  
	  let promobj = { player : imperium_self.game.player , promissary : imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes[prom] }
	  offer_promissaries.push(promobj);
          goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;

	});
      }



      // request theirs
      if (mode == 2) {

        let html = '<div class="sf-readable">Request Promissary FROM them: </div><ul>';
        for (let i = 0; i < imperium_self.game.players_info[player-1].promissary_notes.length; i++) {
	  let pm = imperium_self.game.players_info[player-1].promissary_notes[i];
	  let tmpar = pm.split("-");
          let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	  let already_offered = 0;
	  for (let b = 0; b < receive_promissaries.length; b++) {
	    if (receive_promissaries[b].promissary === pm) {
	      already_offered = 1;
	    }
	  }
	  if (already_offered == 0) {
            html += `  <li class="option" id="${i}">${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
        }
        html += `  <li class="option" id="cancel">cancel</li>`;

	imperium_self.updateStatus(html);
        $('.option').off();
        $('.option').on('click', function () {

          let prom = $(this).attr("id");

          if (prom == "cancel") {
            goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
            return 0;
          }
	  
	  let promobj = { player : player , promissary : imperium_self.game.players_info[player-1].promissary_notes[prom] }
	  receive_promissaries.push(promobj);
          goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;

	});


      }

    }
    let mainTradeInterface = function (imperium_self, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      let html = '<div class="sf-readable">Make Trade Offer to Faction: </div><ul>';
      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
        if (imperium_self.game.players_info[i].traded_this_turn == 0 && (i + 1) != imperium_self.game.player) {
          if (imperium_self.arePlayersAdjacent(imperium_self.game.player, (i + 1))) {
            html += `  <li class="option" id="${i}">${factions[imperium_self.game.players_info[i].faction].name}</li>`;
          }
        }
      }
      html += `  <li class="option" id="cancel">cancel</li>`;
      html += '</ul>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let faction = $(this).attr("id");

        if (faction == "cancel") {
          imperium_self.playerTurn();
          return 0;
        }

        max_offer = imperium_self.game.players_info[imperium_self.game.player - 1].commodities + imperium_self.game.players_info[imperium_self.game.player - 1].goods;
        max_receipt = imperium_self.game.players_info[parseInt(faction)].commodities + imperium_self.game.players_info[parseInt(faction)].goods;

	goodsTradeInterface(imperium_self, (parseInt(faction)+1), mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);

      });
    }

    //
    // start with the main interface
    //
    mainTradeInterface(imperium_self, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);

  }




playerSelectSector(mycallback, mode = 0) {

  //
  // mode
  //
  // 0 = any sector
  // 1 = activated actor
  //
  let imperium_self = this;

  $('.sector').off();
  $('.sector').on('click', function () {
    $('.sector').off();
    let pid = $(this).attr("id");
    mycallback(pid);
  });

}




playerSelectPlanet(mycallback, mode = 0) {

  //
  // mode
  //
  // 0 = in any sector
  // 1 = in unactivated actor
  // 2 = controlled by me
  //

  let imperium_self = this;

  let html = "Select a system in which to select a planet: ";
  this.updateStatus(html);

  $('.sector').on('click', function () {

    let sector = $(this).attr("id");
    let sys = imperium_self.returnSectorAndPlanets(sector);

    //
    // exit if no planets are controlled
    //
    if (mode == 2) {
      let exist_controlled_planets = 0;
      for (let i = 0; i < sys.p.length; i++) {
        if (sys.p[i].owner == imperium_self.game.player) {
          exist_controlled_planets = 1;
        }
      }
      if (exist_controlled_planets == 0) {
        salert("Invalid Choice: you do not control planets in that sector");
        return;
      }
    }


    html = '<div class="sf-readable">Select a planet in this system: </div><ul>';
    for (let i = 0; i < sys.p.length; i++) {
      if (mode == 0) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
      }
      if (mode == 1) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
      }
      if (mode == 2 && sys.p[i].owner == imperium_self.game.player) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + '</li>';
      }
    }
    html += '</ul>';


    imperium_self.updateStatus(html);

    $('.option').off();
    $('.option').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showPlanetCard(sector, s); imperium_self.showSectorHighlight(sector); });
    $('.option').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hidePlanetCard(sector, s); imperium_self.hideSectorHighlight(sector); });
    $('.option').on('click', function () {
      let pid = $(this).attr("id");
      imperium_self.hidePlanetCard(sector, pid);
      mycallback(sector, pid);
    });

  });

}



playerSelectInfluence(cost, mycallback) {

  if (cost == 0) { mycallback(1); return; }

  let imperium_self = this;
  let array_of_cards = this.returnPlayerUnexhaustedPlanetCards(this.game.player); // unexhausted
  let array_of_cards_to_exhaust = [];
  let selected_cost = 0;
  let total_trade_goods = imperium_self.game.players_info[imperium_self.game.player - 1].goods;


  let html = "<div class='sf-readable'>Select " + cost + " in influence: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    html += '<li class="cardchoice cardchoice-card" id="cardchoice_' + array_of_cards[z] + '">' + this.returnPlanetCard(array_of_cards[z]) + '</li>';
  }
  if (1 == imperium_self.game.players_info[imperium_self.game.player - 1].goods) {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade good</li>';
  } else {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade goods</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.cardchoice , .textchoice').on('click', function () {

    let action2 = $(this).attr("id");
    let tmpx = action2.split("_");

    let divid = "#" + action2;
    let y = tmpx[1];
    let idx = 0;
    for (let i = 0; i < array_of_cards.length; i++) {
      if (array_of_cards[i] === y) {
        idx = i;
      }
    }



    //
    // handle spending trade goods
    //
    if (action2 == "trade_goods") {
      if (total_trade_goods > 0) {
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tgoods\t1");
        total_trade_goods--;
        selected_cost += 1;

        if (1 == total_trade_goods) {
          $('#trade_goods').html(('' + total_trade_goods + ' trade good'));
        } else {
          $('#trade_goods').html(('' + total_trade_goods + ' trade goods'));
        }
      }
    } else {
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tplanet\t" + array_of_cards[idx]);
      array_of_cards_to_exhaust.push(array_of_cards[idx]);
      $(divid).off();
      $(divid).css('opacity', '0.2');
      selected_cost += imperium_self.game.planets[array_of_cards[idx]].influence;
    }

    if (cost <= selected_cost) {

      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.cardchoice , .textchoice').off();

      mycallback(1);
    }

  });
}






playerSelectStrategyAndCommandTokens(cost, mycallback) {

  if (cost == 0) { mycallback(1); }

  let imperium_self = this;
  let selected_cost = 0;

  let html = "<div class='sf-readable'>Select " + cost + " in Strategy and Command Tokens: </div><ul>";
  html += '<li class="textchoice" id="strategy">strategy tokens - <span class="available_strategy_tokens">'+imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens+'</span></li>';
  html += '<li class="textchoice" id="command">command tokens - <span class="available_command_tokens">'+imperium_self.game.players_info[imperium_self.game.player-1].command_tokens+'</span></li>';
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();

  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "strategy") {
      let x = parseInt($('.available_strategy_tokens').html());
      if (x > 0) {
        selected_cost++;
        $('.available_strategy_tokens').html((x-1));
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      }
    }
    if (action2 == "command") {
      let x = parseInt($('.available_command_tokens').html());
      if (x > 0) {
        selected_cost++;
        $('.available_command_tokens').html((x-1));
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tcommand\t1");
      }
    }

    if (cost <= selected_cost) { 
      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.textchoice').off();
      mycallback(1); 
    }

  });

}



playerSelectResources(cost, mycallback) {

  if (cost == 0) { mycallback(1); return; }

  let imperium_self = this;
  let array_of_cards = this.returnPlayerUnexhaustedPlanetCards(this.game.player); // unexhausted
  let array_of_cards_to_exhaust = [];
  let selected_cost = 0;
  let total_trade_goods = imperium_self.game.players_info[imperium_self.game.player - 1].goods;

  let html = "<div class='sf-readable'>Select " + cost + " in resources: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    html += '<li class="cardchoice cardchoice-card" id="cardchoice_' + array_of_cards[z] + '">' + this.returnPlanetCard(array_of_cards[z]) + '</li>';
  }
  if (1 == imperium_self.game.players_info[imperium_self.game.player - 1].goods) {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade good</li>';
  } else {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade goods</li>';
  }
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();

  $('.cardchoice , .textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    let tmpx = action2.split("_");

    let divid = "#" + action2;
    let y = tmpx[1];
    let idx = 0;
    for (let i = 0; i < array_of_cards.length; i++) {
      if (array_of_cards[i] === y) {
        idx = i;
      }
    }

    //
    // handle spending trade goods
    //
    if (action2 == "trade_goods") {
      if (total_trade_goods > 0) {
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tgoods\t1");
        total_trade_goods--;
        selected_cost += 1;

        if (1 == total_trade_goods) {
          $('#trade_goods').html(('' + total_trade_goods + ' trade good'));
        } else {
          $('#trade_goods').html(('' + total_trade_goods + ' trade goods'));
        }
      }
    } else {
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tplanet\t" + array_of_cards[idx]);
      array_of_cards_to_exhaust.push(array_of_cards[idx]);
      $(divid).off();
      $(divid).css('opacity', '0.2');
      selected_cost += parseInt(imperium_self.game.planets[array_of_cards[idx]].resources);
    }

    if (cost <= selected_cost) { 

      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.cardchoice , .textchoice').off();

      mycallback(1); 

    }

  });

}








playerSelectActionCard(mycallback, cancel_callback, types = []) {

  let imperium_self = this;
  let array_of_cards = this.returnPlayerActionCards(this.game.player, types);
  if (array_of_cards.length == 0) {
    this.playerAcknowledgeNotice("You do not have any action cards that can be played now", function () {
      if (cancel_callback != null) { cancel_callback(); return 0; }
      imperium_self.playerTurn();
      return 0;
    });
    return 0;
  }

  let html = '';

  html += "<div class='sf-readable'>Select an action card: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    if (!this.game.players_info[this.game.player - 1].action_cards_played.includes(array_of_cards[z])) {
      let thiscard = imperium_self.action_cards[array_of_cards[z]];
      html += '<li class="textchoice pointer" id="' + array_of_cards[z] + '">' + thiscard.name + '</li>';
    }
  }
  html += '<li class="textchoice pointer" id="cancel">cancel</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showActionCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideActionCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 != "cancel") { imperium_self.hideActionCard(action2); }
    if (action2 === "cancel") { cancel_callback(); return 0; }

    if (imperium_self.game.tracker) { imperium_self.game.tracker.action_card = 1; }
    if (imperium_self.action_cards[action2].type == "action") { imperium_self.game.state.active_player_moved = 1; }

    imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(action2);

    mycallback(action2);

  });

}


//
// this is when players are choosing to play the cards that they have 
// already chosen.
//
playerSelectStrategyCard(mycallback, mode = 0) {

  let array_of_cards = this.game.players_info[this.game.player - 1].strategy;
  let strategy_cards = this.returnStrategyCards();
  let imperium_self = this;

  let html = "";

  html += "<div class='sf-readable'>Select a strategy card: </div><ul>";
  for (let z in array_of_cards) {
    if (!this.game.players_info[this.game.player - 1].strategy_cards_played.includes(array_of_cards[z])) {
      html += '<li class="textchoice" id="' + array_of_cards[z] + '">' + strategy_cards[array_of_cards[z]].name + '</li>';
    }
  }
  html += '<li class="textchoice pointer" id="cancel">cancel</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showStrategyCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideStrategyCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 != "cancel") { imperium_self.hideStrategyCard(action2); }

    if (action2 === "cancel") {
      imperium_self.playerTurn();
      return;
    }

    mycallback(action2);

  });
}




//
// this is when players select at the begining of the round, not when they 
// are chosing to play the cards that they have already selected
//
playerSelectStrategyCards(mycallback) {

  let imperium_self = this;
  let cards = this.returnStrategyCards();
  let playercol = "player_color_" + this.game.player;
  let relevant_action_cards = ["strategy"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);


  let html = "<div class='terminal_header'><div class='player_color_box " + playercol + "'></div>" + this.returnFaction(this.game.player) + ": select your strategy card:</div><ul>";
  if (this.game.state.round > 1) {
    html = "<div class='terminal_header'>" + this.returnFaction(this.game.player) + ": select your strategy card:</div><ul>";
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  let scards = [];

  for (let z in this.strategy_cards) {
    scards.push("");
  }

  for (let z = 0; z < this.game.state.strategy_cards.length; z++) {
    let rank = parseInt(this.strategy_cards[this.game.state.strategy_cards[z]].rank);
    while (scards[rank - 1] != "") { rank++; }
    scards[rank - 1] = '<li class="textchoice" id="' + this.game.state.strategy_cards[z] + '">' + cards[this.game.state.strategy_cards[z]].name + '</li>';
  }

  for (let z = 0; z < scards.length; z++) {
    if (scards[z] != "") {
      html += scards[z];
    }
  }

  html += '</ul></p>';
  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showStrategyCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideStrategyCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("pickstrategy\t" + imperium_self.game.player);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
        return 0;
      }, function () {
        imperium_self.playerSelectActionCards(action_card_player, card);
      }, ["action"]);
      return 0;
    }

    imperium_self.hideStrategyCard(action2);
    mycallback(action2);
  });

}



playerRemoveInfantryFromPlanets(player, total = 1, mycallback) {

  let imperium_self = this;

  let html = '';
  html += '<div class="sf-readable">Remove ' + total + ' infantry from planets you control:</div>';
  html += '<ul>';

  let infantry_to_remove = [];

  for (let s in this.game.planets) {
    let planet = this.game.planets[s];
    if (planet.owner == player) {
      let infantry_available_here = 0;
      for (let ss = 0; ss < planet.units[player - 1].length; ss++) {
        if (planet.units[player - 1][ss].type == "infantry") { infantry_available_here++; }
      }
      if (infantry_available_here > 0) {
        html += '<li class="option textchoice" id="' + s + '">' + planet.name + ' - <div style="display:inline" id="' + s + '_infantry">' + infantry_available_here + '</div></li>';
      }
    }
  }
  html += '<li class="option textchoice" id="end"></li>';
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "end") {

      for (let i = 0; i < infantry_to_remove.length; i++) {

        let planet_in_question = imperium_self.game.planets[infantry_to_remove[i].planet];

        let total_units_on_planet = planet_in_question.units[player - 1].length;
        for (let ii = 0; ii < total_units_on_planet; ii++) {
          let thisunit = planet_in_question.units[player - 1][ii];
          if (thisunit.type == "infantry") {
            planet_in_question.units[player - 1].splice(ii, 1);
            ii = total_units_on_planet + 2; // 0 as player_moves below because we have removed above
            imperium_self.addMove("remove_infantry_from_planet\t" + player + "\t" + infantry_to_remove[i].planet + "\t" + "0");
            imperium_self.addMove("NOTIFY\tREMOVING INFANTRY FROM PLANET: " + infantry_to_remove[i].planet);
          }
        }
      }
      mycallback(infantry_to_remove.length);
      return;
    }

    infantry_to_remove.push({ infantry: 1, planet: action2 });
    let divname = "#" + action2 + "_infantry";
    let existing_infantry = $(divname).html();
    let updated_infantry = parseInt(existing_infantry) - 1;
    if (updated_infantry < 0) { updated_infantry = 0; }

    $(divname).html(updated_infantry);

    if (updated_infantry == 0) {
      $(this).remove();
    }

    if (infantry_to_remove.length >= total) {
      $('#end').click();
    }

  });

}

playerAddInfantryToPlanets(player, total = 1, mycallback) {

  let imperium_self = this;

  let html = '';
  html += '<div class="sf-readable">Add ' + total + ' infantry to planets you control:</div>';
  html += '<ul>';

  let infantry_to_add = [];

  for (let s in this.game.planets) {
    let planet = this.game.planets[s];
    if (planet.owner == player) {
      let infantry_available_here = 0;
      for (let ss = 0; ss < planet.units[player - 1].length; ss++) {
        if (planet.units[player - 1][ss].type == "infantry") { infantry_available_here++; }
      }
      html += '<li class="option textchoice" id="' + s + '">' + planet.name + ' - <div style="display:inline" id="' + s + '_infantry">' + infantry_available_here + '</div></li>';
    }
  }
  html += '<li class="option textchoice" id="end"></li>';
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "end") {
      for (let i = 0; i < infantry_to_add.length; i++) {
        imperium_self.addMove("add_infantry_to_planet\t" + player + "\t" + infantry_to_add[i].planet + "\t" + "1");
      }
      mycallback(infantry_to_add.length);
      return;
    }

    infantry_to_add.push({ infantry: 1, planet: action2 });
    let divname = "#" + action2 + "_infantry";
    let existing_infantry = $(divname).html();
    let updated_infantry = parseInt(existing_infantry) + 1;

    $(divname).html(updated_infantry);

    if (infantry_to_add.length >= total) {
      $('#end').click();
    }

  });

}


//////////////////////////
// Select Units to Move //
//////////////////////////
playerSelectUnitsToMove(destination) {

  let imperium_self = this;
  let html = '';
  let hops = 3;
  let sectors = [];
  let distance = [];
  let hazards = [];
  let hoppable = [];
  let fighters_loaded = 0;
  let infantry_loaded = 0;

  let obj = {};
  obj.max_hops = 2;
  obj.ship_move_bonus = this.game.players_info[this.game.player - 1].ship_move_bonus + this.game.players_info[this.game.player - 1].temporary_ship_move_bonus;
  obj.fleet_move_bonus = this.game.players_info[this.game.player - 1].fleet_move_bonus + this.game.players_info[this.game.player - 1].temporary_fleet_move_bonus;
  obj.ships_and_sectors = [];
  obj.stuff_to_move = [];
  obj.stuff_to_load = [];
  obj.distance_adjustment = 0;

  obj.max_hops += obj.ship_move_bonus;
  obj.max_hops += obj.fleet_move_bonus;

  let x = imperium_self.returnSectorsWithinHopDistance(destination, obj.max_hops, imperium_self.game.player);
  sectors = x.sectors;
  distance = x.distance;
  hazards = x.hazards;
  hoppable = x.hoppable;

  for (let i = 0; i < distance.length; i++) {
    if (obj.ship_move_bonus > 0) {
      distance[i]--;
    }
    if (obj.fleet_move_bonus > 0) {
      distance[i]--;
    }
  }

  if (obj.ship_move_bonus > 0) {
    obj.distance_adjustment += obj.ship_move_bonus;
  }
  if (obj.fleet_move_bonus > 0) {
    obj.distance_adjustment += obj.fleet_move_bonus;
  }

  obj.ships_and_sectors = imperium_self.returnShipsMovableToDestinationFromSectors(destination, sectors, distance, hazards, hoppable);

  let updateInterface = function (imperium_self, obj, updateInterface) {

    let subjective_distance_adjustment = 0;
    if (obj.ship_move_bonus > 0) {
      subjective_distance_adjustment += obj.ship_move_bonus;
    }
    if (obj.fleet_move_bonus > 0) {
      subjective_distance_adjustment += obj.fleet_move_bonus;
    }
    let spent_distance_boost = (obj.distance_adjustment - subjective_distance_adjustment);

    let playercol = "player_color_" + imperium_self.game.player;
    let html = "<div class='player_color_box " + playercol + "'></div> " + imperium_self.returnFaction(imperium_self.game.player) + ': select ships to move<ul>';

    //
    // select ships
    //
    for (let i = 0; i < obj.ships_and_sectors.length; i++) {

      let sys = imperium_self.returnSectorAndPlanets(obj.ships_and_sectors[i].sector);
      html += '<b class="sector_name" id="' + obj.ships_and_sectors[i].sector + '" style="margin-top:10px">' + sys.s.name + '</b>';
      html += '<ul class="ship_selector">';
      for (let ii = 0; ii < obj.ships_and_sectors[i].ships.length; ii++) {

        //
        // figure out if we can still move this ship
        //
        let already_moved = 0;
        for (let z = 0; z < obj.stuff_to_move.length; z++) {
          if (obj.stuff_to_move[z].already_moved == 1) {
            already_moved = 1;
          }
          if (obj.stuff_to_move[z].sector == obj.ships_and_sectors[i].sector) {
            if (obj.stuff_to_move[z].i == i) {
              if (obj.stuff_to_move[z].ii == ii) {
                already_moved = 1;
              }
            }
          }
        }

	let rift_passage = 0;
	if (obj.ships_and_sectors[i].hazards[ii] === "rift") { rift_passage = 1; }

        if (already_moved == 1) {
          if (rift_passage == 0) {
            html += `<li id="sector_${i}_${ii}" class=""><b>${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</b></li>`;
	  } else {
            html += `<li id="sector_${i}_${ii}" class=""><b>${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</b> - rift</li>`;
	  }
        } else {
          if (obj.ships_and_sectors[i].ships[ii].move - (obj.ships_and_sectors[i].adjusted_distance[ii] + spent_distance_boost) >= 0) {
            if (rift_passage == 0) {
	      html += `<li id="sector_${i}_${ii}" class="option">${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</li>`;
            } else {
	      html += `<li id="sector_${i}_${ii}" class="option">${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])} - rift</li>`;
	    }
          }
        }
      }

      html += '</ul>';
    }
    html += '<hr />';
    html += '<div id="confirm" class="option">click here to move</div>';
//    html += '<hr />';
//    html += '<div id="clear" class="option">clear selected</div>';
    html += '<hr />';
    imperium_self.updateStatus(html);

    //
    // add hover / mouseover to sector names
    //
    let adddiv = ".sector_name";
    $(adddiv).on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.addSectorHighlight(s); });
    $(adddiv).on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.removeSectorHighlight(s); });


    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");

      //
      // submit when done
      //
      if (id == "confirm") {

        imperium_self.addMove("resolve\tplay");
        // source should be OK as moving out does not add units
        imperium_self.addMove("space_invasion\t" + imperium_self.game.player + "\t" + destination);
        imperium_self.addMove("check_fleet_supply\t" + imperium_self.game.player + "\t" + destination);
        for (let y = 0; y < obj.stuff_to_move.length; y++) {

	  let this_ship_i = obj.stuff_to_move[y].i;
	  let this_ship_ii = obj.stuff_to_move[y].ii;
	  let this_ship_hazard = obj.ships_and_sectors[this_ship_i].hazards[this_ship_ii];

          imperium_self.addMove("move\t" + imperium_self.game.player + "\t" + 1 + "\t" + obj.ships_and_sectors[obj.stuff_to_move[y].i].sector + "\t" + destination + "\t" + JSON.stringify(obj.ships_and_sectors[obj.stuff_to_move[y].i].ships[obj.stuff_to_move[y].ii]) + "\t" + this_ship_hazard);
        }
        for (let y = obj.stuff_to_load.length - 1; y >= 0; y--) {
          imperium_self.addMove("load\t" + imperium_self.game.player + "\t" + 0 + "\t" + obj.stuff_to_load[y].sector + "\t" + obj.stuff_to_load[y].source + "\t" + obj.stuff_to_load[y].source_idx + "\t" + obj.stuff_to_load[y].unitjson + "\t" + obj.stuff_to_load[y].shipjson);
        }

        imperium_self.endTurn();
        return;
      };

      //
      // clear the list to start again
      //
      if (id == "clear") {
        salert("To change movement options, please reload!");
	window.location.reload(true);
        return;
      }


      //
      // highlight ship on menu
      //
      $(this).css("font-weight", "bold");
      this.classList.add("ship_selected");

      //
      //  figure out if we need to load infantry / fighters
      //
      let tmpx = id.split("_");
      let i = tmpx[1];
      let ii = tmpx[2];
      let calcdist = obj.ships_and_sectors[i].distance;
      let sector = obj.ships_and_sectors[i].sector;
      let sys = imperium_self.returnSectorAndPlanets(sector);
      let ship = obj.ships_and_sectors[i].ships[ii];
      let total_ship_capacity = imperium_self.returnRemainingCapacity(ship);
      let x = { i: i, ii: ii, sector: sector };


      //
      // calculate actual distance
      //
      let real_distance = calcdist + obj.distance_adjustment;
      let free_distance = ship.move + obj.fleet_move_bonus;

      if (real_distance > free_distance) {
        //
        // 
        //
        obj.ship_move_bonus--;
      }


      //
      // if this is a fighter, remove it from the underlying
      // list of units we can move, so that it is not double-added
      //
      if (ship.type == "fighter") {
        obj.ships_and_sectors[i].ships[ii].already_moved = 1;
      }




      obj.stuff_to_move.push(x);
      updateInterface(imperium_self, obj, updateInterface);


      //
      // is there stuff left to move?
      //
      let stuff_available_to_move = 0;
      for (let i = 0; i < sys.p.length; i++) {
        let planetary_units = sys.p[i].units[imperium_self.game.player - 1];
        for (let k = 0; k < planetary_units.length; k++) {
          if (planetary_units[k].type == "infantry") {
            stuff_available_to_move++;
          }
        }
      }
      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].type == "fighter") {
          stuff_available_to_move++;
        }
      }


      //
      // remove already-moved fighters from stuff-available-to-move
      // 
      let fighters_available_to_move = 0;
      for (let iii = 0; iii < sys.s.units[imperium_self.game.player - 1].length; iii++) {
        if (sys.s.units[imperium_self.game.player - 1][iii].type == "fighter") {
          let fighter_already_moved = 0;
          for (let z = 0; z < obj.stuff_to_move.length; z++) {
            if (obj.stuff_to_move[z].sector == sector) {
              if (obj.stuff_to_move[z].ii == iii) {
                fighter_already_moved = 1;
              }
            }
          }
          if (fighter_already_moved == 1) {
            stuff_available_to_move--;
          }
        }
      }


      if (total_ship_capacity > 0 && stuff_available_to_move > 0) {
        let remove_what_capacity = 0;
        for (let z = 0; z < obj.stuff_to_load.length; z++) {
          let x = obj.stuff_to_load[z];
          if (x.i == i && x.ii == ii) {
            let thisunit = JSON.parse(obj.stuff_to_load[z].unitjson);
            remove_what_capacity += thisunit.capacity_required;
          }
        }


        let user_message = `<div class="sf-readable">This ship has <span class="capacity_remaining">${total_ship_capacity}</span> capacity. Infantry can capture planets and fighters can protect your fleet. Do you wish to add them? </div><ul>`;

        for (let i = 0; i < sys.p.length; i++) {
          let planetary_units = sys.p[i].units[imperium_self.game.player - 1];
          let infantry_available_to_move = 0;
          for (let k = 0; k < planetary_units.length; k++) {
            if (planetary_units[k].type == "infantry") {
              infantry_available_to_move++;
            }
          }
          if (infantry_available_to_move > 0) {
            user_message += '<li class="option textchoice" id="addinfantry_p_' + i + '">add infantry from ' + sys.p[i].name + ' - <span class="add_infantry_remaining_' + i + '">' + infantry_available_to_move + '</span></li>';
          }
        }

        let fighters_available_to_move = 0;
        for (let iii = 0; iii < sys.s.units[imperium_self.game.player - 1].length; iii++) {
          if (sys.s.units[imperium_self.game.player - 1][iii].type == "fighter") {
            let fighter_already_moved = 0;
            for (let z = 0; z < obj.stuff_to_move.length; z++) {
              if (obj.stuff_to_move[z].sector == sector) {
                if (obj.stuff_to_move[z].ii == iii) {
                  fighter_already_moved = 1;
                }
              }
            }
            if (fighter_already_moved == 0) {
              fighters_available_to_move++;
            }
          }
        }
        user_message += '<li class="option textchoice" id="addfighter_s_s">add fighter - <span class="add_fighters_remaining">' + fighters_available_to_move + '</span></li>';
        user_message += '<li class="option textchoice" id="skip">finish</li>';
        user_message += '</ul></div>';


        //
        // choice
        //
        $('.status-overlay').html(user_message);
        $('.status-overlay').show();
        $('.status').hide();
        $('.textchoice').off();

        //
        // add hover / mouseover to message
        //
        for (let i = 0; i < sys.p.length; i++) {
          adddiv = "#addinfantry_p_" + i;
          $(adddiv).on('mouseenter', function () { imperium_self.addPlanetHighlight(sector, i); });
          $(adddiv).on('mouseleave', function () { imperium_self.removePlanetHighlight(sector, i); });
        }
        adddiv = "#addfighter_s_s";
        $(adddiv).on('mouseenter', function () { imperium_self.addSectorHighlight(sector); });
        $(adddiv).on('mouseleave', function () { imperium_self.removeSectorHighlight(sector); });


        // leave action enabled on other panels
        $('.textchoice').on('click', function () {

          let id = $(this).attr("id");
          let tmpx = id.split("_");
          let action2 = tmpx[0];

          if (total_ship_capacity > 0) {

            if (action2 === "addinfantry") {

              let planet_idx = tmpx[2];
              let irdiv = '.add_infantry_remaining_' + planet_idx;
              let ir = parseInt($(irdiv).html());
              let ic = parseInt($('.capacity_remaining').html());

              //
              // we have to load prematurely. so JSON will be accurate when we move the ship, so player_move is 0 for load
              //
              let unitjson = imperium_self.unloadUnitFromPlanet(imperium_self.game.player, sector, planet_idx, "infantry");
              let shipjson_preload = JSON.stringify(sys.s.units[imperium_self.game.player - 1][obj.ships_and_sectors[i].ship_idxs[ii]]);
              imperium_self.loadUnitByJSONOntoShip(imperium_self.game.player, sector, obj.ships_and_sectors[i].ship_idxs[ii], unitjson);

              $(irdiv).html((ir - 1));
              $('.capacity_remaining').html((ic - 1));

              let loading = {};
              loading.sector = sector;
              loading.source = "planet";
              loading.source_idx = planet_idx;
              loading.unitjson = unitjson;
              loading.ship_idx = obj.ships_and_sectors[i].ship_idxs[ii];
              loading.shipjson = shipjson_preload;
              loading.i = i;
              loading.ii = ii;

              total_ship_capacity--;

              obj.stuff_to_load.push(loading);

              if (ic === 1 && total_ship_capacity == 0) {
                $('.status').show();
                $('.status-overlay').hide();
              }

            }


            if (action2 === "addfighter") {

              if (fighters_available_to_move <= 0) { return; }

              let ir = parseInt($('.add_fighters_remaining').html());
              let ic = parseInt($('.capacity_remaining').html());
              $('.add_fighters_remaining').html((ir - 1));
              fighters_available_to_move--;
              $('.capacity_remaining').html((ic - 1));

              //
              // remove this fighter ...
              //
              let secs_to_check = obj.ships_and_sectors.length;
              for (let sec = 0; sec < obj.ships_and_sectors.length; sec++) {
                if (obj.ships_and_sectors[sec].sector === sector) {
                  let ships_to_check = obj.ships_and_sectors[sec].ships.length;
                  for (let f = 0; f < ships_to_check; f++) {
                    if (obj.ships_and_sectors[sec].ships[f].already_moved == 1) { } else {
                      if (obj.ships_and_sectors[sec].ships[f].type == "fighter") {

                        // remove fighter from status menu
                        let status_div = '#sector_' + sec + '_' + f;
                        $(status_div).remove();

                        // remove from arrays (as loaded)
                        // removed fri june 12
                        //obj.ships_and_sectors[sec].ships.splice(f, 1);
                        //obj.ships_and_sectors[sec].adjusted_distance.splice(f, 1);
                        obj.ships_and_sectors[sec].ships[f] = {};
                        obj.ships_and_sectors[sec].adjusted_distance[f] = 0;
                        f = ships_to_check + 2;
                        sec = secs_to_check + 2;

                      }
                    }
                  }
                }
              }

              let unitjson = imperium_self.removeSpaceUnit(imperium_self.game.player, sector, "fighter");
              let shipjson_preload = JSON.stringify(sys.s.units[imperium_self.game.player - 1][obj.ships_and_sectors[i].ship_idxs[ii]]);

              imperium_self.loadUnitByJSONOntoShip(imperium_self.game.player, sector, obj.ships_and_sectors[i].ship_idxs[ii], unitjson);

              let loading = {};
              obj.stuff_to_load.push(loading);

              loading.sector = sector;
              loading.source = "ship";
              loading.source_idx = "";
              loading.unitjson = unitjson;
              loading.ship_idx = obj.ships_and_sectors[i].ship_idxs[ii];
              loading.shipjson = shipjson_preload;
              loading.i = i;
              loading.ii = ii;

              total_ship_capacity--;

              if (ic == 1 && total_ship_capacity == 0) {
                $('.status').show();
                $('.status-overlay').hide();
              }
            }
          } // total ship capacity

          if (action2 === "skip") {
            $('.status-overlay').hide();
            $('.status').show();
          }

        });
      }
    });
  };

  updateInterface(imperium_self, obj, updateInterface);

  return;

}

//////////////////////////
// Select Units to Move //
//////////////////////////
playerSelectInfantryToLand(sector) {

  let imperium_self = this;
  let html = '<div id="status-message" class="imperial-status-message">Unload Infantry (source): <ul>';
  let sys = imperium_self.returnSectorAndPlanets(sector);

  let space_infantry = [];
  let ground_infantry = [];

  for (let i = 0; i < sys.s.units[this.game.player-1].length; i++) {
    let unit = sys.s.units[this.game.player-1][i];
    if (imperium_self.returnInfantryInUnit(unit) > 0) { 
      html += `<li class="option textchoice" id="addinfantry_s_${i}">remove infantry from ${unit.name} - <span class="add_infantry_remaining_s_${i}">${imperium_self.returnInfantryInUnit(unit)}</span></li>`;
    }
  }

  for (let p = 0; p < sys.p.length; p++) {
    let planet = sys.p[p];
    if (imperium_self.returnInfantryOnPlanet(planet) > 0) { 
      html += `<li class="option textchoice" id="addinfantry_p_${p}">remove infantry from ${planet.name} - <span class="add_infantry_remaining_p_${p}">${imperium_self.returnInfantryOnPlanet(planet)}</span></li>`;
    }
  }

  html += '</ul>';
  html += '</div>';

  html += '<div id="confirm" class="option">click here to move</div>';
//  html += '<hr />';
//  html += '<div id="clear" class="option">clear selected</div>';
  imperium_self.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let id = $(this).attr("id");
    let assigned_planets = [];
    let infantry_available_for_reassignment = 0;
    for (let i = 0; i < sys.p.length; i++) {
      assigned_planets.push(0);
    }

    //
    // submit when done
    //
    if (id == "confirm") {

      for (let i = 0; i < space_infantry.length; i++) {
	imperium_self.addMove("unload_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"ship"+"\t"+space_infantry[i].ship_idx);
        infantry_available_for_reassignment++;
      }
      for (let i = 0; i < ground_infantry.length; i++) {
	imperium_self.addMove("unload_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"planet"+"\t"+ground_infantry[i].planet_idx);
        infantry_available_for_reassignment++;
      }

      let html = '<div class="sf-readable" id="status-message">Reassign Infantry to Planets: <ul>';
          for (let i = 0; i < sys.p.length; i++) {
	    let infantry_remaining_on_planet = imperium_self.returnInfantryOnPlanet(sys.p[i]);
	    for (let ii = 0; ii < ground_infantry.length; ii++) {
	      if (ground_infantry[ii].planet_idx == i) { infantry_remaining_on_planet--; }
	    }
  	    html += `<li class="option textchoice" id="${i}">${sys.p[i].name} - <span class="infantry_on_${i}">${infantry_remaining_on_planet}</span></li>`;
          }
          html += '<div id="confirm" class="option">click here to move</div>';
          html += '</ul'; 
          html += '</div>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "confirm") {
	  imperium_self.endTurn();
        }

        if (infantry_available_for_reassignment > 0)  {
          infantry_available_for_reassignment--;
          let divname = ".infantry_on_"+id;
          let v = parseInt($(divname).html());
          v++;
	  $(divname).html((v));
	  imperium_self.addMove("load_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"planet"+"\t"+id);
	}

      });
    };

    //
    // clear the list to start again
    //
    if (id == "clear") {
      salert("To change movement options, just reload!");
      window.location.reload(true);
    }


    //
    // otherwise we selected
    //
    let user_selected = id.split("_");
    if (user_selected[1] === "p") {
      let divname = ".add_infantry_remaining_p_"+user_selected[2];
      let v = parseInt($(divname).html());
      if (v > 0) {
        ground_infantry.push({ planet_idx : user_selected[2] });
	$(divname).html((v-1));
      }
    }
    if (user_selected[1] === "s") {
      let divname = ".add_infantry_remaining_s_"+user_selected[2];
      let v = parseInt($(divname).html());
      if (v > 0) {
        space_infantry.push({ ship_idx : user_selected[2] });
	$(divname).html((v-1));
      }
    }

  });

  return;

}



playerInvadePlanet(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);

  let total_available_infantry = 0;
  let space_transport_available = 0;
  let space_transport_used = 0;

  let landing_forces = [];
  let landing_on_planet_idx = [];
  let planets_invaded = [];

  html = '<div class="sf-readable">Which planet(s) do you invade: </div><ul>';
  for (let i = 0; i < sys.p.length; i++) {
    if (sys.p[i].owner != player) {
      html += '<li class="option sector_name" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
    }
  }
  html += '<li class="option" id="confirm">launch invasion(s)</li>';
  html += '</ul>';
  this.updateStatus(html);

  let populated_planet_forces = 0;
  let populated_ship_forces = 0;
  let forces_on_planets = [];
  let forces_on_ships = [];

  $('.option').off();
  let adiv = ".sector_name";
  $(adiv).on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.addPlanetHighlight(sector, s); });
  $(adiv).on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.removePlanetHighlight(sector, s); });
  $('.option').on('click', function () {

    let planet_idx = $(this).attr('id');

    if (planet_idx === "confirm") {

/***
      if (landing_forces.length == 0) {
	let sanity_check = confirm("Invade without landing forces? Are you sure -- the invasion will fail.");
	if (!sanity_check) { return; }
      }
***/

      for (let i = 0; i < planets_invaded.length; i++) {

	if (landing_on_planet_idx.includes(planets_invaded[i])) {

            let owner = sys.p[planets_invaded[i]].owner;

            imperium_self.prependMove("bombardment\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("bombardment_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("bombardment_post\t" + owner + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("planetary_defense\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("planetary_defense_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_start\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_end\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);

        }

      }

      imperium_self.prependMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.endTurn();
      return;
    }

    //
    // looks like we have selected a planet for invasion
    //
    if (!planets_invaded.includes(planet_idx)) {
      planets_invaded.push(planet_idx);
    }

    //
    // figure out available infantry and ships capacity
    //
    for (let i = 0; i < sys.s.units[player - 1].length; i++) {
      let unit = sys.s.units[player - 1][i];
      for (let k = 0; k < unit.storage.length; k++) {
        if (unit.storage[k].type == "infantry") {
          if (populated_ship_forces == 0) {
            total_available_infantry += 1;
          }
        }
      }
      if (sys.s.units[player - 1][i].capacity > 0) {
        if (populated_ship_forces == 0) {
          space_transport_available += sys.s.units[player - 1][i].capacity;
        }
      }
    }

    html = '<div class="sf-readable">Select Ground Forces for Invasion of ' + sys.p[planet_idx].name + ': </div><ul>';

    //
    // other planets in system
    //
    for (let i = 0; i < sys.p.length; i++) {
      forces_on_planets.push(0);
      if (space_transport_available > 0 && sys.p[i].units[player - 1].length > 0) {
        for (let j = 0; j < sys.p[i].units[player - 1].length; j++) {
          if (sys.p[i].units[player - 1][j].type == "infantry") {
            if (populated_planet_forces == 0) {
              forces_on_planets[i]++;;
            }
          }
        }
        html += '<li class="invadechoice textchoice option" id="invasion_planet_' + i + '">' + sys.p[i].name + ' - <span class="planet_' + i + '_infantry">' + forces_on_planets[i] + '</span></li>';
      }
    }
    populated_planet_forces = 1;



    //
    // ships in system
    //
    for (let i = 0; i < sys.s.units[player - 1].length; i++) {
      let ship = sys.s.units[player - 1][i];
      forces_on_ships.push(0);
      for (let j = 0; j < ship.storage.length; j++) {
        if (ship.storage[j].type === "infantry") {
          if (populated_ship_forces == 0) {
            forces_on_ships[i]++;
          }
        }
      }
      if (forces_on_ships[i] > 0) {
        html += '<li class="invadechoice textchoice" id="invasion_ship_' + i + '">' + ship.name + ' - <span class="ship_' + i + '_infantry">' + forces_on_ships[i] + '</span></li>';
      }
    }
    populated_ship_forces = 1;
    html += '<li class="invadechoice textchoice" id="finished_0_0">finish selecting</li>';
    html += '</ul></p>';


    //
    // choice
    //
    $('.status-overlay').html(html);
    $('.status').hide();
    $('.status-overlay').show();


    $('.invadechoice').off();
    $('.invadechoice').on('click', function () {

      let id = $(this).attr("id");
      let tmpx = id.split("_");

      let action2 = tmpx[0];
      let source = tmpx[1];
      let source_idx = tmpx[2];
      let counter_div = "." + source + "_" + source_idx + "_infantry";
      let counter = parseInt($(counter_div).html());

      if (action2 == "invasion") {

        if (source == "planet") {
          if (space_transport_available <= 0) { salert("Invalid Choice! No space transport available!"); return; }
          forces_on_planets[source_idx]--;
        } else {
          forces_on_ships[source_idx]--;
        }
        if (counter == 0) {
          salert("You cannot attack with forces you do not have available."); return;
        }

        let unitjson = JSON.stringify(imperium_self.returnUnit("infantry", imperium_self.game.player));

        let landing = {};
        landing.sector = sector;
        landing.source = source;
        landing.source_idx = source_idx;
        landing.planet_idx = planet_idx;
        landing.unitjson = unitjson;

        landing_forces.push(landing);

        let planet_counter = ".invadeplanet_" + planet_idx;
        let planet_forces = parseInt($(planet_counter).html());

        planet_forces++;
        $(planet_counter).html(planet_forces);

        counter--;
        $(counter_div).html(counter);

      }

      if (action2 === "finished") {

        for (let y = 0; y < landing_forces.length; y++) {
          imperium_self.addMove("land\t" + imperium_self.game.player + "\t" + 1 + "\t" + landing_forces[y].sector + "\t" + landing_forces[y].source + "\t" + landing_forces[y].source_idx + "\t" + landing_forces[y].planet_idx + "\t" + landing_forces[y].unitjson);
	  if (!landing_on_planet_idx.includes(landing_forces[y].planet_idx)) { landing_on_planet_idx.push(landing_forces[y].planet_idx); }
        };
        landing_forces = [];
	

        $('.status').show();
        $('.status-overlay').hide();

        return;
      }
    });
  });
}



playerActivateSystem() {

  let imperium_self = this;
  let html = "Select a sector to activate: ";
  let activated_once = 0;
  let xpos = 0;
  let ypos = 0;

  imperium_self.updateStatus(html);

  $('.sector').off();
  $('.sector').on('mousedown', function (e) {
    xpos = e.clientX;
    ypos = e.clientY;
  });
  $('.sector').on('mouseup', function (e) {

    if (Math.abs(xpos-e.clientX) > 4) { return; }
    if (Math.abs(ypos-e.clientY) > 4) { return; }

    //
    // only allowed 1 at a time
    //
    if (activated_once == 1) { return; }

    let pid = $(this).attr("id");

    if (imperium_self.canPlayerActivateSystem(pid) == 0) {
      salert("You cannot activate that system.");
    } else {

      let sys = imperium_self.returnSectorAndPlanets(pid);

      //
      // sanity check on whether we want to do this
      //
      let do_we_permit_this_activation = 1;
      if (!imperium_self.canPlayerMoveShipsIntoSector(imperium_self.game.player, pid)) {
	let c = confirm("You cannot move ships into this sector. Are you sure you wish to activate it?");
	if (c) {
        } else {
	  return;
	}
      }
 
      //
      // if this is our homeworld, it is round 1 and we haven't moved ships out, we may not 
      // understand 
      //
      if (imperium_self.returnPlayerHomeworldSector() == sys.s.sector && imperium_self.game.state.round == 1) {
	let confirm_choice = confirm("If you activate your homeworld you will not be able to move ships out of it until Round 2. Are you sure you want to do this?");
	if (!confirm_choice) { return; }
      }


      activated_once = 1;
      let divpid = '#' + pid;

      $(divpid).find('.hex_activated').css('background-color', 'var(--p' + imperium_self.game.player + ')');
      $(divpid).find('.hex_activated').css('opacity', '0.3');


      let chtml = "<div class='sf-readable'>Activate this system?</div><ul>";
          chtml += '<li class="option" id="yes">yes, do it</li>';
          chtml += '<li class="option" id="no">choose again</li>';
          chtml += '</ul>';

      imperium_self.updateStatus(chtml);
      
      $('.option').off();
      $('.option').on('click', function() {

        let action2 = $(this).attr("id");

        if (action2 === "yes") {
          sys.s.activated[imperium_self.game.player - 1] = 1;
          imperium_self.addMove("activate_system_post\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("pds_space_attack_post\t"+imperium_self.game.player+"\t"+pid);
          imperium_self.addMove("pds_space_attack\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("activate_system\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("expend\t" + imperium_self.game.player + "\t" + "command" + "\t" + 1);
          imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "1");
          imperium_self.endTurn();

        } else {

          activated_once = 0;
          $(divpid).find('.hex_activated').css('background-color', 'transparent');
          $(divpid).find('.hex_activated').css('opacity', '1');

	  imperium_self.playerActivateSystem();

        }
      });
    }

  });
}


//
// if we have arrived here, we are ready to continue with our options post
// systems activation, which are move / pds combat / space combat / bombardment
// planetary invasion / ground combat
//
playerPostActivateSystem(sector) {

  let imperium_self = this;
  let relevant_action_cards = ["post_activate_system"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);
  let player = imperium_self.game.player;

  let html = "<div class='sf-readable'>" + this.returnFaction(this.game.player) + ": </div><ul>";

  if (imperium_self.canPlayerMoveShipsIntoSector(player, sector)) {
    html += '<li class="option" id="move">move into sector</li>';
  }


  if (this.canPlayerInvadePlanet(player, sector) && this.game.tracker.invasion == 0) {
    if (sector == "new-byzantium" || sector == "4_4") {
      if ((imperium_self.game.planets['new-byzantium'].owner != -1) || (imperium_self.returnAvailableInfluence(imperium_self.game.player) + imperium_self.game.players_info[imperium_self.game.player - 1].goods) >= 6) {
        html += '<li class="option" id="invade">invade planet</li>';
      }
    } else {
      html += '<li class="option" id="invade">invade planet</li>';
    }
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">reassign infantry</li>';
  }

  if (this.canPlayerProduceInSector(this.game.player, sector)) {
    html += '<li class="option" id="produce">produce units</li>';
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">relocate infantry</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  html += '<li class="option" id="finish">finish turn</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("activate_system_post\t" + imperium_self.game.player + "\t" + sector);
        imperium_self.game.players_info[this.game.player - 1].action_cards_played.push(card);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
      }, function () {
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, ["action"]);
    }


    if (action2 == "invade") {

      //
      // New Byzantium requires 6 influence to conquer
      //
      if (sector === "new-byzantium" || sector == "4_4") {
        if (imperium_self.game.planets['new-byzantium'].owner == -1) {
          if (imperium_self.returnAvailableInfluence(imperium_self.game.player) >= 6) {
            imperium_self.playerSelectInfluence(6, function (success) {
              imperium_self.game.tracker.invasion = 1;
              imperium_self.playerInvadePlanet(player, sector);
            });
          } else {
            salert("The first conquest of New Byzantium requires spending 6 influence, which you lack.");
            return;
          }
          return;
        }
      }

      imperium_self.game.tracker.invasion = 1;
      imperium_self.playerInvadePlanet(player, sector);
    }



    if (action2 == "land") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerSelectInfantryToLand(sector);
      return 0;
    }

    if (action2 == "move") {
      imperium_self.playerSelectUnitsToMove(sector);
    }
    if (action2 == "produce") {
      //
      // check the fleet supply and NOTIFY users if they are about to surpass it
      //
      let fleet_supply_in_sector = imperium_self.returnSpareFleetSupplyInSector(player, sector);
      if (fleet_supply_in_sector <= 1) {
        let notice = "You have no spare fleet supply in this sector. Do you still wish to produce more ships?";
        if (fleet_supply_in_sector == 1) {
          notice = "You have fleet supply for 1 additional capital ship in this sector. Do you still wish to produce more ships?";
        }
        let c = confirm(notice);
        if (c) {
          imperium_self.playerProduceUnits(sector);
        }
        return;
      }
      imperium_self.playerProduceUnits(sector);
    }
    if (action2 == "finish") {
      if (!imperium_self.moves.includes("resolve\tplay")) { imperium_self.addMove("resolve\tplay"); }
      imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
      imperium_self.endTurn();
    }
  });
}






playerAllocateNewTokens(player, tokens, resolve_needed = 1, stage = 0, leadership_primary = 0) {

  let imperium_self = this;

  if (this.game.player == player) {

    let obj = {};
    obj.current_command = this.game.players_info[player - 1].command_tokens;
    obj.current_strategy = this.game.players_info[player - 1].strategy_tokens;
    obj.current_fleet = this.game.players_info[player - 1].fleet_supply;
    obj.new_command = 0;
    obj.new_strategy = 0;
    obj.new_fleet = 0;
    obj.new_tokens = tokens;


    let updateInterface = function (imperium_self, obj, updateInterface) {

      let html = '<div class="sf-readable">You have ' + obj.new_tokens + ' tokens to allocate. How do you want to allocate them? </div><ul>';

      if (stage == 1) {
        html = '<div class="sf-readable">The Leadership card gives you ' + obj.new_tokens + ' tokens to allocate. How do you wish to allocate them? </div><ul>';
      }
      if (stage == 2) {
        html = '<div class="sf-readable">Leadership has been played and you have purchased ' + obj.new_tokens + ' additional tokens. How do you wish to allocate them? </div><ul>';
      }
      if (stage == 3) {
        html = '<div class="sf-readable">You have ' + obj.new_tokens + ' new tokens to allocate: </div><ul>';
      }

      html += '<li class="option" id="command">Command Token - ' + (parseInt(obj.current_command) + parseInt(obj.new_command)) + '</li>';
      html += '<li class="option" id="strategy">Strategy Token - ' + (parseInt(obj.current_strategy) + parseInt(obj.new_strategy)) + '</li>';
      html += '<li class="option" id="fleet">Fleet Supply - ' + (parseInt(obj.current_fleet) + parseInt(obj.new_fleet)) + '</li>';
      html += '</ul>';

      imperium_self.updateStatus(html);
      imperium_self.lockInterface();

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "strategy") {
          obj.new_strategy++;
          obj.new_tokens--;
        }

        if (id == "command") {
          obj.new_command++;
          obj.new_tokens--;
        }

        if (id == "fleet") {
          obj.new_fleet++;
          obj.new_tokens--;
        }

        if (obj.new_tokens == 0) {
          if (resolve_needed == 1) {
            if (imperium_self.game.confirms_needed > 0 && leadership_primary == 0) {
              imperium_self.addMove("resolve\ttokenallocation\t1\t" + imperium_self.app.wallet.returnPublicKey());
            } else {
              imperium_self.addMove("resolve\ttokenallocation");
            }
          }
          imperium_self.addMove("purchase\t" + player + "\tstrategy\t" + obj.new_strategy);
          imperium_self.addMove("purchase\t" + player + "\tcommand\t" + obj.new_command);
          imperium_self.addMove("purchase\t" + player + "\tfleetsupply\t" + obj.new_fleet);
          imperium_self.unlockInterface();
          imperium_self.endTurn();
        } else {
          imperium_self.unlockInterface();
          updateInterface(imperium_self, obj, updateInterface);
        }

      });
    };

    updateInterface(imperium_self, obj, updateInterface);

  }

  return 0;
}





playerSelectPlayerWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < this.game.players_info.length; i++) {
    if (filter_func(this.game.players_info[i]) == 1) {
      html += '<li class="textchoice" id="' + (i + 1) + '">' + this.returnFaction((i + 1)) + '</li>';
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();



    let action = $(this).attr("id");

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    mycallback(action);

  });
}



playerSelectSectorWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.board) {
    if (filter_func(this.game.board[i].tile) == 1) {
      html += '<li class="textchoice" id="' + i + '">' + this.game.sectors[this.game.board[i].tile].name + '</li>';
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();


  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.showSectorHighlight(s);
    }
  });
  $('.textchoice').on('mouseleave', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.hideSectorHighlight(s);
    }
  });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");

    if (action != "cancel") {
      imperium_self.hideSectorHighlight(action);
    }

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    imperium_self.updateStatus("");
    mycallback(imperium_self.game.board[action].tile);

  });
}





playerSelectChoice(msg, choices, elect = "other", mycallback = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < choices.length; i++) {
    if (elect == "player") {
      if (this.returnFaction(choices[i]) != "Unknown") {
        html += '<li class="textchoice" id="' + i + '">' + this.returnFaction(choices[i]) + '</li>';
      } else {
        html += '<li class="textchoice" id="' + i + '">' + choices[i] + '</li>';
      }
    }
    if (elect == "planet") {
      html += '<li class="textchoice" id="' + i + '">' + this.game.planets[choices[i]].name + '</li>';
    }
    if (elect == "sector") {
      html += '<li class="textchoice" id="' + i + '">' + this.game.sectors[this.game.board[choices[i]].tile].name + '</li>';
    }
    if (elect == "other") {
      html += '<li class="textchoice" id="' + i + '">' + choices[i] + '</li>';
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    mycallback(action);

  });

}










playerSelectPlanetWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.planets) {
    if (this.game.planets[i].tile != "") {
      if (filter_func(i) == 1) {
        html += '<li class="textchoice" id="' + i + '">' + this.game.planets[i].name + '</li>';
      }
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx);
      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
    }
  });
  $('.textchoice').on('mouseleave', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx);
      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
    }
  });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    if (action != "cancel") {
      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx);
      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);
    }

    if (action == "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }

    imperium_self.updateStatus("");
    imperium_self.hideSectorHighlight(action);
    mycallback(action);

  });
}




playerSelectUnitInSectorWithFilter(msg, sector, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let unit_array = [];
  let sector_array = [];
  let planet_array = [];
  let unit_idx = [];
  let exists_unit = 0;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  let sys = this.returnSectorAndPlanets(sector);

  for (let k = 0; k < sys.s.units[imperium_self.game.player - 1].length; k++) {
    if (filter_func(sys.s.units[imperium_self.game.player - 1][k])) {
      unit_array.push(sys.s.units[imperium_self.game.player - 1][k]);
      sector_array.push(sector);
      planet_array.push(-1);
      unit_idx.push(k);
      exists_unit = 1;
      html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.name + ' - ' + unit_array[unit_array.length - 1].name + '</li>';
    }
  }

// HACK
  for (let p = 0; p < sys.p.length; p++) {
    for (let k = 0; k < sys.p[p].units[imperium_self.game.player - 1].length; k++) {
      if (filter_func(sys.p[p].units[imperium_self.game.player - 1][k])) {
        unit_array.push(sys.p[p].units[imperium_self.game.player - 1][k]);
        sector_array.push(sector);
        planet_array.push(p);
        unit_idx.push(k);
        exists_unit = 1;
        html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.sector + ' / ' + sys.p[p].name + " - " + unit_array[unit_array.length - 1].name + '</li>';
      }
    }
  }

  if (exists_unit == 0) {
    html += '<li class="textchoice" id="none">no unit available</li>';
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  //    $('.textchoice').on('mouseenter', function() { 
  //      let s = $(this).attr("id"); 
  //      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  //    $('.textchoice').on('mouseleave', function() { 
  //      let s = $(this).attr("id");
  //      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
  //    });

  this.lockInterface();

  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    //      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx); 
    //      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);

    if (action === "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }
    if (action === "none") {
      let unit_to_return = { sector: "", planet_idx: "", unit_idx: -1, unit: null }
      mycallback(unit_to_return);
      return;
    }

    let unit_to_return = { sector: sector_array[action], planet_idx: planet_array[action], unit_idx: unit_idx[action], unit: unit_array[action] }
    //      imperium_self.hideSectorHighlight(action);

    imperium_self.updateStatus("");
    mycallback(unit_to_return);

  });
}






playerSelectUnitWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let unit_array = [];
  let sector_array = [];
  let planet_array = [];
  let unit_idx = [];
  let exists_unit = 0;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.sectors) {

    let sys = this.returnSectorAndPlanets(i);
    let sector = i;

    for (let k = 0; k < sys.s.units[imperium_self.game.player - 1].length; k++) {
      if (filter_func(sys.s.units[imperium_self.game.player - 1][k])) {
        unit_array.push(sys.s.units[imperium_self.game.player - 1][k]);
        sector_array.push(sector);
        planet_array.push(-1);
        unit_idx.push(k);
        exists_unit = 1;
        html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.name + ' - ' + unit_array[unit_array.length - 1].name + '</li>';
      }
    }

    for (let p = 0; p < sys.p.length; p++) {
      for (let k = 0; k < sys.p[p].units[imperium_self.game.player - 1].length; k++) {
        if (filter_func(sys.p[p].units[imperium_self.game.player - 1][k])) {
          unit_array.push(sys.p[p].units[imperium_self.game.player - 1][k]);
          sector_array.push(sector);
          planet_array.push(p);
          unit_idx.push(k);
          exists_unit = 1;
          html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.sector + ' / ' + sys.p[p].name + " - " + unit_array[unit_array.length - 1].name + '</li>';
        }
      }
    }

  }
  if (exists_unit == 0) {
    html += '<li class="textchoice" id="none">no unit available</li>';
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  //    $('.textchoice').on('mouseenter', function() { 
  //      let s = $(this).attr("id"); 
  //      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  //    $('.textchoice').on('mouseleave', function() { 
  //      let s = $(this).attr("id");
  //      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    //      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx); 
    //      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);

    if (action === "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }
    if (action === "none") {
      let unit_to_return = { sector: "", planet_idx: "", unit_idx: -1, unit: null }
      mycallback(unit_to_return);
      return;
    }

    let unit_to_return = { sector: sector_array[action], planet_idx: planet_array[action], unit_idx: unit_idx[action], unit: unit_array[action] }
    //      imperium_self.hideSectorHighlight(action);

    imperium_self.updateStatus("");
    mycallback(unit_to_return);

  });
}





playerSelectUnitInSectorFilter(msg, sector, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < this.game.players_info.length; i++) {
    for (let ii = 0; ii < sys.s.units[i].length; ii++) {
      if (filter_func(sys.s.units[i][ii]) == 1) {
        html += '<li class="textchoice" id="' + sector + '_' + i + '_' + i + '">' + this.returnFaction((i + 1)) + " - " + sys.s.units[i][ii].name + '</li>';
      }
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action = $(this).attr("id");

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    let tmpar = action.split("_");

    let s = tmpar[0];
    let p = tmpar[1];
    let unitidx = tmpar[2];

    mycallback({ sector: s, player: p, unitidx: unitidx });

  });
}



playerDiscardActionCards(num, mycallback=null) {

  let imperium_self = this;

  if (num < 0) { imperium_self.endTurn(); }

  let html = "<div class='sf-readable'>You must discard <div style='display:inline' class='totalnum' id='totalnum'>" + num + "</div> action card"; if (num > 1) { html += 's'; }; html += ':</div>';
  html += '<ul>';
  let ac_in_hand = this.returnPlayerActionCards(imperium_self.game.player);

  for (let i = 0; i < ac_in_hand.length; i++) {
    html += '<li class="textchoice" id="' + i + '">' + this.action_cards[ac_in_hand[i]].name + '</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showActionCard(ac_in_hand[s]); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideActionCard(ac_in_hand[s]); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    num--;

    $('.totalnum').html(num);
    $(this).remove();

    imperium_self.hideActionCard(action2);
    imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(ac_in_hand[action2]);
    imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");

    if (num == 0) {

      if (mycallback == null) {
        imperium_self.updateStatus("discarding...");
        imperium_self.endTurn();
      } else {
	mycallback();
      }
    }

  });

}






    this.importStrategyCard("construction", {
      name     			:       "Construction",
      rank			:	4,
      img			:	"/strategy/BUILD.png",

      text			:	"Build a PDS or Space Dock. Then build a PDS.<hr />Other players may spend a strategy token and activate a sector to build a PDS or Space Dock in it." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {
          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("strategy\t"+"construction"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
	  imperium_self.playerAcknowledgeNotice("You have played Construction. First you will have the option of producing a PDS or Space Dock. Then you will have the option of producing an additional PDS if you so choose.", function() {
            imperium_self.playerBuildInfrastructure((sector) => {
              imperium_self.playerBuildInfrastructure((sector) => {
		imperium_self.updateSectorGraphics(sector);
                imperium_self.endTurn();
              }, 2);
            }, 1);
          });
        }

      },


      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player != strategy_card_player && imperium_self.game.player == player) {

          let html = '<p>Construction has been played. Do you wish to spend 1 strategy token to build a PDS or Space Dock? This will activate the sector (if unactivated): </p><ul>';
          if (imperium_self.game.state.round == 1) { 
	    html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Construction strategy card. You may spend 1 strategy token to build a PDS or Space Dock on a planet you control (this will activate the sector). You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
	  }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            html += '<li class="option" id="yes">Yes</li>';
          }
	  html += '<li class="option" id="no">No</li>';
          html += '</ul>';
 
          imperium_self.updateStatus(html);

          imperium_self.lockInterface(); 

          $('.option').off();
          $('.option').on('click', function() {

            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();
 

            let id = $(this).attr("id");
 
            if (id == "yes") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tstrategy\t1");
              imperium_self.playerBuildInfrastructure((sector) => {
                imperium_self.addMove("activate\t"+imperium_self.game.player+"\t"+sector);
		imperium_self.updateSectorGraphics(sector);
                imperium_self.endTurn();
              }, 1);
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
          });
        }
      },
    });




    this.importStrategyCard("diplomacy", {
      name     			:       "Diplomacy",
      rank			:	2,
      img			:	"/strategy/DIPLOMACY.png",
      text			:	"Pick a sector other than New Byzantium. Other players activate it. Refresh two planets.<hr />Other players may spend a strategy token to refresh two planets." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

          imperium_self.updateStatus('Select sector to quagmire in diplomatic negotiations, and refresh any planets in that system: ');
          imperium_self.playerSelectSector(function(sector) {

	      if (sector.indexOf("_") > -1) { sector = imperium_self.game.board[sector].tile; }

              imperium_self.addMove("resolve\tstrategy");
              imperium_self.addMove("strategy\t"+"diplomacy"+"\t"+strategy_card_player+"\t2");
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player)+" uses Diplomacy to activate "+imperium_self.game.sectors[sector].name);

              for (let i = 0; i < imperium_self.game.players_info.length; i++) {
                imperium_self.addMove("activate\t"+(i+1)+"\t"+sector);
              }

              //
              // re-activate any planets in that system
              //
              let sys = imperium_self.returnSectorAndPlanets(sector);
	      if (sys.p) {
                for (let i = 0; i < sys.p.length; i++) {
                  if (sys.p[i].owner == imperium_self.game.player) {
		    for (let p in imperium_self.game.planets) {
		      if (sys.p[i] == imperium_self.game.planets[p]) {
                        imperium_self.addMove("unexhaust\t"+imperium_self.game.player+"\t"+"planet"+"\t"+p);
		      }
		    }
                  }
                }
	      }
              imperium_self.saveSystemAndPlanets(sys);
              imperium_self.endTurn();


          });
        }
	return 0;

      },

      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player != strategy_card_player && imperium_self.game.player == player) {

          let html = '<p>Do you wish to spend 1 strategy token to unexhaust two planet cards? </p><ul>';
	  if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has just played the Diplomacy strategy card. This lets you to spend 1 strategy token to unexhaust two planet cards. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
          }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) {
	    html += '<li class="option" id="yes">Yes</li>';
	  }
          html += '<li class="option" id="no">No</li>';
          html += '</ul>';
          imperium_self.updateStatus(html);

          $('.option').off();
          $('.option').on('click', function() {

            let id = $(this).attr("id");

            if (id == "yes") {

              let array_of_cards = imperium_self.returnPlayerExhaustedPlanetCards(imperium_self.game.player); // unexhausted

              let choices_selected = 0;
              let max_choices = 0;

              let html  = "<p>Select planets to unexhaust: </p><ul>";
              let divname = ".cardchoice";
              for (let z = 0; z < array_of_cards.length; z++) {
                max_choices++;
                html += '<li class="cardchoice" id="cardchoice_'+array_of_cards[z]+'">' + imperium_self.returnPlanetCard(array_of_cards[z]) + '</li>';
              }
              if (max_choices == 0) {
                html += '<li class="textchoice" id="cancel">cancel (no options)</li>';
                divname = ".textchoice";
              }
              html += '</ul>';
              if (max_choices >= 2) { max_choices = 2; }

              imperium_self.updateStatus(html);
	      imperium_self.lockInterface();

              $(divname).off();
              $(divname).on('click', function() {

	        if (!imperium_self.mayUnlockInterface()) {
	          salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
	          return;
	        }
	        imperium_self.unlockInterface();

                let action2 = $(this).attr("id");

                if (action2 === "cancel") {
                  imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	          imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
                  imperium_self.endTurn();
                  return;
                }

                let tmpx = action2.split("_");
                let divid = "#"+action2;
                let y = tmpx[1];
                let idx = 0;
                for (let i = 0; i < array_of_cards.length; i++) {
                  if (array_of_cards[i] === y) {
                    idx = i;
                  }
                }

                choices_selected++;
                imperium_self.addMove("unexhaust\t"+imperium_self.game.player+"\tplanet\t"+array_of_cards[idx]);

                $(divid).off();
                $(divid).css('opacity','0.2');

                if (choices_selected >= max_choices) {
                  imperium_self.prependMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	          imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
                  imperium_self.endTurn();
                }

              });
            }

            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }

          });

        }

      },
    });



    this.importStrategyCard("imperial", {
      name     			:       "Imperial",
      rank			:	8,
      img			:	"/strategy/EMPIRE.png",
      text			:	"You may score a public objective. If you control New Byzantium gain 1 VP. Otherwise gain a secret objective.<hr />All players score objectives in Initiative Order" ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

	  let supplementary_scoring = function() {
  	    imperium_self.playerAcknowledgeNotice("You will first be asked to score your public objective. The game will then allow other players to purchase secret objectives.", function() {
              imperium_self.addMove("resolve\tstrategy");
              imperium_self.playerScoreVictoryPoints(imperium_self, function(imperium_self, vp, objective) {

                if (vp > 0 && (imperium_self.stage_i_objectives[objective] != undefined || imperium_self.stage_ii_objectives[objective] != undefined)) {

                  if (imperium_self.stage_i_objectives[objective] != undefined) {
                    imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.endTurn();
		    });
		  } else {
                    imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.endTurn();
		    });
		  }
		} else {
                  imperium_self.addMove("score\t"+imperium_self.game.player+"\t"+"1"+"\t"+"new-byzantium");
		  imperium_self.updateStatus("scoring completed");
                  imperium_self.endTurn();
		}
              }, 1);
            });
	  };




	  let supplementary_secret = function() {
  	    imperium_self.playerAcknowledgeNotice("You will next be asked to score a public objective. The game will then allow other players to purchase secret objectives.", function() {
              imperium_self.addMove("resolve\tstrategy");
              imperium_self.playerScoreVictoryPoints(imperium_self, function(imperium_self, vp, objective) {

                if (vp > 0 && (imperium_self.stage_i_objectives[objective] != undefined || imperium_self.stage_ii_objectives[objective] != undefined)) {

                  if (imperium_self.stage_i_objectives[objective] != undefined) {
                    imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.addMove("gain\t"+strategy_card_player+"\t"+"secret_objective"+"\t"+"1");
                      for (let i = 0; i < imperium_self.game.players_info.length; i++) { imperium_self.addMove("DEAL\t6\t"+(i+1)+"\t1"); }
                      imperium_self.endTurn();
		    });
		  } else {
                    imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
	              imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective); 
	  	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
	  	      imperium_self.updateStatus("scoring completed");
                      imperium_self.addMove("gain\t"+strategy_card_player+"\t"+"secret_objective"+"\t"+"1");
                      for (let i = 0; i < imperium_self.game.players_info.length; i++) { imperium_self.addMove("DEAL\t6\t"+(i+1)+"\t1"); }
                      imperium_self.endTurn();
		    });
		  }
		} else {
                  imperium_self.addMove("gain\t"+strategy_card_player+"\t"+"secret_objective"+"\t"+"1");
                  for (let i = 0; i < imperium_self.game.players_info.length; i++) { imperium_self.addMove("DEAL\t6\t"+(i+1)+"\t1"); }
                  imperium_self.endTurn();
		}
              }, 1);
            });
	  };

	  if (imperium_self.game.planets['new-byzantium'].owner == strategy_card_player) {
	    imperium_self.playerAcknowledgeNotice("You are granted an additional Victory Point for controlling New Byzantium during Imperial Scoring", supplementary_scoring);
	  } else {
	    imperium_self.playerAcknowledgeNotice("As you do not control New Byzantium during Imperial Scoring, you will be issued an additional Secret Objective", supplementary_secret);
	  }
        }

	return 0;
      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        imperium_self.game.state.playing_strategy_card_secondary = 1;

        if (imperium_self.game.player == player) {
          if (imperium_self.game.player != strategy_card_player && imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            imperium_self.playerBuySecretObjective(2);
          } else {
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
            imperium_self.endTurn();
          }
        }

  	return 0;
      },
      strategyTertiaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        imperium_self.game.state.playing_strategy_card_secondary = 1;
        imperium_self.game.state.round_scoring = 1;

	if (player == imperium_self.game.player) {

	  let my_secret_objective = "";
	  let my_secret_vp = "";

          imperium_self.game.state.round_scoring = 2;

          imperium_self.playerScoreSecretObjective(imperium_self, function(x, vp, objective) {

	    my_secret_vp = vp;
	    my_secret_objective = objective;

            imperium_self.playerScoreVictoryPoints(imperium_self, function(x, vp, objective) {

	      imperium_self.updateStatus("scoring completed");
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);

              if (my_secret_vp > 0) { 
		
                if (imperium_self.secret_objectives[my_secret_objective] != undefined) {
                  imperium_self.secret_objectives[my_secret_objective].scoreObjective(imperium_self, player, function() {

		    imperium_self.addMove("score\t"+player+"\t"+my_secret_vp+"\t"+my_secret_objective); 

              	    if (vp > 0) {

        	      if (imperium_self.stage_i_objectives[objective] != undefined) {
        		imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
			  imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	    		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(my_secret_objective);
	      		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
			  imperium_self.endTurn();
			});
        	      }
        	      if (imperium_self.stage_ii_objectives[objective] != undefined) {
        		imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
			  imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	    		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(my_secret_objective);
	      		  imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
			  imperium_self.endTurn();
			});
        	      } 

		    } else {

	    	      imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(my_secret_objective);
		      imperium_self.endTurn();

		    }
		  });
                }
		return 0;
	      }

              if (vp > 0) {
        	if (imperium_self.stage_i_objectives[objective] != undefined) {
        	  imperium_self.stage_i_objectives[objective].scoreObjective(imperium_self, player, function() {
		    imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	            imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
		    imperium_self.endTurn();
		  });
        	}
        	if (imperium_self.stage_ii_objectives[objective] != undefined) {
        	  imperium_self.stage_ii_objectives[objective].scoreObjective(imperium_self, player, function() {
		    imperium_self.addMove("score\t"+player+"\t"+vp+"\t"+objective);
	            imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.push(objective);
		    imperium_self.endTurn();
		  });
        	}
	      } else {

	        imperium_self.endTurn();

	      }
            }, 2);

          });
  	  return 0;
        }
      }
    });




    this.importStrategyCard("leadership", {
      name     			:       "Leadership",
      rank			:	1,
      img			:	"/strategy/INITIATIVE.png",
      text			:	"You may gain and distribute three tokens.<hr />All players may purchase extra tokens at three influence per token." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

	if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {
          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("strategy\t"+"leadership"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
          imperium_self.playerAllocateNewTokens(imperium_self.game.player, 3, 0, 1, 1);
 	}

	return 0;

      },

      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (player == imperium_self.game.player) {
	  if (strategy_card_player != imperium_self.game.player) {
            imperium_self.playerBuyTokens(2);
	    return 0;
 	  } else {
            imperium_self.playerBuyTokens(2);
	    return 0;
	  }
        }

	return 1;

      },

    });




    this.importStrategyCard("politics", {
      name     			:       "Politics",
      rank			:	3,
      img			:	"/strategy/POLITICS.png",
      text			:	"Pick a new Speaker. Gain 2 action cards. Vote on two agendas if New Byzantium is controlled.<hr />Other players may spend a strategy token to purchase two action cards.",
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        //
        // card player goes for primary
        //
        if (imperium_self.game.player === strategy_card_player && player == strategy_card_player) {

          //
          // two action cards
          //
          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("gain\t"+imperium_self.game.player+"\taction_cards"+"\t"+2);
          imperium_self.addMove("DEAL\t2\t"+imperium_self.game.player+"\t2");
          imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " gains action cards");
          imperium_self.addMove("strategy\t"+"politics"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);

          //
          // pick the speaker
          //
          let factions = imperium_self.returnFactions();
          let html = 'Make which player the speaker? <ul>';
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            html += '<li class="option" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
          }
          html += '</ul>';
          imperium_self.updateStatus(html);

          let chancellor = imperium_self.game.player;
          let selected_agendas = [];

          $('.option').off();
          $('.option').on('click', function() {

            let chancellor = (parseInt($(this).attr("id")) + 1);
            let laws = imperium_self.returnAgendaCards();
            let laws_selected = 0;

	    //
	    // if New Byzantium is unoccupied, we skip the voting stage
	    //
	    imperium_self.playerAcknowledgeNotice("You will receive two action cards once other players have decided whether to purchase action cards.", function() {
              imperium_self.addMove("change_speaker\t"+chancellor);
	      imperium_self.endTurn();
	    });
	    return 0;

          });
        }
      },

      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == player) {
          if (imperium_self.game.player != strategy_card_player && imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            imperium_self.playerBuyActionCards(2);
          } else {
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
            imperium_self.endTurn();
          }
        }
      },

      strategyTertiaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        let selected_agendas = [];
        let laws = imperium_self.returnAgendaCards();
        let laws_selected = 0;

        if (imperium_self.game.player == player) {

          //
          // refresh votes --> total available
          //
          imperium_self.game.state.votes_available = [];
          imperium_self.game.state.votes_cast = [];
          imperium_self.game.state.how_voted_on_agenda = [];
          imperium_self.game.state.voted_on_agenda = [];
          imperium_self.game.state.voting_on_agenda = 0;

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            imperium_self.game.state.votes_available.push(imperium_self.returnAvailableVotes(i+1));
            imperium_self.game.state.votes_cast.push(0);
            imperium_self.game.state.how_voted_on_agenda[i] = "abstain";
            imperium_self.game.state.voted_on_agenda[i] = [];
            //
            // add extra 0s to ensure flexibility if extra agendas added
            //
            for (let z = 0; z < imperium_self.game.state.agendas_per_round+2; z++) {
              imperium_self.game.state.voted_on_agenda[i].push(0);
            }
          }
        }


        if (imperium_self.game.player === imperium_self.game.state.speaker) {

            let html = '';
            if (imperium_self.game.state.agendas_per_round == 1) {
              html += 'Select one agenda to advance for consideration in the Galactic Senate.<ul>';
            }
            if (imperium_self.game.state.agendas_per_round == 2) {
              html += 'Select two agendas to advance for consideration in the Galactic Senate.<ul>';
            }
            if (imperium_self.game.state.agendas_per_round == 3) {
              html += 'Select three agendas to advance for consideration in the Galactic Senate.<ul>';
            }

            for (i = 0; i < 3 && i < imperium_self.game.state.agendas.length; i++) {
              html += '<li class="option" id="'+imperium_self.game.state.agendas[i]+'">' + laws[imperium_self.game.state.agendas[i]].name + '</li>';
            }
            html += '</ul>';

            imperium_self.updateStatus(html);

            $('.option').off();
            $('.option').on('mouseenter', function() { let s = $(this).attr("id"); imperium_self.showAgendaCard(s); });
            $('.option').on('mouseleave', function() { let s = $(this).attr("id"); imperium_self.hideAgendaCard(s); });
            $('.option').on('click', function() {

              laws_selected++;
              selected_agendas.push($(this).attr('id'));

              $(this).hide();
              imperium_self.hideAgendaCard(selected_agendas[selected_agendas.length-1]);

              if (laws_selected >= imperium_self.game.state.agendas_per_round) {
                for (i = 1; i >= 0; i--) {
                  imperium_self.addMove("resolve_agenda\t"+selected_agendas[i]);
                  imperium_self.addMove("post_agenda_stage_post\t"+selected_agendas[i]);
                  imperium_self.addMove("post_agenda_stage\t"+selected_agendas[i]);
                  imperium_self.addMove("agenda\t"+selected_agendas[i]+"\t"+i);
                  imperium_self.addMove("pre_agenda_stage_post\t"+selected_agendas[i]);
                  imperium_self.addMove("pre_agenda_stage\t"+selected_agendas[i]);
                  imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
                }
                imperium_self.endTurn();
              }
            });
        } else {

	  imperium_self.updateStatus("The Speaker is selecting two Agendas for consideration by the Senate");

	}
      },

    });




    this.importStrategyCard("technology", {
      name     			:       "Technology",
      rank			:	7,
      img			:	"/strategy/TECH.png",
      text			:	"Research a technology. You may spend 6 resources to research another.<hr />Other players may spend a strategy token and 4 resources to research a technology" ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {
        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {
          imperium_self.playerAcknowledgeNotice("You will first have the option of researching a free-technology, and then invited to purchase an additional tech for 6 resources:", function() {
            imperium_self.playerResearchTechnology(function(tech) {
	      imperium_self.game.players_info[imperium_self.game.player-1].tech.push(tech);
              imperium_self.addMove("resolve\tstrategy");
              imperium_self.addMove("strategy\t"+"technology"+"\t"+strategy_card_player+"\t2");
              imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
              imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
              imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);
              imperium_self.endTurn();
            });
          });
        }
      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

console.log("in secondary!");

	let html = "";
	let resources_to_spend = 0;

        if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) {
 
	  resources_to_spend = imperium_self.game.players_info[imperium_self.game.player-1].cost_of_technology_secondary;
;
          html = '<p>Technology has been played. Do you wish to spend 4 resources and a strategy token to research a technology? </p><ul>';
          if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Technology strategy card. You may spend 4 resources and a strategy token to gain a permanent new unit or ability. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability?</p><ul>`;
          }

	  if (
	    imperium_self.game.players_info[player-1].permanent_research_technology_card_must_not_spend_resources == 1 ||
	    imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 1
	  ) { 
            html = '<p>Technology has been played. Do you wish to spend a strategy token to research a technology? </p><ul>';
	    resources_to_spend = 0;
	  }

	  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
	  if (available_resources >= 4 && imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            html += '<li class="option" id="yes">Yes</li>';
          }
	  html += '<li class="option" id="no">No</li>';
          html += '</ul>';
 
          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {
 
            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();

            let id = $(this).attr("id");

            if (id === "yes") {

	      imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources = 0;
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.playerSelectResources(resources_to_spend, function(success) {
                if (success == 1) {
                  imperium_self.playerResearchTechnology(function(tech) {
                    imperium_self.addMove("purchase\t"+player+"\ttechnology\t"+tech);
                    imperium_self.addMove("expend\t"+imperium_self.game.player+"\tstrategy\t1");
                    imperium_self.endTurn();
                  });
                } else {
                  imperium_self.endTurn();
                }
              });
            }
            if (id === "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
          });

	  return 0;

        } else {

          if (imperium_self.game.player != strategy_card_player) { return 0; }

	  resources_to_spend = imperium_self.game.players_info[imperium_self.game.player-1].cost_of_technology_primary;

          html = '<p>Do you wish to spend '+resources_to_spend+' resources to research an additional technology? </p><ul>';

	  if (
	    imperium_self.game.players_info[player-1].permanent_research_technology_card_must_not_spend_resources == 1 ||
	    imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 1
	  ) { 
            html = '<p>Do you wish to research an additional technology? </p><ul>';
	    resources_to_spend = 0;
	  }

	  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
	  if (available_resources >= resources_to_spend) {
            html += '<li class="option" id="yes">Yes</li>';
	  }
          html += '<li class="option" id="no">No</li>';
          html += '</ul>';

          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {

            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();


            let id = $(this).attr("id");

            if (id == "yes") {
	      imperium_self.game.players_info[player-1].temporary_research_technology_card_must_not_spend_resources == 0;
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.playerSelectResources(resources_to_spend, function(success) {
                if (success == 1) {
                  imperium_self.playerResearchTechnology(function(tech) {
                    imperium_self.addMove("purchase\t"+imperium_self.game.player+"\ttechnology\t"+tech);
                    imperium_self.endTurn();
                  });
                } else {
                }
              });
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
          });

	  return 0;

        }
      },
    });









    this.importAgendaCard('minister-of-technology', {
        name : "Minister of Technology" ,
        type : "Law" ,
        text : "Elect a player. They do not need to spend resources to research technology when the technology card is played" ,
	initialize : function(imperium_self) {
	  imperium_self.game.state.minster_of_technology = null;
	  imperium_self.game.state.minster_of_technology_player = null;
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_research_technology_card_must_not_spend_resources = 0;
	    imperium_self.game.players_info[i].permanent_research_technology_card_must_not_spend_resources = 0;
	  }
	},
        returnAgendaOptions : function(imperium_self) {
          let options = [];
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            options.push(imperium_self.returnFaction(i+1));
          }
          return options;
        },
        onPass : function(imperium_self, winning_choice) {
	  let player_number = 0;
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (imperium_self.returnFaction(i+1) == winning_choice) { player_number = i; }
	  }
          imperium_self.game.state.minister_of_technology = 1;
          imperium_self.game.state.minister_of_technology_player = player_number+1;
          imperium_self.game.players_info[player_number].permanent_research_technology_card_must_not_spend_resources = 1;

	  imperium_self.game.state.laws.push({ agenda : "minister-of-technology" , option : winning_choice });

        }
  });





    this.importActionCard('unexpected-breakthrough', {
        name : "Unexpected Breakthrough" ,
        type : "action" ,
        text : "Do not spend resources to research technology the next time the Technology card is played" ,
        playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_research_technology_card_must_not_spend_resources = 1;
          return 1;
        }
    });






    this.importStrategyCard("trade", {
      name     			:       "Trade",
      rank			:	5,
      img			:	"/strategy/TRADE.png",
      text			:	"Gain 3 trade goods. Refresh your commodities and those of any other players.<hr />Unrefreshed players may spend a strategy token to refresh their commodities." ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

          imperium_self.addMove("resolve\tstrategy");
          imperium_self.addMove("strategy\t"+"trade"+"\t"+strategy_card_player+"\t2");
          imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
          imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
          imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t3");
          imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tcommodities\t"+imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit);
 
          let factions = imperium_self.returnFactions();
          let html = '<p>You will receive 3 trade goods and '+imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit+' commodities. You may choose to replenish the commodities of any other players: </p><ul>';
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            if (i != imperium_self.game.player-1) {
              html += '<li class="option" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
            }
          }
          html += '<li class="option" id="finish">done</li>';
 
          imperium_self.updateStatus(html);
 
          $('.option').off();
          $('.option').on('click', function() {
            let id = $(this).attr("id");
            if (id != "finish") {
              imperium_self.addMove("purchase\t"+(parseInt(id)+1)+"\tcommodities\t"+imperium_self.game.players_info[id].commodity_limit);
              $(this).hide();
            } else {
              imperium_self.endTurn();
            }
          });

        }

      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) {

	  if (imperium_self.game.players_info[player-1].commodities == imperium_self.game.players_info[player-1].commodity_limit) { 
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
	    imperium_self.updateLog(imperium_self.returnFaction(player) + " skips the Trade secondary as they have already refreshed commodities");
            imperium_self.endTurn();
	    return 1;
	  }

          let html = '<p>Trade has been played. Do you wish to spend 1 strategy token to refresh your commodities? </p><ul>';
          if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Trade strategy card. You may spend 1 strategy token to refresh your faction commodities, which may be exchanged with your neighbours on the board for trade goods. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
          }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0) {
            html += '<li class="option" id="yes">Yes</li>';
          }
          html += '<li class="option" id="no">No</li>';
	  html += '</ul>';


	  if (imperium_self.game.players_info[imperium_self.game.player-1].commodities == imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit) {
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
	    imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " already has commodities and skips trade secondary");
	    imperium_self.endTurn();
	    return 0;
	  }


          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {
 
            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();

            $('.option').off();
            let id = $(this).attr("id");

            if (id == "yes") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tcommodities\t"+imperium_self.game.players_info[imperium_self.game.player-1].commodity_limit);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tstrategy\t1");
	      imperium_self.endTurn();
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
 
          });
        }
      },
    });


    this.importStrategyCard("warfare", {
      name     			:       "Warfare",
      rank			:	6,
      img			:	"/strategy/MILITARY.png",
      text			:	"De-activate a sector. Gain and distribute 1 free token.<hr />Other players may spend a strategy token to producein their home system" ,
      strategyPrimaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == strategy_card_player && player == strategy_card_player) {

          imperium_self.updateStatus('Select sector to de-activate.');
          imperium_self.playerSelectSector(function(sector) {

	    let sys = imperium_self.returnSectorAndPlanets(sector);

            imperium_self.addMove("resolve\tstrategy");
            imperium_self.addMove("strategy\t"+"warfare"+"\t"+strategy_card_player+"\t2");
            imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
            imperium_self.addMove("resetconfirmsneeded\t"+imperium_self.game.players_info.length);
            imperium_self.addMove("deactivate\t"+strategy_card_player+"\t"+sector);
            imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(strategy_card_player)+" deactivates "+sys.s.name);
            imperium_self.playerAllocateNewTokens(imperium_self.game.player, 1, 0, 3, 0);
          });
    
        }

      },
      strategySecondaryEvent 	:	function(imperium_self, player, strategy_card_player) {

        if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) { 

          let html = '<p>Do you wish to spend 1 strategy token to produce in your home sector? </p><ul>';
          if (imperium_self.game.state.round == 1) {
            html = `<p class="doublespace">${imperium_self.returnFaction(strategy_card_player)} has played the Warfare strategy card. You may spend 1 strategy token to produce in your Homeworld without activating the sector. You have ${imperium_self.game.players_info[player-1].strategy_tokens} strategy tokens. Use this ability? </p><ul>`;
          }
          if (imperium_self.game.players_info[player-1].strategy_tokens > 0 ) { 
            html += '<li class="option" id="yes">Yes</li>';
	  }
          html += '<li class="option" id="no">No</li>';
          html += '</ul>';
 
          imperium_self.updateStatus(html);

	  imperium_self.lockInterface();

          $('.option').off();
          $('.option').on('click', function() {

            if (!imperium_self.mayUnlockInterface()) {
              salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
              return;
            }
            imperium_self.unlockInterface();

            let id = $(this).attr("id");
 
            if (id == "yes") {
              imperium_self.playerProduceUnits(imperium_self.game.players_info[imperium_self.game.player-1].homeworld, 0, 0, 2, 1); // final is warfare card
            }
            if (id == "no") {
              imperium_self.addMove("resolve\tstrategy\t1\t"+imperium_self.app.wallet.returnPublicKey());
              imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
              imperium_self.endTurn();
              return 0;
            }
 
          });
        }
      },
    });


  this.importSecretObjective('military-catastrophe', {
      name 		: 	"Military Catastrophe" ,
      text		:	"Destroy the flagship of another player" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_military_catastrophe = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
        if (imperium_self.game.players_info[imperium_self.game.player-1].units_i_destroyed_this_combat_round.includes("flagship")) {
	  imperium_self.game.state.secret_objective_military_catastrophe = 1;
	}
        return 0; 
      },
      groundCombatRoundEnd :	function(imperium_self, attacker, defender, sector, planet_idx) {
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_military_catastrophe == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('flagship-dominance', {
      name 		: 	"Blood Christening" ,
      text		:	"Achieve victory in a space combat in a system containing your flagship. Your flagship must survive this combat" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_flagship_dominance = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
	if (imperium_self.doesSectorContainPlayerUnit(imperium_self.game.player, sector, "flagship")) { 
	  let sys = imperium_self.returnSectorAndPlanets(sector);
	  if (sys.s.units[defender-1].length == 0) {
	    if (attacker == imperium_self.game.player && sys.s.units[attacker-1].length > 0) {
	      imperium_self.game.state.secret_objective_flagship_dominance = 1;
	    }
	  }
	  if (sys.s.units[attacker-1].length == 0) {
	    if (defender == imperium_self.game.player && sys.s.units[defender-1].length > 0) {
	      imperium_self.game.state.secret_objective_flagship_dominance = 1;
	    }
	  }
	}
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_flagship_dominance == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });



  this.importSecretObjective('nuke-them-from-orbit', {
      name 		: 	"Nuke them from Orbit" ,
      text		:	"Destroy the last of a player's ground forces using bombardment" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_nuke_from_orbit = 0;
	imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = 0;
        return 0; 
      },
      bombardmentTriggers :	function(imperium_self, player, bombarding_player, sector, planet_idx) {
	imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = 0;
	let sys = imperium_self.returnSectorAndPlanets(sector);
	let planet = sys.p[planet_idx];
	let infantry_on_planet = imperium_self.returnInfantryOnPlanet(planet);
	for (let i = 0; i < planet.units.length; i++) {
	  if (planet.units[i].length > 0) {
	    if ((i+1) != bombarding_player) {
	      defender = i+1;
	      imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = infantry_on_planet;
	    }
	  }
	}
	return 0;
      },
      planetaryDefenseTriggers :  function(imperium_self, player, sector, planet_idx) {
	if (imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked > 0) {
	  let sys = imperium_self.returnSectorAndPlanets(sector);
console.log("PIDX: " + planet_idx);
	  let planet = sys.p[planet_idx];
console.log("PLANET: " + JSON.stringify(planet));
	  let infantry_on_planet = imperium_self.returnInfantryOnPlanet(planet);
	  if (infantry_on_planet == 0) {
	    imperium_self.game.state.secret_objective_nuke_from_orbit_how_many_got_nuked = 1;
	  }
	}
	return 0;
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_nuke_from_orbit == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('anti-imperialism', {
      name 		: 	"Anti-Imperialism" ,
      text		:	"Achieve victory in combat with a player with the most VP" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_anti_imperialism = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
        imperium_self.game.state.secret_objective_anti_imperialism = 0;
	let sys = imperium_self.returnSectorAndPlanets(sector);
	let players_with_most_vp = imperium_self.returnPlayersWithHighestVP();

	if (imperium_self.game.player == attacker && sys.s.units[attacker-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(attacker, sector) == 0) {
	    if (players_with_most_vp.includes(defender)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; } 
	  }
	}
	if (imperium_self.game.player == defender && sys.s.units[defender-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(defender, sector) == 0) {
	    if (players_with_most_vp.includes(attacker)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; }
	  }
	}
        return 0; 
      },
      groundCombatRoundEnd :	function(imperium_self, attacker, defender, sector, planet_idx) {
        let sys = imperium_self.returnSectorAndPlanets(sector);
        let planet = sys.p[planet_idx];
	let players_with_most_vp = imperium_self.returnPlayersWithHighestVP();

	if (imperium_self.game.player == attacker && planet.units[attacker-1].length > 0) {
	  if (planet.units[defender-1].length == 0) {
	    if (players_with_most_vp.includes(defender)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; } 
	  }
	}
	if (imperium_self.game.player == defender && planet.units[defender-1].length > 0) {
	  if (planet.units[attacker-1].length == 0) {
	    if (players_with_most_vp.includes(attacker)) { imperium_self.game.state.secret_objective_anti_imperialism = 1; }
	  }
	}
	return 0;
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_anti_imperialism == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('end-their-suffering', {
      name 		: 	"End Their Suffering" ,
      text		:	"Eliminate a player with the lowest VP from the board in Space or Ground Combat" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_end_their_suffering = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);
	let players_with_lowest_vp = imperium_self.returnPlayersWithLowestVP();

	if (imperium_self.game.player == attacker) {
	  if (sys.s.units[defender-1].length == 0) {
	    if (players_with_lowest_vp.includes(defender)) { 
	      // does the player have any units left?
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[defender-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[defender-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
	if (imperium_self.game.player == defender) {
	  if (sys.s.units[attacker-1].length == 0) {
	    if (players_with_lowest_vp.includes(attacker)) { 
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[attacker-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[attacker-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
        return 0; 
      },
      groundCombatRoundEnd :	function(imperium_self, attacker, defender, sector, planet_idx) {
        let sys = imperium_self.returnSectorAndPlanets(sector);
        let planet = sys.p[planet_idx];
	let players_with_lowest_vp = imperium_self.returnPlayersWithLowestVP();

	if (imperium_self.game.player == attacker) {
	  if (planet.units[defender-1].length == 0) {
	    if (players_with_lowest_vp.includes(defender)) { 
	      // does the player have any units left?
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[defender-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[defender-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
	if (imperium_self.game.player == defender) {
	  if (planet.units[attacker-1].length == 0) {
	    if (players_with_lowest_vp.includes(attacker)) { 
	      for (let i in imperium_self.game.sectors) {
		if (imperium_self.game.sectors[i].units[attacker-1].length > 0) { return; }
	      }
	      for (let i in imperium_self.game.planets) {
		if (imperium_self.game.planets[i].units[attacker-1].length > 0) { return; }
	      }
	      imperium_self.game.state.secret_objective_end_their_suffering = 1;
	    }
	  }
	}
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_end_their_suffering == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });




  this.importSecretObjective('establish-a-blockade', {
      name 		: 	"Establish a Blockade" ,
      text		:	"Have at least 1 ship in the same sector as an opponent's spacedock",
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	for (let i in imperium_self.game.sectors) {
	  if (imperium_self.game.sectors[i].units[player-1].length > 0) {
	    let sys = imperium_self.returnSectorAndPlanets(i);
	    for (let p = 0; p < sys.p.length; p++) {
	      for (let b = 0; b < sys.p[p].units.length; b++) {
	 	if ((b+1) != player) {
	          for (let bb = 0; bb < sys.p[p].units[b].length; bb++) {
		    if (sys.p[p].units[b][bb].type === "spacedock") { return 1; }
		  }
		}
	      }
	    }
	  }
	}
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });

  this.importSecretObjective('close-the-trap', {
      name 		: 	"Close the Trap" ,
      text		:	"Destroy another player's last ship in a system using a PDS" ,
      type		: 	"secret" ,
      phase		: 	"action" ,
      onNewTurn		: 	function(imperium_self, player, mycallback) {
	imperium_self.game.state.secret_objective_close_the_trap = 0;
        return 0; 
      },
      spaceCombatRoundEnd :	function(imperium_self, attacker, defender, sector) {
	let sys = imperium_self.returnSectorAndPlanets(sector);
	if (imperium_self.game.player == attacker && sys.s.units[attacker-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(attacker, sector) == 0) {
	    imperium_self.game.state.secret_objective_close_the_trap = 1;
	  }
	}
	if (imperium_self.game.player == defender && sys.s.units[defender-1].length > 0) {
	  if (imperium_self.hasUnresolvedSpaceCombat(defender, sector) == 0) {
	    imperium_self.game.state.secret_objective_close_the_trap = 1;
	  }
	}

        if (imperium_self.game.players_info[imperium_self.game.player-1].units_i_destroyed_this_combat_round.includes("flagship")) {
	  imperium_self.game.state.secret_objective_military_catastrophe = 1;
	}
        return 0; 
      },
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.state.secret_objective_close_the_trap == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('galactic-observer', {
      name 		: 	"Galactic Observer" ,
      text		:	"Have at least 1 ship in 6 different sectors" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let ships_in_systems = 0;
	for (let i in imperium_self.game.board) {
	  let sector = imperium_self.game.board[i].tile;
	  if (imperium_self.doesSectorContainPlayerShip(player, sector)) {
	    ships_in_systems++;
	  }
	}

	if (ships_in_systems > 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });



  this.importSecretObjective('master-of-the-ion-cannon', {
      name 		: 	"Master Cannoneer" ,
      text		:	"Have at least 4 PDS units in play" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let pds_units_in_play = 0;

	for (let i in imperium_self.game.planets) {
	  let planet = imperium_self.game.planets[i];
	  for (let ii = 0; ii < planet.units[player-1].length; ii++) {
	    if (planet.units[player-1][ii].type == "pds") {
	      pds_units_in_play++;
	    }
	  }
	}

	if (pds_units_in_play > 3) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('war-engine', {
      name 		: 	"War Engine" ,
      text		:	"Have three spacedocks in play" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let docks_in_play = 0;

	for (let i in imperium_self.game.planets) {
	  let planet = imperium_self.game.planets[i];
	  for (let ii = 0; ii < planet.units[player-1].length; ii++) {
	    if (planet.units[player-1][ii].type == "spacedock") {
	      docks_in_play++;
	    }
	  }
	}

	if (docks_in_play > 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });

  this.importSecretObjective('wormhole-administrator', {
      name 		: 	"Wormhole Administrator" ,
      text		:	"Have at least 1 ship in systems containing alpha and beta wormholes respectively" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let relevant_sectors = imperium_self.returnSectorsWithPlayerShips(player);
	let alpha = 0;
	let beta = 0;
	for (let i = 0; i < relevant_sectors.length; i++) {
	  if (imperium_self.game.sectors[relevant_sectors[i]].wormhole == 1) { alpha = 1; }
	  if (imperium_self.game.sectors[relevant_sectors[i]].wormhole == 2) { beta = 1; }
	}
	if (alpha == 1 && beta == 1) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('fleet-of-terror', {
      name 		: 	"Fleet of Terror" ,
      text		:	"Have five dreadnaughts in play" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let dreadnaughts = 0;
	let relevant_sectors = imperium_self.returnSectorsWithPlayerShips(player);
	for (let i = 0; i < relevant_sectors.length; i++) {
	  for (let ii = 0; ii < imperium_self.game.sectors[relevant_sectors[i]].units[player-1].length; ii++) {
	    if (imperium_self.game.sectors[relevant_sectors[i]].units[player-1][ii].type === "dreadnaught") {
	      dreadnaughts++;
	    }
	  }
	}
	if (dreadnaughts >= 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('cultural-diplomacy', {
      name 		: 	"Cultural Diplomacy" ,
      text		:	"Control at least 4 cultural planets" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let cultural = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();
        for (let i = 0; i < planetcards.length; i++) { if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; } }
        if (cultural >= 4) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('act-of-espionage', {
      name 		: 	"Act of Espionage" ,
      text		:	"Discard five action cards from your hard" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.returnPlayerActionCards(player).length >= 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	if (imperium_self.game.player == player) {
	  imperium_self.playerDiscardActionCards(5, function() {
	    mycallback(1);
	  });
	} else {
	  mycallback(0);
	}
      }
  });


  this.importSecretObjective('space-to-breathe', {
      name 		: 	"Space to Breathe" ,
      text		:	"Have at least 1 ship in 3 systems with no planets" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	let relevant_sectors = imperium_self.returnSectorsWithPlayerShips(player);
	let sectors_without_planets = 0;
	for (let i = 0; i < relevant_sectors.length; i++) {
	  if (imperium_self.game.sectors[relevant_sectors[i]].planets.length == 0) { sectors_without_planets++; }
	}
	if (sectors_without_planets >= 3) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });


  this.importSecretObjective('ascendant-technocracy', {
      name 		: 	"Ascendant Technocracy" ,
      text		:	"Research 4 tech upgrades on the same color path" , 
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {

        let techlist = imperium_self.game.players_info[player-1].tech;

        let greentech = 0;
        let bluetech = 0;
        let redtech = 0;
        let yellowtech = 0;

        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].color == "blue") { bluetech++; }
          if (imperium_self.tech[techlist[i]].color == "red") { redtech++; }
          if (imperium_self.tech[techlist[i]].color == "yellow") { yellowtech++; }
          if (imperium_self.tech[techlist[i]].color == "green") { greentech++; }
        }

        if (bluetech >= 4) { return 1; }
        if (yellowtech >= 4) { return 1; }
        if (redtech >= 4) { return 1; }
        if (greentech >= 4) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        mycallback(1);
      },
  });



  this.importSecretObjective('penal-colonies', {
      name 		: 	"Penal Colonies" ,
      text		:	"Control four planets with hazardous conditions" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let hazardous = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();
        for (let i = 0; i < planetcards.length; i++) { if (imperium_self.game.planets[planetcards[i]].type === "hazardous")   { hazardous++; } }
        if (hazardous >= 4) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('master-of-production', {
      name 		: 	"Master of Production" ,
      text		:	"Control four planets with industrial civilizations" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let industrial = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();
        for (let i = 0; i < planetcards.length; i++) { if (imperium_self.game.planets[planetcards[i]].type === "industrial")   { industrial++; } }
        if (industrial >= 4) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('faction-technologies', {
      name 		: 	"Faction Technologies" ,
      text		:	"Research 2 faction technologies" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
        let techlist = imperium_self.game.players_info[player-1].tech;
        let factiontech = 0;
        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].type == "normal" && techlist[i].indexOf("faction") == 0) { factiontech++; }
        }
        if (factiontech >= 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('occupy-new-byzantium', {
      name 		: 	"Occupy New Byzantium" ,
      text		:	"Control New Byzantium and have at least 3 ships protecting the sector" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {
	if (imperium_self.game.planets['new-byzantium'].owner == player) {
	  if (imperium_self.game.sectors['new-byzantium'].units[player-1].length >= 3) { return 1; }
	}
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });
  this.importSecretObjective('cast-a-long-shadow', {
      name 		: 	"Cast a Long Shadow" ,
      text		:	"Have at least 1 ship in a system adjacent to an opponent homeworld" ,
      type		: 	"secret" ,
      canPlayerScoreVictoryPoints	: function(imperium_self, player) {

 	// 1_1, 4_7, etc.
	let homeworlds = imperium_self.returnHomeworldSectors(imperium_self.game.players_info.length);
	let sectors = [];

	for (let i = 0; i < homeworlds.length; i++) {
	  if (imperium_self.game.board[homeworlds[i]].tile != imperium_self.game.board[imperium_self.game.players_info[player-1].homeworld].tile) {
	    sectors.push(imperium_self.game.board[homeworlds[i]].tile);
	  }
	}

	for (let i = 0; i < sectors.length; i++) {
	  if (imperium_self.isPlayerAdjacentToSector(player, sectors[i])) { return 1; }
	}
       
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) { 
	mycallback(1);
      }
  });






/***
  this.importStageIPublicObjective('manage-to-breathe', {
      name 	: 	"Deep Breathing" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Just score this for free..." ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	return 1;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
***/

  this.importStageIPublicObjective('planetary-unity', {
      name 	: 	"Planetary Unity" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Control four planets of the same planet type" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

	let hazardous = 0;
	let cultural = 0;
	let industrial = 0;

	let planetcards = imperium_self.returnPlayerPlanetCards(player);

	for (let i = 0; i < planetcards.length; i++) {
	  let p = imperium_self.game.planets[planetcards[i]];
	  if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
	  if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
	  if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
	}

	if (hazardous >= 4 || cultural >= 4 || industrial >= 4) { return 1; }

	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('forge-of-war', {
      name 	: 	"Forge of War" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Research 2 unit upgrade technologies" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	let techlist = imperium_self.game.players_info[player-1].tech;
	let unit_upgrades = 0;
	for (let i = 0; i < techlist.length; i++) {
	  if (imperium_self.tech[techlist[i]].unit == 1) {
	    unit_upgrades++;
	  }
	}
	if (unit_upgrades >= 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('diversified-research', {
      name 	: 	"Diversified Research" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Research 2 technologies in two different color paths" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

	let techlist = imperium_self.game.players_info[player-1].tech;

	let greentech = 0;
	let bluetech = 0;
	let redtech = 0;
	let yellowtech = 0;

	for (let i = 0; i < techlist.length; i++) {
	  if (imperium_self.tech[techlist[i]].color == "blue") { bluetech++; }
	  if (imperium_self.tech[techlist[i]].color == "red") { redtech++; }
	  if (imperium_self.tech[techlist[i]].color == "yellow") { yellowtech++; }
	  if (imperium_self.tech[techlist[i]].color == "green") { greentech++; }
	}

	let achieve_two = 0;
	
	if (bluetech >= 2) { achieve_two++; }
	if (yellowtech >= 2) { achieve_two++; }
	if (redtech >= 2) { achieve_two++; }
	if (greentech >= 2) { achieve_two++; }

	if (achieve_two >= 2) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('mining-conglomerate', {
      name 	: 	"Mining Conglomerate" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend eight resources when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if (imperium_self.returnAvailableResources(player) >= 8) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectResources(8, function(success) {
	    mycallback(success);
          });
	} else {
	  mycallback(0);
	}
      },
  });
  this.importStageIPublicObjective('conquest-of-science', {
      name 	: 	"Conquest of Science" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Control 3 planets with tech specialities" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let techbonuses = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (planetcards[i].bonus == "red") { techbonuses++; }
          if (planetcards[i].bonus == "blue") { techbonuses++; }
          if (planetcards[i].bonus == "green") { techbonuses++; }
          if (planetcards[i].bonus == "yellow") { techbonuses++; }
        }

	if (techbonuses >= 3) { return 1; }

	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('colonization', {
      name 	: 	"Colonization" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Control six planets outside your home system" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let hazardous = 0;
        let cultural = 0;
        let industrial = 0;
        let diplomatic = 0;

        let planetcards = imperium_self.returnPlayerPlanetCards(player);

        for (let i = 0; i < planetcards.length; i++) {
          if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
          if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
          if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
          if (imperium_self.game.planets[planetcards[i]].type === "diplomatic") { diplomatic++; }
        }

        if ((cultural+hazardous+industrial+diplomatic) >= 6) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });


  this.importStageIPublicObjective('grand-gesture', {
      name 	: 	"A Grand Gesture" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend 3 command or strategy tokens when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if ((imperium_self.game.players_info[player-1].strategy_tokens + imperium_self.game.players_info[player-1].command_tokens) >= 3) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectStrategyAndCommandTokens(3, function(success) {
	    mycallback(success);
          });
	} else {
	  mycallback(0);
	}
      },
  });


  this.importStageIPublicObjective('establish-trade-outposts', {
      name 	: 	"Establish Trade Outposts" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend 5 trade goods when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if (imperium_self.returnAvailableTradeGoods(player) >= 5) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        imperium_self.game.players_info[player-1].goods -= 5;
	imperium_self.displayFactionDashboard();
	mycallback(1);
      },
  });
  this.importStageIPublicObjective('pecuniary-diplomacy', {
      name 	: 	"Pecuniary Diplomacy" ,
      img	:	"/imperium/img/objective_card_1_template.png" ,
      text	:	"Spend 8 influence when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
	if (imperium_self.returnAvailableInfluence(player) >= 8) { return 1; }
	return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectInfluence(8, function(success) {
	    mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });




  this.importStageIIPublicObjective('master-of-commerce', {
      name 	: 	"Master of Commerce" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 10 trade goods when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if (imperium_self.returnAvailableTradeGoods(player) >= 10) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        imperium_self.game.players_info[player-1].goods -= 10;
	imperium_self.displayFactionDashboard();
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('display-of-dominance', {
      name 	: 	"Display of Dominance" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control at least 1 planet in another player's home sector" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

	let homeworlds = [];
	let homeplanets = [];
	for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	  let home_sector = imperium_self.game.board[imperium_self.game.players_info[player-1].homeworld].tile;
	  let sys = imperium_self.returnSectorAndPlanets(home_sector);
	  for (let ii = 0; ii < sys.p.length; ii++) {
	    homeplanets.push(sys.p[ii].name);
	  }
	}

        let planetcards = imperium_self.returnPlayerPlanetCards();

	for (let i = 0; i < planetcards.length; i++) {
	  if (homeplanets.includes(planetcards[i].name)) { return 1; }
	}

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('technological-empire', {
      name 	: 	"Technological Empire" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control 5 planets with tech bonuses" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let techbonuses = 0;
        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (planetcards[i].bonus == "red") { techbonuses++; }
          if (planetcards[i].bonus == "blue") { techbonuses++; }
          if (planetcards[i].bonus == "green") { techbonuses++; }
          if (planetcards[i].bonus == "yellow") { techbonuses++; }
        }

        if (techbonuses >= 3) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('establish-galactic-currency', {
      name 	: 	"Establish Galactic Currency" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 16 resources when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if (imperium_self.returnAvailableResources(player) >= 16) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectResources(16, function(success) {
	    mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });
  this.importStageIIPublicObjective('master-of-science', {
      name 	: 	"Master of Science" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Own 2 tech upgrades in each of 4 tech color paths" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let techlist = imperium_self.game.players_info[player-1].tech;

        let greentech = 0;
        let bluetech = 0;
        let redtech = 0;
        let yellowtech = 0;

        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].color == "blue") { bluetech++; }
          if (imperium_self.tech[techlist[i]].color == "red") { redtech++; }
          if (imperium_self.tech[techlist[i]].color == "yellow") { yellowtech++; }
          if (imperium_self.tech[techlist[i]].color == "green") { greentech++; }
        }

        let achieve_two = 0;

        if (bluetech >= 2) { achieve_two++; }
        if (yellowtech >= 2) { achieve_two++; }
        if (redtech >= 2) { achieve_two++; }
        if (greentech >= 2) { achieve_two++; }

        if (achieve_two >= 4) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },

  });
  this.importStageIIPublicObjective('imperial-unity', {
      name 	: 	"Imperial Unity" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control 6 planets of the same planet type" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let hazardous = 0;
        let cultural = 0;
        let industrial = 0;
        let diplomatic = 0;

        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
          if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
          if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
          if (imperium_self.game.planets[planetcards[i]].type === "diplomatic")   { diplomatic++; }
        }

        if (hazardous >= 6 || cultural >= 6 || industrial >= 6 || diplomatic >= 6) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
        mycallback(1);
      },
  });
  this.importStageIIPublicObjective('advanced-technologies', {
      name 	: 	"Advanced Technologies" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Research 3 unit upgrade technologies" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        let techlist = imperium_self.game.players_info[player-1].tech;
        let unit_upgrades = 0;
        for (let i = 0; i < techlist.length; i++) {
          if (imperium_self.tech[techlist[i]].unit == 1) {
            unit_upgrades++;
          }
        }
        if (unit_upgrades >= 3) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('colonial-dominance', {
      name 	: 	"Colonial Dominance" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Control 11 planets outside your home system" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {

        let hazardous = 0;
        let cultural = 0;
        let industrial = 0;
        let diplomatic = 0;

        let planetcards = imperium_self.returnPlayerPlanetCards();

        for (let i = 0; i < planetcards.length; i++) {
          if (imperium_self.game.planets[planetcards[i]].type === "hazardous")  { hazardous++; }
          if (imperium_self.game.planets[planetcards[i]].type === "industrial") { industrial++; }
          if (imperium_self.game.planets[planetcards[i]].type === "cultural")   { cultural++; }
          if (imperium_self.game.planets[planetcards[i]].type === "diplomatic")   { diplomatic++; }
        }

        if ((cultural+hazardous+industrial+diplomatic) >= 11) { return 1; }

        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	mycallback(1);
      },
  });
  this.importStageIIPublicObjective('power-broker', {
      name 	: 	"Power Broker" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 16 influence when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if (imperium_self.returnAvailableInfluence(player) >= 16) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectInfluence(16, function(success) {
            mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });
  this.importStageIIPublicObjective('cultural-revolution', {
      name 	: 	"Cultural Revolution" ,
      img	:	"/imperium/img/objective_card_2_template.png" ,
      text	:	"Spend 6 command or strategy tokens when scoring" ,
      canPlayerScoreVictoryPoints : function(imperium_self, player) {
        if ((imperium_self.game.players_info[player-1].strategy_tokens + imperium_self.game.players_info[player-1].command_tokens) >= 6) { return 1; }
        return 0;
      },
      scoreObjective : function(imperium_self, player, mycallback) {
	if (imperium_self.game.player == player) {
          imperium_self.playerSelectStrategyAndCommandTokens(6, function(success) {
            mycallback(success);
          });
        } else {
	  mycallback(0);
	}
      },
  });
  
  
  

  this.importAgendaCard('shard-of-the-throne', {
  	name : "Shard of the Throne" ,
  	type : "Law" ,
	elect : "player" ,
  	text : "Elect a Player to earn 1 VP. When this player loses a space combat to another player, they transfer the VP to that player" ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.shard_of_the_throne = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.shard_of_the_throne_player = i+1;
	    }
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "shard-of-the-throne";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

          imperium_self.game.players_info[imperium_self.game.state.shard_of_the_throne_player-1].vp += 1;
	  imperium_self.updateLeaderboard();
	  imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.shard_of_the_throne_player) + " gains the Shard of the Throne (1VP)");

	},
        repealAgenda(imperium_self) {

	  //
	  // remove from active play
	  //
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	    if (imperium_self.game.state.laws[i].agenda === "shard-of-the-throne") {
	      imperium_self.game.state.laws.splice(i, 1);
	      i--;
	    }  
	  }

	  //
	  // unset the player
	  //
	  imperium_self.game.state.shard_of_the_throne_player = -2;

	  return 1;

        },
        spaceCombatRoundEnd : function(imperium_self, attacker, defender, sector) {
	  if (defender == imperium_self.game.state.shard_of_the_throne_player) {
	    if (!imperium_self.doesPlayerHaveShipsInSector(defender, sector)) {
	      imperium_self.game.state.shard_of_the_throne_player = attacker;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.shard_of_the_throne_player) + " gains the Shard of the Throne (1VP)");
	      imperium_self.game.players_info[attacker-1].vp += 1;
	      imperium_self.game.players_info[defender-1].vp -= 1;
	      imperium_self.updateLeaderboard();
	    }
	  }
	},
	groundCombatRoundEnd : function(imperium_self, attacker, defender, sector, planet_idx) {
	  if (defender == imperium_self.game.state.shard_of_the_throne_player) {
	    if (!imperium_self.doesPlayerHaveInfantryOnPlanet(defender, sector, planet_idx)) {
	      imperium_self.game.state.shard_of_the_throne_player = attacker;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.shard_of_the_throne_player) + " gains the Shard of the Throne (1VP)");
	      imperium_self.game.players_info[attacker-1].vp += 1;
	      imperium_self.game.players_info[defender-1].vp -= 1;
	      imperium_self.updateLeaderboard();
	    }
	  }
	},
  });


  this.importAgendaCard('homeland-defense-act', {
  	name : "Homeland Defense Act" ,
  	type : "Law" ,
  	text : "FOR: there is no limit to the number of PDS units on a planet. AGAINST: each player must destroy one PDS unit" ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.homeland_defense_act = 1;
	  let law_to_push = {};
	      law_to_push.agenda = "homeland-defense-act";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

          if (winning_choice === "for") {
	    imperium_self.game.state.pds_limit_per_planet = 100;
	  }

          if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.doesPlayerHaveUnitOnBoard((i+1), "pds")) {
	        imperium_self.game.queue.push("destroy_a_pds\t"+(i+1));
	      }
	    }
	  }

	  imperium_self.game.state.laws.push({ agenda : "homeland-defense-act" , option : winning_choice });

	},
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "homeland-defense-act") {
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the player
          //
          imperium_self.game.state.homeland_defense_act = 0;
	  imperium_self.game.state.pds_limit_per_planet = 2; // limit back

          return 1;

        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "destroy_a_pds") {

            let player = parseInt(mv[1]);
	    imperium_self.game.queue.splice(qe, 1);

	    if (imperium_self.game.player == player) {
              imperium_self.playerSelectUnitWithFilter(
                    "Select a PDS unit to destroy: ",
                    function(unit) {
		      if (unit == undefined) { return 0; }
                      if (unit.type == "pds") { return 1; }
                      return 0;
            	    },
                    function(unit_identifier) {

                      let sector        = unit_identifier.sector;
                      let planet_idx    = unit_identifier.planet_idx;
                      let unit_idx      = unit_identifier.unit_idx;
                      let unit          = unit_identifier.unit;

		      if (unit == null) {
                        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " has no PDS units to destroy");
		        imperium_self.endTurn();
			return 0;
		      }
                      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit.name + " in " + imperium_self.game.sectors[sector].name);
		      imperium_self.endTurn();
                    }
              );
	    }

            return 0;
          }
          return 1;
        }
  });




  this.importAgendaCard('holy-planet-of-ixth', {
  	name : "Holy Planet of Ixth" ,
  	type : "Law" ,
	elect : "planet" ,
  	text : "Elect a cultural planet. The planet's controller gains 1 VP. Units cannot be landed, produced or placed on this planet" ,
        returnAgendaOptions : function(imperium_self) {
	  return imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "cultural") { return 1; } return 0; 
	  });
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.holy_planet_of_ixth = 1;
	  imperium_self.game.state.holy_planet_of_ixth_planet = winning_choice;
	  let law_to_push = {};
	      law_to_push.agenda = "holy-planet-of-ixth";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  //
	  // lock the planet
	  //
	  imperium_self.game.planets[winning_choice].locked = 1;

	  //
	  // issue VP to controller
	  //
	  let owner = imperium_self.game.planets[winning_choice].owner;
	  if (owner != -1) {
	    imperium_self.game.players_info[owner-1].vp += 1;
	    imperium_self.updateLeaderboard();
	    imperium_self.updateLog(imperium_self.returnFaction(owner) + " gains 1 VP from Holy Planet of Ixth");
	  }

	},
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
	  let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "holy-planet-of-ixth") {
	      winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the player
          //
	  if (winning_choice != null) {
            imperium_self.game.state.holy_planet_of_ixth = 0;
            imperium_self.game.state.holy_planet_of_ixth_planet = -1;
	    imperium_self.game.planets[winning_choice].locked = 0;
	  }

          return 1;

        },
  });



  this.importAgendaCard('research-team-biotic', {
        name : "Research Team: Biotic" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an industrial planet. The owner may exhaust this planet to ignore 1 green technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-biotic") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_biotic = 0;
            imperium_self.game.state.research_team_biotic_planet = -1;
          }

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_biotic = 1;
          imperium_self.game.state.research_team_biotic_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-biotic";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].owner == player) {
            return { event : 'research_team_biotic', html : '<li class="option" id="research_team_biotic">use biotic (green) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_green_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_biotic_planet].exhausted = 1;
	  }
          return 0;
        }
  });


  this.importAgendaCard('research-team-cybernetic', {
        name : "Research Team: Cybernetic" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an industrial planet. The owner may exhaust this planet to ignore 1 yellow technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_cybernetic = 1;
          imperium_self.game.state.research_team_cybernetic_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-cybernetic";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
	repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-cybernetic") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_cybernetic = 0;
            imperium_self.game.state.research_team_cybernetic_planet = -1;
          }

          return 1;

        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].owner == player) {
            return { event : 'research_team_cybernetic', html : '<li class="option" id="research_team_cybernetic">use cybernetic (yellow) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_yellow_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_cybernetic_planet].exhausted = 1;
	  }
          return 0;
        }
  });


  this.importAgendaCard('research-team-propulsion', {
        name : "Research Team: Propulsion" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an industrial planet. The owner may exhaust this planet to ignore 1 blue technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-propulsion") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_propulsion = 0;
            imperium_self.game.state.research_team_propulsion_planet = -1;
          }

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_propulsion = 1;
          imperium_self.game.state.research_team_propulsion_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-propulsion";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].owner == player) {
            return { event : 'research_team_propulsion', html : '<li class="option" id="research_team_propulsion">use propulsion (blue) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_blue_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_propulsion_planet].exhausted = 1;
	  }
          return 0;
        }
  });


  this.importAgendaCard('research-team-warfare', {
        name : "Research Team: Warfare" ,
        type : "Law" ,
	elect : "planet" ,
        text : "Elect an hazardous planet. The owner may exhaust this planet to ignore 1 red technology prerequisite the next time they research a technology" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "industrial") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "research-team-warfare") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.research_team_warfare = 0;
            imperium_self.game.state.research_team_warfare_planet = -1;
          }

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.research_team_warfare = 1;
          imperium_self.game.state.research_team_warfare_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "research-team-warfare";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);
        },
        menuOption  :       function(imperium_self, menu, player) {
          if (menu == "main" && imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].owner == player) {
            return { event : 'research_team_warfare', html : '<li class="option" id="research_team_warfare">use warfare (red) tech-skip</li>' };
	  }
	  return {};
        },
        menuOptionTriggers:  function(imperium_self, menu, player) {
          if (menu == "main") {
            if (imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].owner == player) {
              if (imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].exhausted == 0) {
                return 1;
              }
            }
          }
          return 0;
        },
        menuOptionActivated:  function(imperium_self, menu, player) {
          if (menu == "main") {
            imperium_self.game.players_info[player-1].temporary_red_tech_prerequisite++;
            imperium_self.game.planets[imperium_self.game.state.research_team_warfare_planet].exhausted = 1;
	  }
          return 0;
        }
  });



  this.importAgendaCard('demilitarized-zone', {
  	name : "Demilitarized Zone" ,
  	type : "Law" ,
	elect : "planet" ,
  	text : "Elect a cultural planet. All units are destroyed and cannot be landed, produced or placed on this planet" ,
        returnAgendaOptions : function(imperium_self) {
	  return imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "cultural") { return 1; } return 0; 
	  });
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.demilitarized_zone = 1;
	  imperium_self.game.state.demilitarized_zone_planet = winning_choice;
	  let law_to_push = {};
	      law_to_push.agenda = "demilitarized-zone";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  imperium_self.game.planets[winning_choice].units = []; 
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.planets[winning_choice].units.push([]);
	  }

	  imperium_self.game.planets[winning_choice].locked = 1;

	},
        repealAgenda(imperium_self) {

          //
          // remove from active play
          //
          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "demilitarized-zone") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          //
          // unset the planet
          //
          if (winning_choice != null) {
            imperium_self.game.state.demilitarized_zone = 0;
            imperium_self.game.state.demilitarized_zone_planet = -1;
	    imperium_self.game.planets[winning_choice].locked = 0;
          }

          return 1;

        },
  });

  this.importAgendaCard('core-mining', {
  	name : "Core Mining" ,
  	type : "Law" ,
	elect : "planet" ,
  	text : "Elect a hazardous planet. Destroy half the infantry on that planet and increase its resource value by +2" ,
        returnAgendaOptions : function(imperium_self) {
	  return imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "hazardous") { return 1; } return 0; 
	  });
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "core-mining") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }


          if (winning_choice != null) {
            imperium_self.game.state.core_mining = 0;
            imperium_self.game.state.core_mining_planet = -1;
	    imperium_self.game.planets[winning_choice].locked = 0;
	    imperium_self.game.planets[winning_choice].resources -= 2;
          }
          return 1;

        },
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.core_mining = 1;
	  imperium_self.game.state.core_mining_planet = winning_choice;
	  let law_to_push = {};
	      law_to_push.agenda = "core-mining";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  let options = imperium_self.returnPlanetsOnBoard(function(planet) {
	    if (planet.type === "hazardous") { return 1; } return 0; 
	  });

	  //
	  // also - destroy the planet and increase its resource value
	  //
	  //let planetidx = options[winning_choice];
	  let planetidx = winning_choice;

	  for (let i = 0; i < imperium_self.game.planets[planetidx].units.length; i++) {
	    let destroy = 1;
	    for (let ii = 0; ii < imperium_self.game.planets[planetidx].units[i].length; ii++) {
	      if (imperium_self.game.planets[planetidx].units[i][ii].type == "infantry") {
	        if (destroy == 1) {
	          imperium_self.game.players[planetidx].units[i].splice(ii, 1);
		  ii--;
		  destroy = 0;
		} else {
		  destroy = 1;
		}
	      }
	    }
	  }

	  imperium_self.game.planets[winning_choice].resources += 2;

	}
  });



  this.importAgendaCard('anti-intellectual-revolution', {
  	name : "Anti-Intellectual Revolution" ,
  	type : "Law" ,
  	text : "FOR: players must destroy a capital ship in order to play the Technology card. AGAINST: at the start of the next round, each player exhausts one planet for each technology they have." ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "anti-intellectual-revolution") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          let techcard = imperium_self.strategy_cards['technology'];
	  if (techcard.strategyPrimaryEventBackup) { techcard.strategyPrimaryEvent = techcard.strategyPrimaryEventBackup; }
	  if (techcard.strategySecondaryEventBackup) { techcard.strategySecondaryEvent = techcard.strategySecondaryEventBackup; }

          return 1;

        },
	initialize : function(imperium_self, winning_choice) {

          if (winning_choice === "for") {

            let techcard = imperium_self.strategy_cards['technology'];

            let old_tech_sec = techcard.strategySecondaryEvent;
            let new_tech_sec = function(imperium_self, player, strategy_card_player) {
	      if (imperium_self.game.player == player && imperium_self.game.player != strategy_card_player) {
                imperium_self.playerAcknowledgeNotice("Anti-Intellectual Revolution is in play. Do you wish to destroy a capital ship to research technology?", function() {

                  imperium_self.playerSelectUnitWithFilter(
                    "Select a capital ship to destroy: ",
                    function(ship) {
                      if (ship.type == "destroyer") { return 1; }
                      if (ship.type == "cruiser") { return 1; }
                      if (ship.type == "carrier") { return 1; }
                      if (ship.type == "dreadnaught") { return 1; }
                      if (ship.type == "flagship") { return 1; }
                      if (ship.type == "warsun") { return 1; }
                      return 0;
                    },

                    function(unit_identifier) {

                      let sector        = unit_identifier.sector;
                      let planet_idx    = unit_identifier.planet_idx;
                      let unit_idx      = unit_identifier.unit_idx;
                      let unit          = unit_identifier.unit;

                      if (planet_idx == -1) {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"space"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      } else {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      }
                      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit.name + " in " + imperium_self.game.sectors[sector].name);
                      old_tech_sec(imperium_self, player, strategy_card_player);

                    }
                  );
                });
              }
            };
	    techcard.strategySecondaryEventBackup = old_tech_sec;
            techcard.strategySecondaryEvent = new_tech_sec;



            let old_tech_func = techcard.strategyPrimaryEvent;
            let new_tech_func = function(imperium_self, player, strategy_card_player) {
              if (imperium_self.game.player == strategy_card_player) {
                imperium_self.playerAcknowledgeNotice("Anti-Intellectual Revolution is in play. Do you wish to destroy a capital ship to research technology?", function() {

                  imperium_self.playerSelectUnitWithFilter(
                    "Select a capital ship to destroy: ",
                    function(ship) {
                      if (ship.type == "destroyer") { return 1; }
                      if (ship.type == "cruiser") { return 1; }
                      if (ship.type == "carrier") { return 1; }
                      if (ship.type == "dreadnaught") { return 1; }
                      if (ship.type == "flagship") { return 1; }
                      if (ship.type == "warsun") { return 1; }
                      return 0;
                    },

                    function(unit_identifier) {

                      let sector        = unit_identifier.sector;
                      let planet_idx    = unit_identifier.planet_idx;
                      let unit_idx      = unit_identifier.unit_idx;
                      let unit          = unit_identifier.unit;

                      if (planet_idx == -1) {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"space"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      } else {
                        imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+imperium_self.game.player+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+unit_idx+"\t"+"1");
                      }
                      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit.name + " in " + imperium_self.game.sectors[sector].name);
                      old_tech_func(imperium_self, player, strategy_card_player);

                    }
                  );
                });
              }
            };
	    techcard.strategyPrimaryEventBackup = old_tech_func;
            techcard.strategyPrimaryEvent = new_tech_func;
          }

          if (winning_choice === "against") {
            // exhaust two planets
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              imperium_self.game.players_info[i].must_exhaust_at_round_start.push("planet","planet");
            }
          }
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.anti_intellectual_revolution = 1;
	  let law_to_push = {};
	      law_to_push.agenda = "anti-intellectual-revolution";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  this.initialize(imperium_self, winning_choice);
	}
  });



  this.importAgendaCard('unconventional-measures', {
  	name : "Unconventional Measures" ,
  	type : "Directive" ,
  	text : "FOR: each player that votes 'for' draws 2 action cards. AGAINST: each player that votes 'for' discards their action cards." ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
	onPass : function(imperium_self, winning_choice) {

	  //
	  // gain two action cards
	  //
	  if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == winning_choice) {
                imperium_self.game.queue.push("gain\t2\t"+(i+2)+"\taction_cards"+"\t"+2);
                imperium_self.game.queue.push("DEAL\t2\t"+(i+1)+"\t2");
                imperium_self.game.queue.push("NOTIFY\tdealing two action cards to player "+(i+1));
	      }	      
	    }
	  }

	  //
	  // everyone who votes against discards action cards
	  //
	  if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "for") {
                if (imperium_self.game.player == (i+1)) {
		  imperium_self.game.players_info[i].action_cards_in_hand = 0;
		} else {
		  imperium_self.game.players_info[i].action_cards_in_hand = 0;
		  imperium_self.game.deck[1].hand = [];
  		  let law_to_push = {};
		      law_to_push.agenda = "unconventional-measures";
		      law_to_push.option = "winning_choice";
		  imperium_self.game.state.laws.push(law_to_push);
		}
	      }	      
	    }
	  }

        }
  });


  this.importAgendaCard('seeds-of-an-empire', {
  	name : "Seeds of an Empire" ,
  	type : "Directive" ,
  	text : "FOR: the player(s) with the most VP gain a VP. AGAINST: the players with the least VP gain a VP" ,
        returnAgendaOptions : function(imperium_self) { return ['for','against']; },
	onPass : function(imperium_self, winning_choice) {

	  let io = imperium_self.returnInitiativeOrder();

	  //
	  // highest VP
	  //
	  if (winning_choice === "for") {

	    let highest_vp = 0;
	    for (let i = 0; i < io.length; i++) {
	      if (highest_vp >= imperium_self.game.players_info[io[i]-1].vp) { highest_vp = imperium_self.game.players_info[io[i]-1].vp; }
	      imperium_self.game.state.seeds_of_an_empire = io[i];
	    }

	    for (let i = 0; i < io.length; i++) {
	      if (highest_vp == imperium_self.game.players_info[io[i]-1].vp) {
		imperium_self.game.players_info[io[i]-1].vp += 1;
		imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction((io[i])) + " gains 1 VP from Seeds of an Empire");
	        imperium_self.game.state.seeds_of_an_empire = (io[i]);
		if (imperium_self.checkForVictory()) { return 0; }
	      }
	    }
	    
          }


	  //
	  // lowest VP
	  //
	  if (winning_choice === "against") {

	    let lowest_vp = 10000;
	    for (let i = 0; i < io.length; i++) {
	      if (lowest_vp <= imperium_self.game.players_info[io[i]-1].vp) { highest_vp = imperium_self.game.players_info[io[i]-1].vp; }
	    }

	    for (let i = 0; i < io.length; i++) {
	      if (lowest_vp == imperium_self.game.players_info[io[i]-1].vp) {
		imperium_self.game.players_info[io[i]-1].vp += 1;
		imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction((io[i]+1)) + " gains 1 VP from Seeds of an Empire");
	        imperium_self.game.state.seeds_of_an_empire = (io[i]);
		if (imperium_self.checkForVictory()) { return 0; }

	      }
	    }
	    
          }

	  imperium_self.updateLeaderboard();

	  return 1;
        }
  });


  this.importAgendaCard('space-cadet', {
  	name : "Space Cadet" ,
  	type : "Law" ,
  	text : "Any player more than 3 VP behind the lead must henceforth be referred to as an Irrelevant Loser" ,
        returnAgendaOptions : function(imperium_self) { 
	  let options = [ 'for' , 'against' ];
	  return options;
        },
	initialize : function(imperium_self, winning_choice) {
	  if (imperium_self.space_cadet_initialized == undefined) {
	    imperium_self.space_cadet_initialized = 1;
	    if (imperium_self.game.state.space_cadet == 1) {
	      imperium_self.returnFactionNamePreSpaceCadet = imperium_self.returnFactionName;
	      imperium_self.returnFactionName = function(imperium_self, player) {
	        let max_vp = 0;
	        for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	          if (max_vp < imperium_self.game.players_info[i].vp) {
		    max_vp = imperium_self.game.players_info[i].vp;
		  }
	        }
                if (imperium_self.game.players_info[player-1].vp <= (max_vp-3)) { return "Irrelevant Loser"; }
    	        return imperium_self.returnFactionNamePreSpaceCadet(imperium_self, player);
  	      }
	      imperium_self.returnFactionNameNicknamePreSpaceCadet = imperium_self.returnFactionNameNickname;
	      imperium_self.returnFactionNameNickname = function(imperium_self, player) {
	        let max_vp = 0;
	        for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	          if (max_vp < imperium_self.game.players_info[i].vp) {
		    max_vp = imperium_self.game.players_info[i].vp;
		  }
	        }
                if (imperium_self.game.players_info[player-1].vp <= (max_vp-3)) { return "Loser"; }
    	        return imperium_self.returnFactionNameNicknamePreSpaceCadet(imperium_self, player);
  	      }
	    }
	  }
	},
	onPass : function(imperium_self, winning_choice) {
	  if (winning_choice == 'for') {
	    imperium_self.game.state.space_cadet = 1;
	    let law_to_push = {};
	        law_to_push.agenda = "space-cadet";
	        law_to_push.option = winning_choice;
	    imperium_self.game.state.laws.push(law_to_push);
	    this.initialize(imperium_self);
	  }
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) { 
            if (imperium_self.game.state.laws[i].agenda === "space-cadet") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
	  imperium_self.game.state.space_cadet = 0;
          imperium_self.returnFactionName = imperium_self.returnFactionNamePreSpaceCadet;

          return 1;

        }
  });


  this.importAgendaCard('galactic-threat', {
  	name : "Galactic Threat" ,
  	type : "Law" ,
  	text : "Elect a player. They must henceforth be referred to as the Galatic Threat" ,
        returnAgendaOptions : function(imperium_self) { 
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
        },
	initialize : function(imperium_self, winning_choice) {
	  if (imperium_self.galactic_threat_initialized == undefined) {
	    imperium_self.galactic_threat_initialized = 1;
	    if (imperium_self.game.state.galactic_threat == 1) {
	      imperium_self.returnFactionNamePreGalacticThreat = imperium_self.returnFactionName;
	      imperium_self.returnFactionName = function(imperium_self, player) {
                if (imperium_self.game.state.galactic_threat_player == player) { return "The Galactic Threat"; }
    	        return imperium_self.returnFactionNamePreGalacticThreat(imperium_self, player);
  	      }
	      imperium_self.returnFactionNameNicknamePreGalacticThreat = imperium_self.returnFactionNameNickname;
	      imperium_self.returnFactionNameNickname = function(imperium_self, player) {
                if (imperium_self.game.state.galactic_threat_player == player) { return "Threat"; }
    	        return imperium_self.returnFactionNameNicknamePreGalacticThreat(imperium_self, player);
  	      }
	    }
	  }
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.galactic_threat = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.galactic_threat_player = i+1;
	    }
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "galactic-threat";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  this.initialize(imperium_self);
	},
        repealAgenda(imperium_self) {

	  let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) { 
            if (imperium_self.game.state.laws[i].agenda === "galactic-threat") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.galactic_threat = 0;
          imperium_self.game.state.galactic_threat_initialized = 0;
	  if (imperium_self.returnFactionNamePreGalacticThreat) {
            imperium_self.returnFactionName = imperium_self.returnFactionNamePreGalacticThreat;
	  }

          return 1;

        }
  });




  this.importAgendaCard('Committee Formation', {
  	name : "Committee Formation" ,
  	type : "Law" ,
	elect : "player" ,
  	text : "Elect a player. They may form a committee to choose a player to be elected in a future agenda, bypassing voting" ,
        returnAgendaOptions : function(imperium_self) { 
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
        },
	preAgendaStageTriggers : function(imperium_self, player, agenda) {
	  if (imperium_self.game.state.committee_formation == 1 && imperium_self.game.state.committee_formation_player == player) { return 1; }
	  return 0;
	},
	preAgendaStageEvent : function(imperium_self, player, agenda) {

	  let html = "Do you wish to use Committee Formation to select the winner yourself? <ul>";
	      html += '<li class="textchoice" id="yes">assemble the committee</li>';
	      html += '<li class="textchoice" id="no">not this time</li>';
	      html += '</ul>';

	  imperium_self.updateStatus(html);

	  $('.textchoice').off();
	  $('.textchoice').on('click', function() {

	    let action = $(this).attr("id");

	    if (action == "no") { imperium_self.endTurn(); }

	    //
	    // works by "Assassinating all other representatives, so they don't / can't vote"
	    //
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (i != imperium_self.game.player-1) {
                imperium_self.addMove("rider\t"+player+"\tassassinate-representative\t-1");
	      }
	    }
            imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " forms a committee...");
	    

	  });

          return 0;

	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.committee_formation = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.committee_formation_player = (i+1);
	    }
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "committee-formation";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	},
        repealAgenda(imperium_self) {

	  let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "committee_formation") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.game.state.committee_formation = 0;
          imperium_self.game.state.committee_formation_player = -1;
          imperium_self.returnFactionName = imperium_self.returnFactionNamePreGalacticThreat;
          
          return 1;

        }

  });




  this.importAgendaCard('minister-of-policy', {
        name : "Minister of Policy" ,
        type : "Law" ,
	elect : "player" ,
        text : "Elect a player. They draw an extra action card at the start of each round" ,
        returnAgendaOptions : function(imperium_self) {
          let options = [];
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            options.push(imperium_self.returnFaction(i+1));
          }
          return options;
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.minister_of_policy = 1;
          imperium_self.game.state.minister_of_policy_player = winning_choice;
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.minister_of_policy_player = i+1;
	    }
	  }
	  imperium_self.game.players_info[imperium_self.game.state.minister_of_policy_player-1].action_cards_bonus_when_issued++;
	  let law_to_push = {};
	      law_to_push.agenda = "minister-of-policy";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

        },
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "minister-of-policy") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.game.state.minister_of_policy = 0;
	  imperium_self.game.players_info[imperium_self.game.state.minister_of_policy_player-1].action_cards_bonus_when_issued--;
          imperium_self.game.state.minister_of_policy_player = -1;

          return 1;

        }
  });



  this.importAgendaCard('executive-sanctions', {
  	name : "Executive Sanctions" ,
  	type : "Law" ,
  	text : "Players may have a maximum of 3 action cards in their hands at all times" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].action_card_limit = 3;
	    }
	  }
	  let law_to_push = {};
	      law_to_push.agenda = "executive-sanctions";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  return 1;
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "executive-sanctions") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (imperium_self.game.players_info[i].action_card_limit == 3) {
	      imperium_self.game.players_info[i].action_card_limit = 7;
	    }
	  }

          return 1;

        }

  });

  this.importAgendaCard('fleet-limitations', {
  	name : "Fleet Limitations" ,
  	type : "Law" ,
  	text : "Players may have a maximum of four tokens in their fleet supply." ,
  	img : "/imperium/img/agenda_card_template.png" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].fleet_supply_limit = 4;
	      if (imperium_self.game.players_info[i].fleet_supply >= 4) { imperium_self.game.players_info[i].fleet_supply = 4; }
	    }
	  }
	  return 1;
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "fleet-limitations") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].fleet_supply_limit = 16;
          }

          return 1;

        }

  });


  this.importAgendaCard('restricted-conscription', {
  	name : "Restricted Conscription" ,
  	type : "Law" ,
  	text : "Production cost for infantry and fighters is 1 rather than 0.5 resources" ,
  	img : "/imperium/img/agenda_card_template.png" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    imperium_self.units["infantry"].cost = 1;
	    imperium_self.units["fighter"].cost = 1;
	  }
	  let law_to_push = {};
	      law_to_push.agenda = "restricted-conscription";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  return 1;
	},
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "restricted-conscription") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.units["infantry"].cost = 0.5;
          imperium_self.units["fighter"].cost = 0.5;

          return 1;

        }
  });


  this.importAgendaCard('wormhole-travel-ban', {
  	name : "Wormhole Travel Ban" ,
  	type : "Law" ,
  	text : "All wormholes are closed." ,
  	img : "/imperium/img/agenda_card_template.png" ,
        returnAgendaOptions : function(imperium_self) { return ['support','oppose']; },
        onPass : function(imperium_self, winning_choice) {
	  if (this.returnAgendaOptions(imperium_self)[winning_choice] == "support") {
	    imperium_self.game.state.wormholes_open = 0;
	  }
	  let law_to_push = {};
	      law_to_push.agenda = "wormhole-travel-ban";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);
	  return 1;
	},
        repealAgenda(imperium_self) {
          
          let winning_choice = null;
          
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "wormhole-travel-ban") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.wormholes_open = 1;;
          
          return 1;

        }

  });





  this.importAgendaCard('archived-secret', {
  	name : "Archived Secret" ,
  	type : "Directive" ,
  	text : "Elected Player draws one secret objective" ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
	},
	onPass : function(imperium_self, winning_choice) {
	  imperium_self.game.state.archived_secret = 1;

	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    if (winning_choice === imperium_self.returnFaction((i+1))) {
	      imperium_self.game.state.archived_secret_player = i+1;
	    }
	  }

	  //
	  // deal secret objective
	  //
          imperium_self.game.queue.push("gain\t"+(imperium_self.game.state.archived_secret_player)+"\tsecret_objectives\t1");
          imperium_self.game.queue.push("DEAL\t6\t"+(imperium_self.game.state.archived_secret_player)+"\t1");

	  return 1;

	},
  });



  this.importAgendaCard('economic-equality', {
  	name : "Economic Equality" ,
  	type : "Directive" ,
  	text : "FOR: all players discard all trade goods, AGAINST: players lose all trade goods and then gain 5 trade goods. " ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.economic_equality = 1;

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].goods = 0;
	    }
	    imperium_self.updateLog("All players have 0 trade goods");
          }

          if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].goods = 5;
	    }
	    imperium_self.updateLog("All players have 5 trade goods");
          }

	  imperium_self.displayFactionDashboard();

	  return 1;

	},
  });






  this.importAgendaCard('mutiny', {
  	name : "Mutiny" ,
  	type : "Directive" ,
  	text : "FOR: all who vote FOR gain 1 VP, AGAINST: all players who vote FOR lose 1 VP" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.mutiny = 1;

          if (winning_choice === "for") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "for") {
                imperium_self.game.players_info[i].vp++;
	        imperium_self.updateLog(imperium_self.returnFaction(i+1) + " gains 1 VP from Mutiny");
              }
            }
          }

          //
          // everyone who votes against discards action cards
          //
          if (winning_choice === "against") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] === "for") {
                imperium_self.game.players_info[i].vp--;
	        imperium_self.updateLog(imperium_self.returnFaction(i+1) + " loses 1 VP from Mutiny");
              }
            }
	  }

	  imperium_self.updateLeaderboard();

	  return 1;

	},
  });




  this.importAgendaCard('conventions-of-war', {
  	name : "Conventions of War" ,
  	type : "Law" ,
  	text : "FOR: cultural planets are exempt from bombardment, AGAINST: players who vote against discard all action cards" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.conventions_of_war = 1;

          if (winning_choice === "for") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "against") {
                imperium_self.game.players_info[i].action_cards_in_hand = 0;
		if (imperium_self.game.player == (i+1)) {
		  imperium_self.game.deck[1].hand = [];
		}
              }
            }
          }

          //
          // everyone who votes against discards action cards
          //
          if (winning_choice === "against") {
            imperium_self.game.state.bombardment_against_cultural_planets = 0;
	  }

	  let law_to_push = {};
	      law_to_push.agenda = "conventions-of-war";
	      law_to_push.option = winning_choice;
	  imperium_self.game.state.laws.push(law_to_push);

	  return 1;

	},
        repealAgenda(imperium_self) {
          
          let winning_choice = null;
          
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "conventions-of-war") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.bombardment_against_cultural_planets = 1;          

          return 1;

        }

  });





  this.importAgendaCard('swords-to-ploughshares', {
  	name : "Swords to Ploughshares" ,
  	type : "Directive" ,
  	text : "FOR: everyone destroys half their infantry (round up) on every planet, AGAINST: everyone gains 1 infantry each planet" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.swords_to_ploughshares = 1;

          if (winning_choice === "against") {
            for (let i in imperium_self.game.planets) {
	      if (imperium_self.game.planets[i].owner != -1) {
		imperium_self.game.planets[i].units[imperium_self.game.planets[i].owner-1].push(imperium_self.returnUnit("infantry", imperium_self.game.planets[i].owner));
	      }
	    }
	  }


          //
          // everyone who votes against discards action cards
          //

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {

	      let total_infantry_destroyed = 0;

              for (let k in imperium_self.game.planets) {
	        if (imperium_self.game.planets[k].owner == (i+1)) {

		  let destroy_this_infantry = 0;

		  for (let m = 0; m < imperium_self.game.planets[k].units[i].length; m++) {
		    if (imperium_self.game.planets[k].units[i][m].type == "infantry") {
		      if (destroy_this_infantry == 1) {
			destroy_this_infantry = 0;
			total_infantry_destroyed++;
		      } else {
			destroy_this_infantry = 1;
		      }
		    }
		  }

		  for (let m = 0, n = 0; n < total_infantry_destroyed && m < imperium_self.game.planets[k].units[i].length; m++) {
		    if (imperium_self.game.planets[k].units[i][m].type == "infantry") {
		      imperium_self.game.planets[k].units[i].splice(m, 1);
		      m--;
		      n++;
		    }
		  }


	        }
	      }

	      if (total_infantry_destroyed == 1) {
  	        imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " gains " + total_infantry_destroyed + " trade good");
	      } else {
  	        imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " gains " + total_infantry_destroyed + " trade goods");
	      }

	    }
	  }

	  return 1;

	},
  });




  this.importAgendaCard('wormhole-research', {
  	name : "Wormhole Research" ,
  	type : "Directive" ,
  	text : "FOR: all ships in sectors with alpha and beta wormholes are destroyed, their owners research 1 technology, AGAINST: everyone who voted against loses a command token" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.wormhole_research = 1;

	  let players_to_research_tech = [];

          if (winning_choice === "for") {
	    for (let i in imperium_self.game.sectors) {
	      if (imperium_self.game.sectors[i].wormhole != 0) {
	        for (let k = 0; k < imperium_self.game.sectors[i].units.length; k++) {
	          if (imperium_self.game.sectors[i].units[k].length > 0) {
	            imperium_self.game.sectors[i].units[k] = [];
		    if (!players_to_research_tech.includes((k+1))) {
		      players_to_research_tech.push((k+1));
		    }
		  }
		}
	      }
            }

	    players_to_research_tech.sort();
	    for (let i = 0; i < players_to_research_tech.length; i++) { 
	      imperium_self.game.queue.push("reearch\t"+players_to_research_tech[i]);
	    }
          }





          //
          // everyone who votes against loses command token
          //
          if (winning_choice === "against") {
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              if (imperium_self.game.state.choices[imperium_self.game.state.how_voted_on_agenda[i]] == "against") {
                imperium_self.game.players_info[i].command_tokens--;
                if (imperium_self.game.players_info[i].command_tokens <= 0) {
                  imperium_self.game.players_info[i].command_tokens = 0;
		}
	      }
	    }
	    imperium_self.updateTokenDisplay();
	  }
	  return 1;

	},
  });







  this.importAgendaCard('new-constitution', {
  	name : "New Constitution" ,
  	type : "Directive" ,
  	text : "FOR: remove all laws in play and exhaust all homeworld at the start of the next round" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.new_constitution = 1;

	  //
	  // repeal any laws in plan
	  //
	  for (let i = imperium_self.game.state.laws.length-1; i > 0; i--) {
	    let saved_agenda = imperium_self.game.state.laws[i].agenda;
	    imperium_self.agenda_cards[saved_agenda].repealAgenda(imperium_self);
	  }

	  let players_to_research_tech = [];

          if (winning_choice === "for") {
	    imperium_self.game.state.laws = [];
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.players_info[i].must_exhaust_at_round_start.push("homeworld");
            }
          }

	  return 1;


	},
  });






  this.importAgendaCard('shared-research', {
  	name : "Shared Research" ,
  	type : "Directive" ,
  	text : "FOR: each player activates their home system, AGAINST: units can move through nebulas" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.shared_research = 1;

	  let players_to_research_tech = [];

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      imperium_self.game.queue.push("activate\t"+(i+1)+"\t"+imperium_self.returnPlayerHomeworld((i+1)));
            }
          }

          if (winning_choice === "against") {
	    imperium_self.game.players_info[i].fly_through_nebulas = 1;
	  }

	  return 1;

	},
  });







  this.importAgendaCard('wormhole-reconstruction', {
  	name : "Wormhole Reconstruction" ,
  	type : "Directive" ,
  	text : "FOR: alpha and beta wormholes connect to each other, AGAINST:  each player activates all systems with alpha and beta wormholes" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
	onPass : function(imperium_self, winning_choice) {

	  imperium_self.game.state.wormhole_reconstruction = 1;

          if (winning_choice === "for") {
	    imperium_self.game.state.wormholes_adjacent = 1;
          }

          if (winning_choice === "against") {
	    for (let i in imperium_self.game.sectors) {
	      if (imperium_self.game.sectors[i].wormhole == 1 || imperium_self.game.sectors[i].wormhole == 2) {
		for (let ii = 0; ii < imperium_self.game.players_info.length; ii++) {
		  imperium_self.game.sectors[i].activated[ii] = 1;
		}
	        let sys = imperium_self.returnSectorAndPlanets(i);
		if (sys.s) {
		  imperium_self.updateSectorGraphics(i);
		}
	      }
	    }
	  }

	  return 1;

	},
  });





  this.importAgendaCard('crown-of-emphidia', {
        name : "Crown of Emphidia" ,
        type : "Law" ,
        elect : "player" ,
        text : "Elect a Player to earn 1 VP. When this player loses a homeworld to another player, they lose 1 VP and their opponent gains 1 VP" ,
        returnAgendaOptions : function(imperium_self) {
          let options = [];
          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            options.push(imperium_self.returnFaction(i+1));
          }
          return options;
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.crown_of_emphidia = 1;

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            if (winning_choice === imperium_self.returnFaction((i+1))) {
              imperium_self.game.state.crown_of_emphidia_player = i+1;
            }
          }

          let law_to_push = {};
              law_to_push.agenda = "crown-of-emphidia";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);

          imperium_self.game.players_info[imperium_self.game.state.crown_of_emphidia_player-1].vp += 1;
          imperium_self.updateLeaderboard();
          imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.crown_of_emphidia_player) + " gains 1 VP from Crown of Emphidia");

        },
        repealAgenda(imperium_self) {
          
          let winning_choice = null;
          
          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "crown-of-emphidia") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }
          
          imperium_self.game.state.crown_of_emphidia = -1;
          imperium_self.game.state.crown_of_emphidia_player = -1;
          
          return 1;

        },
        groundCombatRoundEnd : function(imperium_self, attacker, defender, sector, planet_idx) {
          if (defender == imperium_self.game.state.crown_of_emphidia_player) {
            if (!imperium_self.doesPlayerHaveInfantryOnPlanet(defender, sector, planet_idx)) {
              if (imperium_self.doesPlayerHaveInfantryOnPlanet(attacker, sector, planet_idx)) {
                imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.crown_of_emphidia_player) + " loses the Crown of Emphidia (-1VP)");
                imperium_self.game.state.crown_of_emphidia_player = attacker;
                imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.crown_of_emphidia_player) + " gains the Crown of Emphidia (+1VP)");
                imperium_self.game.players_info[attacker-1].vp += 1;
                imperium_self.game.players_info[defender-1].vp -= 1;
                imperium_self.updateLeaderboard();
	      }
            }
          }

	  return 1;

        },
  });

  this.importAgendaCard('terraforming-initiative', {
        name : "Terraforming Initiative" ,
        type : "Law" ,
        elect : "planet" ,
        text : "Elect a hazardous planet. The resource and influence values of this planet are increased by 1 point each" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "hazardous") { return 1; } return 0;
          });
        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.terraforming_initiative = 1;
          imperium_self.game.state.terraforming_initiative_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "terraforming-initiative";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);

          //
          // alter planet
          //
          imperium_self.game.planets[winning_choice].resources++;
          imperium_self.game.planets[winning_choice].influence++;
          imperium_self.updateLog(imperium_self.game.planets[winning_choice].name + " increases resource and influence through terraforming");

	  return 1;

        },
        repealAgenda(imperium_self) {

          let winning_choice = null;

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "terraforming-initiative") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;
            }
          }

          imperium_self.game.state.terraforming_initiative = -1;
	  if (winning_choice) {
            if (imperium_self.game.planets[winning_choice]) {
              imperium_self.game.planets[winning_choice].resources--;
              imperium_self.game.planets[winning_choice].influence--;
            }
	  }
	  imperium_self.game.state.terraforming_initiative_planet = -1;

          return 1;

        },

  });


  this.importAgendaCard('senate-sanctuary', {
        name : "Senate Sanctuary" ,
        type : "Law" ,
        elect : "planet" ,
        text : "Elect a cultural planet. The influence value of this planet is increased by 2 points" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "cultural") { return 1; } return 0;
          });
        },
        repealAgenda(imperium_self) {
  
          let winning_choice = null;     

          for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
            if (imperium_self.game.state.laws[i].agenda === "senate-sanctuary") {
              winning_choice = imperium_self.game.state.laws[i].option;
              imperium_self.game.state.laws.splice(i, 1);
              i--;    
            }
          }

          if (winning_choice) {
            if (imperium_self.game.planets[winning_choice]) {
              imperium_self.game.planets[winning_choice].influence -= 2;
            }
          }
          imperium_self.game.state.senate_sanctuary = 0;
          imperium_self.game.state.senate_sanctuary_planet = -1;

          return 1;

        },
        onPass : function(imperium_self, winning_choice) {
          imperium_self.game.state.senate_sanctuary = 1;
          imperium_self.game.state.senate_sanctuary_planet = winning_choice;
          let law_to_push = {};
              law_to_push.agenda = "senate-sanctuary";
              law_to_push.option = winning_choice;
          imperium_self.game.state.laws.push(law_to_push);

          //
          // alter planet
          //
          imperium_self.game.planets[winning_choice].influence+=2;
          imperium_self.updateLog(imperium_self.game.planets[winning_choice].name + " increases influence value by 2");

	  return 1;

        }
  });


  this.importAgendaCard('publicize-weapons-schematics', {
        name : "Publicize Weapons Schematics" ,
        type : "Directive" ,
        text : "FOR: all players now have War Suns technology, AGAINST: all players with War Suns technology discard all action cards" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.publicize_weapons_schematics = 1;

          if (winning_choice === "for") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (!imperium_self.doesPlayerHaveTech((i+1), "warsun")) {
		imperium_self.game.queue.push("purchase\t"+(i+1)+"\t"+"tech"+"\t"+"warsun");
	      }
 	    }
          }

          if (winning_choice === "against") {
	    for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	      if (imperium_self.doesPlayerHaveTech((i+1), "warsun")) {
		imperium_self.game.players_info[i].action_cards_in_hand = 0;
		if (imperium_self.game.player == (i+1)) {
		  imperium_self.game.deck[1].hand = [];
		}
		imperium_self.updateLog(imperium_self.returnFaction((i+1)) + " discards all Action Cards");
	      }
	    }
	  }

	  return 1;

        }
  });



  this.importAgendaCard('incentive-program', {
        name : "Incentive Program" ,
        type : "Directive" ,
        text : "FOR: reveal a 1 VP public objective, AGAINST: reveal a 2 VP public objective" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.incentive_program = 1;

          if (winning_choice === "for") {
            imperium_self.game.queue.push("revealobjectives");
            for (let i = 1; i <= imperium_self.game.players_info.length; i++) {
              imperium_self.game.queue.push("FLIPCARD\t4\t1\t2\t"+i); // deck card poolnum player
            }
          }

          if (winning_choice === "against") {
            imperium_self.game.queue.push("revealobjectives");
            for (let i = 1; i <= imperium_self.game.players_info.length; i++) {
              imperium_self.game.queue.push("FLIPCARD\t5\t1\t3\t"+i); // deck card poolnum player
            }
	  }
	  return 1;
        }
  });


  this.importAgendaCard('colonial-redistribution', {
        name : "Colonial Redistribution" ,
        type : "Directive" ,
        elect : "planet" ,
        text : "Elect a cultural, industrial or hazardous planet. Destroy all units on the planet. Planet owner chooses a player with the fewest VP to gain control of the planet and gain 1 infantry on it. If no-one controls that planet, the Speaker chooses the recipient." ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
            if (planet.type === "cultural") { return 1; }
            if (planet.type === "industrial") { return 1; }
            if (planet.type === "hazardous") { return 1; }
	    return 0;
          });
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.colonial_redistribution = 1;
          imperium_self.game.state.colonial_redistribution_planet = winning_choice;
	  imperium_self.game.queue.push("colonial_redistribution\t"+winning_choice);

	  imperium_self.game.state.laws.push({ agenda : "colonial-redistribution" , option : winning_choice });

	  return 0;

        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "colonial_redistribution") {

            let winning_choice = mv[1];
            imperium_self.game.queue.splice(qe, 1);

	    let owner = imperium_self.game.planets[winning_choice].owner;
	    let planet_idx = imperium_self.game.planets[winning_choice].idx;
	    let sector = imperium_self.game.planets[winning_choice].sector;

	    if (owner == -1) { owner = imperium_self.game.state.speaker; }
	    imperium_self.game.planets[winning_choice].units[owner] = [];

	    if (imperium_self.game.player == owner) {
            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player to receive 1 infantry and this planet" ,
              function(player) {
	        let lower_vp_player = 0;
		let this_player_vp = player.vp;
	        for (let i = 0; i < imperium_self.game.players_info.length; i++) {
		  if (imperium_self.game.players_info[i] < this_player_vp) { lower_vp_player = 1; }
		}
	        if (lower_vp_player == 1) { return 0; }
		return 1;
              },
	      function(player) {
		imperium_self.updateStatus("");
		imperium_self.addMove("produce\t" + player + "\t" + "1" + "\t" + planet_idx + "\t" + "infantry" + "\t" + sector);
		imperium_self.addMove("annex\t" + player + "\t" + sector + "\t" + planet_idx);
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(player) + " gains the contested planet");
		imperium_self.endTurn();
		return 0;
	      },
	    );
	    }

            return 0;
          }

          return 1;
        }
  });



  this.importAgendaCard('compensated-disarmament', {
        name : "Compensated Disarmament" ,
        type : "Directive" ,
        elect : "planet" ,
        text : "Destroy all ground forces on planet. For each infantry destroyed planet owner gains 1 trade good" ,
        returnAgendaOptions : function(imperium_self) {
          return imperium_self.returnPlanetsOnBoard(function(planet) {
	    return 1;
          });
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.compensated_disarmament = 1;
          imperium_self.game.state.compensated_disarmament_planet = winning_choice;

console.log("planet is: " + winning_choice);

	  let planet = imperium_self.game.planets[winning_choice];
	  let owner = parseInt(planet.owner);
	  let total_infantry = 0;

	  if (owner == -1) { return 1; }

	  let units_to_check = planet.units[owner-1].length;
	  for (let i = 0; i < units_to_check; i++) {
	    let unit = planet.units[owner-1][i];
	    if (unit.type == "infantry") {
	      total_infantry++;
	      planet.units[owner-1].splice(i, 1);
	      i--;
	      units_to_check = planet.units[owner-1].length;
	    }
	  }

	  if (total_infantry > 0) {
	    imperium_self.game.queue.push("purchase\t"+owner+"\tgoods\t"+total_infantry);
	  }

	  imperium_self.updateSectorGraphics(planet.sector);

	  return 1;

        }
  });


  this.importAgendaCard('judicial-abolishment', {
        name : "Judicial Abolishment" ,
        type : "Directive" ,
        elect : "law" ,
        text : "Discard a law if one is in play" ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	    options.push(imperium_self.agenda_cards[imperium_self.game.state.laws[i].agenda].name);
	  }
	  return options;
        },
        onPass : function(imperium_self, winning_choice) {

          imperium_self.game.state.judicial_abolishment = 1;
          imperium_self.game.state.judicial_abolishment_law = winning_choice;

	  let repealed = null;

	  for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	    if (winning_choice === imperium_self.agenda_cards[imperium_self.game.state.laws[i].agenda].name) {
	      imperium_self.agenda_cards[ imperium_self.game.state.laws[i].agenda ].repealAgenda(imperium_self);
	      repealed = imperium_self.game.state.laws[i].agenda;
	      i = imperium_self.game.state.laws.length+2;
	    }
	  }

	  if (repealed) {
	    imperium_self.updateLog(imperium_self.agenda_cards[repealed].name + " abolished");
	  }

	  return 1;

        }
  });




  this.importAgendaCard('public-execution', {

        name : "Public Execution" ,
        type : "Directive" ,
	elect : "player" ,
        text : "Elect a player. They discard all their action cards, lose the speaker token to the next player in initiative order (if they have it) and lose all of their votes." ,
        returnAgendaOptions : function(imperium_self) {
	  let options = [];
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    options.push(imperium_self.returnFaction(i+1));
	  }
	  return options;
	},
        onPass : function(imperium_self, winning_choice) {

	  let initiative_order = imperium_self.returnInitiativeOrder();

          imperium_self.game.state.public_execution = 1;

          for (let i = 0; i < imperium_self.game.players_info.length; i++) {
            if (winning_choice === imperium_self.returnFaction((i+1))) {
              imperium_self.game.state.public_execution_player = i+1;
            }
          }


	  // lose action cards
          imperium_self.game.players_info[imperium_self.game.state.public_execution_player-1].action_cards_in_hand = 0;
	  if (imperium_self.game.player == imperium_self.game.state.public_execution_player) {
	    imperium_self.game.deck[1].hand = [];
	  }

	  // lose speakership
	  if (winning_choice == imperium_self.game.state.speaker) {
	    imperium_self.game.state.speaker = initiative_order[0];
	    for (let i = 0; i < initiative_order.length-1; i++) {
	      if (initiative_order[i] == imperium_self.game.state.public_execution_player) {
	        imperium_self.game.state.speaker = initiative_order[i+1];
	      }
	    }
	  }

	  // lose all voting power
          imperium_self.game.state.votes_available[imperium_self.game.state.public_execution_player-1] = 0;

	  imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.public_execution_player) + " representative publicly executed");

	  return 1;

        }
  });








  this.importAgendaCard('ixthian-artifact', {

        name : "Ixthian Artifact" ,
        type : "Directive" ,
        text : "FOR: roll a die. On rolls of 5 and under destroy all units on New Byzantium and 3 units in each adjacent system. On all other rolls each player researches 2 technologies" ,
        returnAgendaOptions : function(imperium_self) {
	  return ["for","against"];
	},
        onPass : function(imperium_self, winning_choice) {

	  if (winning_choice == "for") {

	    let roll = imperium_self.rollDice(10);

imperium_self.updateLog("Ixthian Artifact rolls " + roll);

	    if (roll <= 5) {

	      // destroy all units
	      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
		imperium_self.game.planets['new-byzantium'].units[i] = [];
		imperium_self.game.sectors['new-byzantium'].units[i] = [];
	      }

     	      let as = imperium_self.returnAdjacentSectors('new-byzantium');
 	      for (let i = 0; i < as.length; i++) {
	        for (let ii = 0; ii < imperium_self.game.players_info.length; ii++) {
  	          if (imperium_self.doesSectorContainPlayerUnits((ii+1), as[i])) {
		    imperium_self.game.queue.push("destroy_units\t"+(ii+1)+"\t"+3+"\t"+as[i]+"\t"+0);
    	          }
    	        }
	      }

	    }

	    if (roll >= 6) {
	      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
		imperium_self.game.queue.push("research\t"+(i+1));
		imperium_self.game.queue.push("research\t"+(i+1));
	      }
	      imperium_self.game.queue.push("ACKNOWLEDGE\tThe Ixthian Artifact did not explode. All players may now research two technologies...");
          }
        }
        return 1;
      }
  });



/************************************
  
ACTION CARD - types

"action" -> main menu
"bombardment_attacker"
"bombardment_defender"
"combat"
"ground_combat"
"pds" -> before pds fire
"post_pds" -> after pds fire
"pre_agenda" --> before agenda voting
"post_agenda" --> after agenda voting
"space_combat"
"space_combat_victory"
"rider"


************************************/


    this.importActionCard('infiltrate', {
  	name : "Infiltrate" ,
  	type : "instant" ,
  	text : "The next time you invade a planet, you may takeover any existing PDS units or Space Docks" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_infiltrate_infrastructure_on_invasion = 1;
	  return 1;
	},
    });




    this.importActionCard('reparations', {
  	name : "Reparations" ,
  	type : "action" ,
  	text : "If you have lost a planet this round, refresh one of your planets" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.players_info[action_card_player-1].lost_planet_this_round != -1) {

	    let my_planets = imperium_self.returnPlayerExhaustedPlanetCards(imperium_self.game.player);

            imperium_self.playerSelectPlanetWithFilter(
              "Select an exhausted planet to refresh: " ,
              function(planet) {
		if (my_planets.includes(planet)) { return 1; } return 0;
              },
              function(planet) {
                imperium_self.addMove("unexhaust\tplanet\t"+planet);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player)+" refreshes " + imperium_self.game.planets[planet].name);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	    return 0;
	  }
	  return 1;
	},
    });



    this.importActionCard('political-stability', {
  	name : "Political Stability" ,
  	type : "instant" ,
  	text : "Pick a strategy card you have already played this round. You may keep this for next round" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let html = '<div class="sf-readable">Pick a Strategy Card to keep for next round: </div><ul>';
	    for (let i = 0; i < imperium_self.game.players_info[action_card_player-1].strategy_cards_played.length; i++) {
	      let card = imperium_self.game.players_info[action_card_player-1].strategy_cards_played[i];
              html += '<li class="option" id="'+card+'">' + imperium_self.strategy_cards[card].name + '</li>';
	    }
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.option').off();
	    $('.option').on('click', function() {
	      let card = $(this).attr("id");
	      imperium_self.addMove("strategy_card_retained\t"+imperium_self.game.player+"\t"+card);
	      imperium_self.endTurn();
	      return 0;
	    });

	  }

	  return 0;
	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "strategy_card_retained") {

            let player = parseInt(mv[1]);
            let card = mv[2];
            imperium_self.game.queue.splice(qe, 1);
	    imperium_self.game.players_info[player-1].strategy_cards_retained.push(card);

            return 1;
          }

	  return 1;
        }
    });



    this.importActionCard('lost-star-chart', {
  	name : "Lost Star Chart" ,
  	type : "instant" ,
  	text : "During this turn, all wormholes are adjacent to each other" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.temporary_wormholes_adjacent = 1;
	  return 1;
	},
    });


    this.importActionCard('plague', {
  	name : "Plague" ,
  	type : "action" ,
  	text : "ACTION: Select a planet. Roll a dice for each infantry on planet and destroy number of rolls 6 or higher." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet to cripple with the plague:",
              function(planet) {
		return imperium_self.doesPlanetHaveInfantry(planet);
              },
	      function(planet) {
		imperium_self.addMove("plague\t"+imperium_self.game.player+"\t"+planet);
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " unleashes a plague on " + imperium_self.game.planets[planet].name);
		imperium_self.endTurn();
		return 0;
	      },
	      null
	    );
	  }
	  return 0;
	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "plague") {

            let attacker = parseInt(mv[1]);
            let target = mv[2];
	    let sector = imperium_self.game.planets[target].sector;
	    let planet_idx = imperium_self.game.planets[target].idx;
	    let sys = imperium_self.returnSectorAndPlanets(sector);
	    let z = imperium_self.returnEventObjects();
	    let player = sys.p[planet_idx].owner;

	    let total_units_destroyed = 0;

            for (let i = 0; i < sys.p[planet_idx].units.length; i++) {
              for (let ii = 0; ii < sys.p[planet_idx].units[i].length; ii++) {
		let thisunit = sys.p[planet_idx].units[i][ii];

		if (thisunit.type == "infantry") {
		  let roll = imperium_self.rollDice(10);
		  if (roll > 6) {
		    thisunit.destroyed = 1;
		    for (z_index in z) {
		      thisunit = z[z_index].unitDestroyed(this, attacker, thisunit);
		    }
	            total_units_destroyed++;
		  }
		}
	      }
            }

	    imperium_self.updateLog("The plague destroys " + total_units_destroyed + " infantry");

            imperium_self.eliminateDestroyedUnitsInSector(player, sector);
            imperium_self.saveSystemAndPlanets(sys);
            imperium_self.updateSectorGraphics(sector);
            imperium_self.game.queue.splice(qe, 1);

            return 1;
          }

	  return 1;
        }

    });



    this.importActionCard('repeal-law', {
  	name : "Repeal Law" ,
  	type : "action" ,
  	text : "ACTION: Repeal one law that is in effect." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

	    let html = '<div class="sf-readable">Pick a Law to Repeal: </div><ul>';
	    for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	      let law = imperium_self.game.state.laws[i];
	      let agenda = imperium_self.agenda_cards[law];
              html += '<li class="option" id="'+agenda+'">' + imperium_self.agenda_cards[card].name + '</li>';
	    }
            html += '<li class="option" id="cancel">cancel</li>';
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.option').off();
	    $('.option').on('click', function() {

	      let card = $(this).attr("id");

	      if (card === "cancel") {
	        imperium_self.endTurn();
		return 0;
	      }

	      imperium_self.addMove("repeal_law\t"+card);
	      imperium_self.endTurn();
	      return 0;
	    });
          }

	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "repeal_law") {

            let card = mv[2];
            imperium_self.game.queue.splice(qe, 1);
	    for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	      if (imperium_self.game.state.laws[i] == card) {
		imperium_self.agenda_cards[card].repealAgenda(imperium_self);
	        return 1;
	      }
	    }

            return 1;
          }

	  return 1;
        }
    });



    this.importActionCard('veto', {
  	name : "Veto" ,
  	type : "action" ,
  	text : "ACTION: Select one agenda to remove from consideration and draw a replacement" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            let html = '';
            html += 'Select one agenda to quash in the Galactic Senate.<ul>';
            for (i = 0; i < 3; i++) {
              html += '<li class="option" id="'+imperium_self.game.state.agendas[i]+'">' + imperium_self.agenda_cards[imperium_self.game.state.agendas[i]].name + '</li>';
            }
            html += '</ul>';

            imperium_self.updateStatus(html);

            $('.option').off();
            $('.option').on('mouseenter', function() { let s = $(this).attr("id"); imperium_self.showAgendaCard(s); });
            $('.option').on('mouseleave', function() { let s = $(this).attr("id"); imperium_self.hideAgendaCard(s); });
            $('.option').on('click', function() {

              let agenda_to_quash = $(this).attr('id');

	      imperium_self.hideAgendaCard(agenda_to_quash);

              imperium_self.updateStatus("Quashing Agenda");
              imperium_self.addMove("quash\t"+agenda_to_quash+"\t"+"1"); // 1 = re-deal
              imperium_self.endTurn();
            });
          }

	  return 0;
        }
    });


    this.importActionCard('flank-speed1', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed2', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed3', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed4', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });



    this.importActionCard('propulsion-research', {
  	name : "Propulsion Research" ,
  	type : "instant" ,
  	text : "Gain +1 movement on a single ship moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_ship_move_bonus = 1;
	  return 1;
	}
    });




    this.importActionCard('military-drills', {
  	name : "Military Drills" ,
  	type : "action" ,
  	text : "ACTION: Gain two new command tokens" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    imperium_self.playerAllocateNewTokens(action_card_player, 2);
	  }
	  return 0;
	}
    });



    this.importActionCard('cripple-defenses', {
  	name : "Cripple Defenses" ,
  	type : "action" ,
  	text : "ACTION: Select a planet and destroy all PDS units on that planet" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet to destroy all PDS units on that planet: ",
              function(planet) {
		return imperium_self.doesPlanetHavePDS(planet);
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
		let tile = planet.tile;	        
		let planet_idx = planet.idx;
		let sys = imperium_self.returnSectorAndPlanets(sector);

		for (let b = 0; b < sys.p[planet_idx].units.length; b++) {
		  for (let bb = 0; bb < sys.p[planet_idx].units[b].length; bb++) {
		    if (sys.p[planet_idx].units[b][bb].type == "pds") {
		      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+(b+1)+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+bb+"\t"+"1");
		    }
                  }
                }

		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys all PDS units destroyed on "+sys.p[planet_idx].name);
		imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('reactor-meltdown', {
  	name : "Reactor Meltdown" ,
  	type : "action" ,
  	text : "ACTION: Select a non-homeworld planet and destroy one Space Dock on that planet" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a non-homeworld planet and destroy one Space Dock on that planet: " ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
	        if (planet.hw == 0 && imperium_self.doesPlanetHaveSpaceDock(planet)) {
		  return 1;
		}
              },
	      function(planet) {
		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
		let tile = planet.tile;	        
		let planet_idx = planet.idx;
		let sys = imperium_self.returnSectorAndPlanets(sector);

		for (let b = 0; b < sys.p[planet_idx].units.length; b++) {
		  for (let bb = 0; bb < sys.p[planet_idx].units[b].length; bb++) {
		    if (sys.p[planet_idx].units[b][bb].type == "spacedock") {
		      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+(b+1)+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+bb+"\t"+"1");
		    }
                  }
                }

		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys all Space Docks on "+sys.p[planet_idx].name);
		imperium_self.endTurn();
		return 0;

	      },
	      // cancel -- no space dock available?
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('lost-mission', {
  	name : "Lost Mission" ,
  	type : "action" ,
  	text : "ACTION: Place 1 Destroyer in a system with no existing ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector with no existing ships in which to place a Destroyer: ",
              function(sector) {
		return !imperium_self.doesSectorContainShips(sector);
              },
	      function(sector) {

                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdestroyer\t"+sector);
                imperium_self.addMove("NOTIFY\tAdding destroyer to gamebaord");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });

    this.importActionCard('accidental-colonization', {
  	name : "Accidental Colonization" ,
  	type : "action" ,
  	text : "ACTION: Gain control of one planet not controlled by any player" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet not controlled by another player: ",
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner == -1) { return 1; } return 0;
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
                imperium_self.addMove("gain_planet\t"+imperium_self.game.player+"\t"+sector+"\t"+planet.idx);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " gains planet " + planet.name);
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('uprising', {
  	name : "Uprising" ,
  	type : "action" ,
  	text : "ACTION: Exhaust a non-home planet card held by another player. Gain trade goods equal to resource value." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Exhaust a non-homeworld planet card held by another player. Gain trade goods equal to resource value." ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner != -1 && planet.owner != imperium_self.game.player && planet.exhausted == 0 && planet.hw == 0) { return 1; } return 0;
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let goods = planet.resources;

                imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+goods);
                imperium_self.addMove("expend\t"+imperium_self.game.player+"\tplanet\t"+planet.planet);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " exhausting "+planet.name + " and gaining " + goods + " trade goods");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });



    this.importActionCard('diaspora-conflict', {
  	name : "Diaspora Conflict" ,
  	type : "action" ,
  	text : "ACTION: Exhaust a non-home planet card held by another player. Gain trade goods equal to resource value." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Exhaust a planet card held by another player. Gain trade goods equal to resource value." ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner != -1 && planet.owner != imperium_self.game.player && planet.exhausted == 0 && planet.hw ==0) { return 1; } return 0;
              },
	      function(planet) {

	        let planetname = planet;
		planet = imperium_self.game.planets[planet];
		let goods = planet.resources;

                imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+goods);
                imperium_self.addMove("expend\t"+imperium_self.game.player+"\tplanet\t"+planetname);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " exhausting "+planet.name + " and gaining " + goods + " trade goods");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });



    this.importActionCard('economic-initiative', {
  	name : "Economic Initiative" ,
  	type : "action" ,
  	text : "ACTION: Ready each cultural planet in your control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      if (imperium_self.game.planets[i].type == "cultural") {
		imperium_self.game.planets[i].exhausted = 0;
	      }
	    }
	  }
	  return 1;
	}
    });


    this.importActionCard('focused-research', {
  	name : "Focused Research" ,
  	type : "action" ,
  	text : "ACTION: Spend 4 Trade Goods to Research 1 Technology" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let p = imperium_self.game.players_info[imperium_self.game.player-1];

	  if (p.goods < 4) {
	    imperium_self.updateLog("Player does not have enough trade goods to research a technology");
	    return 1;
	  }

	  //
	  // otherwise go for it
	  //
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerResearchTechnology(function(tech) {
              imperium_self.addMove("purchase\t"+imperium_self.game.player+"\ttech\t"+tech);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tgoods\t4");
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " researches " + imperium_self.tech[tech].name);
              imperium_self.endTurn();
	    });

	  }
	  return 0;
	}
    });



    this.importActionCard('frontline-deployment', {
  	name : "Frontline Deployment" ,
  	type : "action" ,
  	text : "ACTION: Deploy three infantry on one planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
              "Deploy three infantry to a planet you control: ",
              function(planet) {
                if (imperium_self.game.planets[planet].owner == imperium_self.game.player) { return 1; } return 0;
              },
              function(planet) {
		planet = imperium_self.game.planets[planet];
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys three infantry to " + planet.name);
                imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
	}
    });



    this.importActionCard('ghost-ship', {
  	name : "Ghost Ship" ,
  	type : "action" ,
  	text : "ACTION: Place a destroyer in a sector with a wormhole and no enemy ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {
            imperium_self.playerSelectSectorWithFilter(
              "Place a destroyer in a sector with a wormhole and no enemy ships: " ,
              function(sector) {
                if (imperium_self.doesSectorContainShips(sector) == 0 && imperium_self.game.sectors[sector].wormhole != 0) { return 1; } return 0;
              },
              function(sector) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+"-1"+"\t"+"destroyer"+"\t"+sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys a Destroyer to " + imperium_self.game.sectors[sector].name);
               imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
        }
    });



    this.importActionCard('war-effort', {
  	name : "War Effort" ,
  	type : "action" ,
  	text : "ACTION: Place a cruiser in a sector with one of your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
              "Place a cruiser in a sector with one of your ships: " ,
              function(sector) {
                if (imperium_self.doesSectorContainPlayerShips(player, sector) == 1) { return 1; } return 0;
              },
              function(sector) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+"-1"+"\t"+"cruiser"+"\t"+sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys a Cruiser to " + imperium_self.game.sectors[sector].name);
                imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
        }
    });





    this.importActionCard('industrial-initiative', {
  	name : "Industrial Initiative" ,
  	type : "action" ,
  	text : "ACTION: Gain a trade good for each industrial planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let trade_goods_to_gain = 0;

	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      if (imperium_self.game.planets[i].type == "industrial") {
		trade_goods_to_gain++;
	      }
	    }
	  }

	  if (trade_goods_to_gain > 0 ) {
            imperium_self.game.queue.push("purchase\t"+imperium_self.game.player+"\tgoods\t"+trade_goods_to_gain);
	  }

	  return 1;
	}
    });




    this.importActionCard('Insubordination', {
  	name : "Insubordination" ,
  	type : "action" ,
  	text : "ACTION: Select a player and remove 1 token from their command pool" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player and remove one token from their command pool: " ,
              function(player) {
	        if (player != imperium_self.game.player) { return 1; } return 0;
              },
	      function(player) {
                imperium_self.addMove("expend\t"+player+"\tcommand\t"+"1");
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFactionNickname(player) + " loses one comand token");
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
        }
    });




    this.importActionCard('Lucky Shot', {
  	name : "Lucky Shot" ,
  	type : "action" ,
  	text : "ACTION: Destroy a destroyer, cruiser or dreadnaught in a sector with a planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Destroy a destroyer, cruiser or dreadnaught in a sector containing a planet you control: " ,
              function(sector) {
  		if (imperium_self.doesSectorContainPlanetOwnedByPlayer(sector, imperium_self.game.player)) {
  		  if (imperium_self.doesSectorContainUnit(sector, "destroyer") || imperium_self.doesSectorContainUnit(sector, "cruiser") || imperium_self.doesSectorContainUnit(sector, "dreadnaught")) {
		    return 1;
		  }
		}
		return 0;
              },
	      function(sector) {

                imperium_self.playerSelectUnitInSectorWithFilter(
	          "Select a ship in this sector to destroy: " ,
		  sector,
                  function(unit) {
		    if (unit.type == "destroyer") { return 1; }
		    if (unit.type == "cruiser") { return 1; }
		    if (unit.type == "dreadnaught") { return 1; }
		    return 0;
                  },
	          function(unit_info) {

		    let s = unit_info.sector;
		    let p = parseInt(unit_info.unit.owner);
		    let uidx = unit_info.unit_idx;

		    let sys = imperium_self.returnSectorAndPlanets(s);
		    let unit_to_destroy = unit_info.unit;

                    imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+unit_to_destroy.owner+"\t"+"space"+"\t"+s+"\t"+"-1"+"\t"+uidx+"\t"+"1");
		    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit_to_destroy.name + " in " + sys.name);
		    imperium_self.endTurn();
		    return 0;
	          },
	          null
	        );
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
        }
    });





    this.importActionCard('mining-initiative-ac', {
  	name : "Mining Initiative" ,
  	type : "action" ,
  	text : "ACTION: Gain trade goods equal to the highest resource value planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

   	    let maximum_resources = 0;
	    for (let i in imperium_self.game.planets) {
	      if (imperium_self.game.planets[i].owner == action_card_player && imperium_self.game.planets[i].resources > maximum_resources) {
		maximum_resources = imperium_self.game.planets[i].resources;
	      }
	    }

            imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+maximum_resources);
            imperium_self.endTurn();
	    return 0;

	  }
	  return 0;
	}
    });




    this.importActionCard('rise-of-a-messiah', {
  	name : "Rise of a Messiah" ,
  	type : "action" ,
  	text : "ACTION: Add one infantry to each planet player controls" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " adds 1 infantry to " + imperium_self.game.planets[i].name);
	      imperium_self.addPlanetaryUnit(action_card_player, imperium_self.game.planets[i].sector, imperium_self.game.planets[i].idx, "infantry");
	    }
	  }
	  return 1;
	}
    });



    this.importActionCard('unstable-planet', {
  	name : "Unstable Planet" ,
  	type : "action" ,
  	text : "ACTION: Choose a hazardous planet and exhaust it. Destroy 3 infantry on that planet if they exist" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a hazardous planet and exhaust it. Destroy 3 infantry on that planet if they exist" ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
	        if (planet.type == "hazardous") { return 1; } return 0;
              },
	      function(planet) {
                imperium_self.addMove("expend\t"+player+"\tplanet\t"+planet);

		let planet_obj   = imperium_self.game.planets[planet];	
		let planet_owner = parseInt(planet_obj.owner);
		let planet_res   = parseInt(planet_obj.resources);

		let infantry_destroyed = 0;

		if (planet_owner >= 0) {
		  for (let i = 0; i < planet_obj.units[planet_owner-1].length; i++) {
		    if (infantry_destroyed < 3) {
		      if (planet_obj.units[planet_owner-1][i].type == "infantry") {
		        imperium_self.addMove("destroy_unit\t"+action_card_player+"\t"+planet_owner+"\t"+"ground"+"\t"+planet_obj.sector+"\t"+planet_obj.idx+"\t"+"1");
		    	infantry_destroyed++;
		      }
		    }
		  }
		}
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });






    this.importActionCard('Covert Operation', {
  	name : "Covert Operation" ,
  	type : "action" ,
  	text : "ACTION: Choose a player. They give you one of their action cards, if possible" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player. They give you one of their action cards: ",
              function(player) {
	        if (player != imperium_self.game.player) { return 1; } return 0;
              },
	      function(player) {
                imperium_self.addMove("pull\t"+imperium_self.game.player+"\t"+player+"\t"+"action"+"\t"+"random");
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " pulls a random action card from " + imperium_self.returnFaction(player));
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('tactical-bombardment', {
  	name : "Tactical Bombardment" ,
  	type : "action" ,
  	text : "ACTION: Choose a sector in which you have ships with bombardment. Exhaust all planets in that sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector in which you have ships with bombardment. Exhaust all planets in that sector" ,
              function(sector) {
	        if (imperium_self.doesSectorContainPlayerUnit(player, sector, "dreadnaught") == 1) { return 1; }
	        if (imperium_self.doesSectorContainPlayerUnit(player, sector, "warsun") == 1) { return 1; }
		return 0;
              },

	      function(sector) {

		let planets_in_sector = imperium_self.game.sectors[sector].planets;
		for (let i = 0; i < planets_in_sector.length; i++) {
                  imperium_self.addMove("expend\t"+player+"\tplanet\t"+planets_in_sector[i]);
		  imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " exhausts " + imperium_self.game.planets[planets_in_sector[i]].name);
		}
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('signal-jamming', {
  	name : "Signal Jamming" ,
  	type : "action" ,
  	text : "ACTION: Choose a player. They must activate a system in or next to a system in which you have a ship" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector in which you have a ship or one adjacent to one: ",
              function(sector) {
	        if (imperium_self.isPlayerShipAdjacentToSector(action_card_player, sector)) {
		  return 1;
		}
	        return 0;
              },
	      function(sector) {

            	imperium_self.playerSelectPlayerWithFilter(
	          "Select a player to signal jam in that sector: " ,
                  function(p) {
	            if (p != imperium_self.game.player) { return 1; } return 0;
                  },
	          function(p) {
                    imperium_self.addMove("activate\t"+p+"\t"+sector);
		    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(p) + " suffers signal jamming in " + imperium_self.game.sectors[sector].name);
		    imperium_self.endTurn();
		    return 0;
	          },
	          null
	        );
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('unexpected-action', {
  	name : "Unexpected Action" ,
  	type : "action" ,
  	text : "ACTION: Deactivate a stystem you have activated. Gain one command or strategy token: ", 
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector that you have activated and deactivate it: " ,
              function(sector) {
		if (imperium_self.game.sectors[sector].activated[action_card_player-1] == 1) {
		  return 1;
		}
              },
	      function(sector) {
                imperium_self.addMove("purchase\t"+action_card_player+"\tcommand\t"+"1");
                imperium_self.addMove("deactivate\t"+action_card_player+"\t"+sector);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " deactivates " + imperium_self.game.sectors[sector].name);
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('in-the-silence-of-space', {
  	name : "In the Silence of Space" ,
  	type : "instant" ,
  	text : "Your ships may move through sectors with other player ships this turn: " ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_move_through_sectors_with_opponent_ships = 1;
	  return 1;
	}
    });



    this.importActionCard('upgrade', {
  	name : "Upgrade" ,
  	type : "activate" ,
  	text : "After you activate a system containing one of your ships, place a Dreadnaught from your reinforcements in that sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let sector = imperium_self.game.state.activated_sector;
	  if (imperium_self.doesSectorContainPlayerShips(action_card_player, sector)) {
	    imperium_self.addSpaceUnit(action_card_player, sector, "dreadnaught");
	  }

	  return 1;
	}
    });



    this.importActionCard('disable', {
  	name : "Disable" ,
  	type : "activate" ,
  	text : "Your fleet cannot be hit by PDS fire or Planetary Defense during this invasion" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_immune_to_pds_fire = 1;
	  imperium_self.game.players_info[action_card_player-1].temporary_immune_to_planetary_defense = 1;
	  return 1;
	}
    });





    this.importActionCard('bunker', {
  	name : "Bunker" ,
  	type : "bombardment_defender" ,
  	text : "During this bombardment, attacker gets -4 applied to each bombardment roll." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_bombardment_combat_roll_modifier = -4;
	  }
	  return 1;
	}
    });


    this.importActionCard('thunder-from-the-heavens', {
  	name : "Thunder from the Heavens" ,
  	type : "bombardment_attacker" ,
  	text : "During this bombardment, attacker gets +2 applied to each bombardment roll." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_bombardment_combat_roll_modifier = 2;
	  }
	  return 1;
	}
    });




    this.importActionCard('sabotage1', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage2', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage3', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage4', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });



    this.importActionCard('fire-team', {
  	name : "Fire Team" ,
  	type : "ground_combat" ,
  	text : "Reroll up to 15 dice during this round of ground combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].combat_dice_reroll = 15; // 15 
	  return 1;

	}
    });


    this.importActionCard('parley', {
  	name : "Parley" ,
  	type : "ground_combat" ,
  	text : "Return invading infantry to space if player ships exist in the sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	
	  if (player == action_card_player) {

	    let sector = imperium_self.game.state.ground_combat_sector;
	    let planet_idx = imperium_self.game.state.ground_combat_planet_idx;
	    let attacker = imperium_self.game.state.ground_combat_attacker;

	    let sys = imperium_self.returnSectorAndPlanets(sector);

	    let attacker_infantry = sys.p[planet_idx].units[attacker-1];
	    sys.p[planet_idx].units[attacker-1] = [];;

	    for (let i = 0; i < sys.s.units[attacker-1].length; i++) {
	      while (imperium_self.returnRemainingCapacity(sys.s.units[attacker-1][i]) > 0 && attacker_infantry.length > 0) {
		imperium_self.loadUnitByJSONOntoShip(attacker, sector, i, JSON.stringify(attacker_infantry[0]));
	        attacker_infantry.splice(0, 1);
	      }
	    }

	  }

	  imperium_self.updateSectorGraphics(sector);
	  return 1;

	}

    });




/*****
    this.importActionCard('confusing-legal-text', {
  	name : "Confusing Legal Text" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his votes, pick another player to win if you are the leading candidate" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

//	    imperium_self.game.state.votes_cast[bribing_player-1].votes += goods_spent;

	  if (imperium_self.agenda_cards[card].elect === "player") {

            let winning_options = [];
            for (let i = 0; i < imperium_self.game.state.choices.length; i++) {
              winning_options.push(0);
            }
            for (let i = 0; i < imperium_self.game.players.length; i++) {
              winning_options[imperium_self.game.state.how_voted_on_agenda[i]] += imperium_self.game.state.votes_cast[i];
            }

            //
            // determine winning option
            //
            let max_votes_options = -1;
            let max_votes_options_idx = 0;
            for (let i = 0; i < winning_options.length; i++) {
              if (winning_options[i] > max_votes_options) {
                max_votes_options = winning_options[i];
                max_votes_options_idx = i;
              }
            }

            let total_options_at_winning_strength = 0;
            for (let i = 0; i < winning_options.length; i++) {
              if (winning_options[i] == max_votes_options) { total_options_at_winning_strength++; }
            }

	    if (total_options_at_winning_strength == 1) {

	      //
	      // cast 1000 votes for someone else
	      //
	      if (imperium_self.game.player == action_card_player) { 
                html = '<div class="sf-readable">Who do you wish to be elected instead? </div><ul>';
	        for (let i = 0; i < imperium_self.game.state.choices.length; i++) {
		  if (imperium_self.game.state.choices[i] != imperium_self.game.player) {
		    html += '<li class="options textchoice" id="'+imperium_self.game.state.choices[i]+'">'+imperium_self.returnFaction(imperium_self.game.state.choices[i])+'</li>';
		  }
	        }
		html += '</ul>';
	      }

      	      $('.textchoice').off();
	      $('.textchoice').on('click', function() {

		let action = $(this).attr("id");

		imperium_self.addMove("vote\t"+imperium_self.returnActiveAgenda()+"\t"+action+"\t"+"1000");
		imperium_self.endTurn();
		return 0;

	      });
	
	      return 0;
	    } else {
	      return 1;
	    }
	  }
	  return 1;
	}
    });
****/


    this.importActionCard('distinguished-councillor', {
  	name : "Distinguished Coucillor" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his votes, cast an additional 5 votes" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          imperium_self.game.state.votes_cast[action_card_player-1] += 5;
	  imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " casts an additional 5 votes with Distinguished Councillor");

	  return 1;

	}
    });


    this.importActionCard('bribery', {
  	name : "Bribery" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his vote, spend any number of trade goods to purchase the same number of additional voutes" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

	    let html  = '<div class="sf-readable">Spend any number of trade goods to purchase additional votes: </div><ul>';
	    if (imperium_self.game.players_info[action_card_player-1].goods > 0) {
	      html   += '<li class="textchoice" id="0">0 votes</li>';
	      for (let i = 1; i <= imperium_self.game.players_info[action_card_player-1].goods+1; i++) {
	        if (i == 1) { html   += '<li class="textchoice" id="1">'+i+' vote</li>'; }
	        else { html   += '<li class="textchoice" id="'+i+'">'+i+' votes</li>'; }
	      }
	    } else {
	      html   += '<li class="textchoice" id="0">0 votes</li>';
            }
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.textchoice').off();
	    $('.textchoice').on('click', function() {

	      let action = $(this).attr("id");

	      imperium_self.addMove("bribery\t"+action_card_player+"\t"+action);
	      imperium_self.endTurn();
	    });

	  }

	  return 0;

	},
	handleGameLoop : function(imperium_self, qe, mv) {

	  if (mv[0] == "bribery") {

	    let bribing_player = parseInt(mv[1]);
	    let goods_spent = parseInt(mv[2]);
	    imperium_self.game.queue.splice(qe, 1);

	    imperium_self.game.state.votes_cast[bribing_player-1].votes += goods_spent;
	    imperium_self.game.players_info[bribing_player-1].goods -= goods_spent;
	    if (goods_spent == 1) {
	      imperium_self.updateLog(imperium_self.returnFaction(bribing_player) + " bribes the Council for " + goods_spent + " additional vote");
	    } else {
	      imperium_self.updateLog(imperium_self.returnFaction(bribing_player) + " bribes the Council for " + goods_spent + " additional votes");
	    }

	    return 1;
	  }

	  return 1;

	}
    });






    //
    // invisible and unwinnable rider attached to prevent voting
    //
    this.importActionCard('assassinate-representative', {
  	name : "Assassinate Representative" ,
  	type : "pre_agenda" ,
  	text : "Choose a player. That player cannot vote on the Agenda" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectPlayerWithFilter(
              "Select a player who will not be able to vote on this Agenda: " ,
              function(player) {
                if (player != imperium_self.game.player) { return 1; } return 0;
              },
              function(player) {
                imperium_self.addMove("rider\t"+player+"\tassassinate-representative\t-1");
                //imperium_self.addMove("assassinate_representative\t"+imperium_self.game.player+"\t"+player);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " assassinates the voting representative of " + imperium_self.returnFaction(player));
                imperium_self.endTurn();
                return 0;
              },
              null,
            );
	  }
	  return 0;
        },
    });




    this.importActionCard('ancient-burial-sites', {
  	name : "Ancient Burial Sites" ,
  	type : "pre_agenda" ,
  	text : "Chose a player. That player loses a maximum of four votes on this agenda" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectPlayerWithFilter(
              "Select a player to lose 4 votes: " ,
              function(player) {
                if (player != imperium_self.game.player) { return 1; } return 0;
              },
              function(player) {
                imperium_self.addMove("ancient_burial\t"+imperium_self.game.player+"\t"+player);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " finds soe dirt on the voting representative of " + imperium_self.returnFaction(player));
                imperium_self.endTurn();
                return 0;
              },
              null,
            );
	  }
	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "ancient_burial") {

            let player = parseInt(mv[1]);
            let target = parseInt(mv[2]);
            imperium_self.game.queue.splice(qe, 1);

            imperium_self.game.state.votes_available[target-1] -= 4;
            if (imperium_self.game.state.votes_available[target-1] < 0) { 
              imperium_self.game.state.votes_available[target-1] = 0;
            }

            return 1;
          }

	  return 1;
        }

    });







    this.importActionCard('leadership-rider', {
  	name : "Leadership Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to gain two strategy tokens and 1 command token" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
            let msg  = 'On which choice do you wish to place your Leadership rider?';
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"diplomacy-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium.self.game.player)+" has placed a Leadership Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
          imperium_self.game.players_info[action_card_player-1].strategy_tokens += 2;
          imperium_self.game.players_info[action_card_player-1].command_tokens += 1;
	  imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " gains 2 strategy tokens and 1 command token");
	  return 1;
	}
    });






    this.importActionCard('diplomacy-rider', {
  	name : "Diplomacy Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to have others activate system with planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg  = 'On which choice do you wish to place your Diplomacy rider?';
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"diplomacy-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Diplomacy Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {

	  //
	  // rider is executed
	  //
	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectSectorWithFilter(
              "Select a sector with a planet you control to mire in diplomatic conflict: ",
              function(sector) {
		for (let i = 0; i < imperium_self.game.sectors[sector].planets.length; i++) {
  		  if (imperium_self.game.planets[imperium_self.game.sectors[sector].planets[i]].owner == imperium_self.game.player) { return 1; } return 0;
                }
              },
              function(sector) {
                for (let b = 0; b < imperium_self.game.players_info.length; b++) {
                  imperium_self.addMove("activate\t"+(b+1)+"\t"+sector);
                }
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFactionNickname(imperium_self.game.player) + " uses Diplomacy Rider to protect " + sector);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	  }
	  return 0;
	}
    });





    this.importActionCard('politics-rider', {
  	name : "Politics Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to gain three action cards and the speaker token" ,
        playActionCard : function(imperium_self, player, action_card_player, card) {
          if (imperium_self.game.player == action_card_player) {
            let active_agenda = imperium_self.returnActiveAgenda();
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;
            let msg  = 'On which choice do you wish to place your Politics rider?';
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"politics-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Politics Rider on "+choices[choice]);
              imperium_self.endTurn();
            });
          }
          return 0;
        },
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	
	  if (imperium_self.game.player == action_card_player) {

	    // three action cards
            imperium_self.addMove("gain\t"+imperium_self.game.player+"\taction_cards\t3");
            imperium_self.addMove("DEAL\t2\t"+imperium_self.game.player+"\t3");
            imperium_self.addMove("NOTIFY\tdealing two action cards to player "+player);

	    // and change speaker
	    let html = 'Make which player the speaker? <ul>';
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              html += '<li class="textchoice" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
            }
            html += '</ul>';
            imperium_self.updateStatus(html);

            let chancellor = imperium_self.game.player;

            $('.textchoice').off();
            $('.textchoice').on('click', function() {
              let chancellor = (parseInt($(this).attr("id")) + 1);
	      imperium_self.addMove("change_speaker\t"+chancellor);
	      imperium_self.endTurn();
	    });
	  } 

 	  return 0;
	}
    });




    this.importActionCard('construction-rider', {
  	name : "Construction Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to place a space dock on a planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (action_card_player == imperium_self.game.player) {

            let active_agenda = imperium_self.returnActiveAgenda();
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg = 'On which choice do you wish to place the Construction rider?';
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"construction-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Construction Rider on "+choices[choice]);
              imperium_self.endTurn();
            });

	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	  if (action_card_player == imperium_self.game.player) {
            imperium_self.playerSelectPlanetWithFilter(
              "Select a planet you control without a Space Dock: ",
              function(planet) {
  		if (imperium_self.game.planets[planet].owner == imperium_self.game.player && imperium_self.doesPlanetHaveSpaceDock(planet) == 0) { return 1; } return 0;
              },
              function(planet) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t"+imperium_self.game.planets[planet].idx+"\t"+"spacedock"+"\t"+imperium_self.game.planets[planet].sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " builds a Space Dock in " + imperium_self.game.sectors[imperium_self.game.planets[planet].sector].name);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	  }
	  return 0;
	}
    });



    this.importActionCard('trade-rider', {
  	name : "Trade Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to receive 5 trade goods" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();

            let html  = 'On which choice do you wish to place your Trade rider?';
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
	    imperium_self.playerSelectChoice(html, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"trade-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Trade Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
 
 	  return 0;
	},
	playActionCardEvent(imperium_self, player, action_card_player, card) {
	  imperium_self.game.queue.push("purchase\t"+action_card_player+"\t"+"goods"+"\t"+5);
	  imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " gains 5 Trade Goods through their Trade Rider");
	  return 1;
	}
    });




    this.importActionCard('warfare-rider', {
  	name : "Warfare Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to place a dreadnaught in a system with one of your ships: " ,
        playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            let active_agenda = imperium_self.returnActiveAgenda();

            let msg  = 'On which choice do you wish to place your Warfare Rider?';
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"warfare-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Warfare Rider on "+choices[choice]);
              imperium_self.endTurn();
            });
          }

          return 0;
        },
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
              "Select a sector which contains at least one of your ships: ",
              function(sector) {
                return imperium_self.doesSectorContainPlayerShips(action_card_player, sector);
              },
              function(sector) {

                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdreadnaught\t"+sector);
                imperium_self.addMove("NOTIFY\tAdding dreadnaught to board");
                imperium_self.endTurn();
                return 0;

              },
              null
            );
          }
	  return 0;
	}
    });


    this.importActionCard('technology-rider', {
  	name : "Technology Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to research a technology for free" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();

            let msg  = 'On which choice do you wish to place your Technology rider?';
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"technology-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Technology Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
 
 	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    imperium_self.playerResearchTechnology(function(tech) {
	      imperium_self.endTurn();
	    });
	  } 
 	  return 0;
	}
    });


    this.importActionCard('imperial-rider', {
  	name : "Imperial Rider" ,
  	type : "rider" ,
  	text : "Player gains 1 VP" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg = 'On which choice do you wish to place the Imperial rider?';	
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"imperial-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed an Imperial Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });

	  }

	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
          imperium_self.game.players_info[action_card_player-1].vp += 1;
          imperium_self.game.players_info[action_card_player-1].objectives_scored.push("imperial-rider");
	  return 1;
	}
    });







    this.importActionCard('intercept', {
  	name : "Intercept" ,
  	type : "retreat" ,
  	text : "After your opponent declares a retreat in space combat, they cannot retreat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  imperium_self.game.players[action_card_player-1].temporary_opponent_cannot_retreat = 1;
	  return 1;

        }
    });





    this.importActionCard('courageous-to-the-end', {
  	name : "Courageous to the End" ,
  	type : "space_combat_after" ,
  	text : "For one ship lost in last round of space combat, fire twice. With each hit your opponent must destroy a ship of their chosing" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round.length > 0) {

	    let lowest_combat_roll_ship = 10;
	    for (let i = 0; i < imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round[i]; i++) {
	      let unittype = imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round[i];
	      let unit = imperium_self.returnUnit(unittype, player);
	      if (unit.combat < lowest_combat_roll_ship) { lowest_combat_roll_ship = unit.combat; }
	    }

	    let roll1 = imperium_self.rollDice(10);
	    let roll2 = imperium_self.rollDice(10);

	    let counterparty = imperium_self.game.state.space_combat_attacker;
	    if (counterparty == player) { counterparty = imperium_self.game.state.space_combat_defender; }

	    let total_ships_to_destroy = 0;

	    if (roll1 >= lowest_combat_roll_ship) {
	      total_ships_to_destroy++;
	    }
	    if (roll2 >= lowest_combat_roll_ship) {
	      total_ships_to_destroy++;
	    }

	    if (imperium_self.game.player == action_card_player) {
	      imperium_self.addMove("player_destroy_unit"+"\t"+player+"\t"+counterparty+"\t"+total_ships_to_destroy+"\t"+"space"+"\t"+imperium_self.game.state.space_combat_sector+"\t"+0);
	      imperium_self.endTurn();
	    }

	    return 0;

	  }

	  return 1;
        }
    });




    this.importActionCard('salvage', {
  	name : "Salvage" ,
  	type : "space_combat_victory" ,
  	text : "If you win a space combat, opponent gives you all their commodities" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (player == action_card_player) {

  	    let a = imperium_self.game.players_info[imperium_self.game.state.space_combat_attacker];
	    let d = imperium_self.game.players_info[imperium_self.game.state.space_combat_defender];


	    if (d.commodities > 0) {
	      a.goods += d.commodities;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.space_combat_attacker) + " takes " + d.commodities + " in trade goods from commodities lost in combat");
	      d.commodities = 0;
	    }
	  
	    return 1;
	  }
        }
    });



    this.importActionCard('shields-holding1', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding2', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding3', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding4', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });


    this.importActionCard('maneuvering-jets1', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets2', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets3', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets4', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });



    this.importActionCard('emergency-repairs', {
  	name : "Emergency Repairs" ,
  	type : "assign_hits" ,
  	text : "Repair all damaged ships not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // repairs all non-full-strength units for the action_card_player
	  //
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let i = 0; i < sys.s.units[action_card_player-1].length; i++) {
	    if (sys.s.units[action_card_player-1][i].strength < sys.s.units[action_card_player-1][i].max_strength) {
	      sys.s.units[action_card_player-1][i].strength = sys.s.units[action_card_player-1][i].max_strength;
	    }
	  }

	  return 1;

	}

    });

    this.importActionCard('experimental-fighter-prototype', {
  	name : "Experimental Fighter Prototype" ,
  	type : "space_combat" ,
  	text : "Your fighters get +2 on their combat rolls for a single round of space combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units[action_card_player-1].length; p++) {
            let unit = sys.s.units[action_card_player-1][p];
	    if (unit.type == "fighter") {
	      unit.temporary_combat_modifier += 2;
	    }
	  }

	  return 1;

	}

    });

    this.importActionCard('moral-boost', {
  	name : "Moral Boost" ,
  	type : "combat" ,
  	text : "Apply +1 to each of your units' combat rolls during this round of combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.state.space_combat_sector) {
            let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	    for (let i = 0; i < sys.s.units[action_card_player-1].length; i++) {
              let unit = sys.s.units[action_card_player-1][i];
	      unit.temporary_combat_modifier += 1;
	    }
	  }

	  if (imperium_self.game.state.ground_combat_sector) {
	    if (imperium_self.game.state.ground_combat_planet_idx) {
              let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	      for (let p = 0; i < sys.p.length; p++) {
	        for (let i = 0; i < sys.p[p].units[action_card_player-1].length; i++) {
                  let unit = sys.p[p].units[action_card_player-1][i];
	          unit.temporary_combat_modifier += 1;
	        }
	      }
	    }
	  }
	  return 1;
        }
    });



    this.importActionCard('experimental-battlestation', {
  	name : "Experimental Battlestation" ,
  	type : "pre_pds" ,
  	text : "After a player moves ships into a sector, a space dock in that or an adjacent sector can fire 3 PDS shots" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  imperium_self.updateLog("Experimental Battlestation");

	  let sector = imperium_self.game.state.activated_sector;
	  let adjacent_sectors = imperium_self.returnAdjacentSectors(sector);
	  adjacent_sectors.push(sector);

	  let has_experimental_battlestation = 0;

	  for (let n = 0; n < adjacent_sectors.length; n++) {
	    let sys = imperium_self.returnSectorAndPlanets(adjacent_sectors[n]);
	    for (let p = 0; p < sys.p.length; p++) {
	      if (sys.p[p].owner == imperium_self.game.player) {
  	        if (imperium_self.doesPlayerHaveSpaceDock(sys.p[p])) {
		  imperium_self.game.players_info[action_card_player-1].experimental_battlestation = sector;
		  return 1;
		}
	      }
	    }
	  }

	  return 1;
        }
    });










    this.importActionCard('direct-hit1', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit2', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit3', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit4', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });






    this.importActionCard('skilled-retreat1', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "skilled_retreat") {

            let player = parseInt(mv[1]);
            let destination = mv[2];
	    let source = mv[3];
            imperium_self.game.queue.splice(qe, 1);

	    let dsys = imperium_self.returnSectorAndPlanets(destination);
	    let ssys = imperium_self.returnSectorAndPlanets(source);

	    //
	    // move the units over
	    //
	    for (let i = 0; i < ssys.s.units[player-1].length; i++) {
	      dsys.s.units[player-1].push(ssys.s.units[player-1][i]);
	    }
	    ssys.s.units[player-1] = [];

	    imperium_self.saveSystemAndPlanets(dsys);
	    imperium_self.saveSystemAndPlanets(ssys);

	    //
	    // eliminate all commands down to "continue"
	    //
	    for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	      let tmpk = imperium_self.game.queue[i].split("\t");
	      if (tmpk[0] !== "continue") {
		imperium_self.game.queue.splice(i, 1);
	      } else {
		i = -1;
	      }
	    }


	    //
	    // update sector graphics
	    //
	    imperium_self.updateSectorGraphics(ssys.s.sector);
	    imperium_self.updateSectorGraphics(dsys.s.sector);

	    //
	    // handle fleet supply
	    //
	    return imperium_self.handleFleetSupply(player, destination);

          }

          return 1;
        }

    });
    this.importActionCard('skilled-retreat2', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });
    this.importActionCard('skilled-retreat3', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });
    this.importActionCard('skilled-retreat4', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });





    this.importActionCard('public-disgrace', {
  	name : "Public Disgrace" ,
  	type : "activate" ,
  	text : "Force a player who has already picked a strategy card to select another. They select before you do" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  // pick the player

	  // pick the strategy card

	  // insert the card into the strategy_cards list
	  return 0;

	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "public_disgrace") {

            let player = parseInt(mv[1]);
            let target = parseInt(mv[2]);
            let card   = mv[3];
            imperium_self.game.queue.splice(qe, 1);

	    for (let i = 0; i < imperium_self.game.players_info[target-1].strategy.length; i++) {
	      if (imperium_self.game.players_info[target-1].strategy[i] == card) {
		imperium_self.game.players_info[target-1].strategy.splice(i, 1);
	      }
	    }

	    imperium_self.game.queue.push("pickstrategy\t"+player);
	    imperium_self.game.queue.push("reinsert_strategy_card\t"+card);
	    imperium_self.game.queue.push("pickstrategy\t"+target);

	    return 1;

          }

	  if (mv[0] == "reinsert_strategy_card") {

	    let card = mv[1];

            imperium_self.game.state.strategy_cards.push(card);
            imperium_self.game.state.strategy_cards_bonus.push(0);

	    return 1;

	  }
    

          return 1;
        }

    });




returnPlayers(num = 0) {

  var players = [];

  let factions = JSON.parse(JSON.stringify(this.returnFactions()));

  for (let i = 0; i < num; i++) {

    if (i == 0) { col = "color1"; }
    if (i == 1) { col = "color2"; }
    if (i == 2) { col = "color3"; }
    if (i == 3) { col = "color4"; }
    if (i == 4) { col = "color5"; }
    if (i == 5) { col = "color6"; }

    var keys = Object.keys(factions);
    let rf = keys[this.rollDice(keys.length) - 1];

    if (i == 0) {
      if (this.game.options.player1 != undefined) {
        if (this.game.options.player1 != "random") {
          rf = this.game.options.player1;
        }
      }
    }
    if (i == 1) {
      if (this.game.options.player2 != undefined) {
        if (this.game.options.player2 != "random") {
          rf = this.game.options.player2;
        }
      }
    }
    if (i == 2) {
      if (this.game.options.player3 != undefined) {
        if (this.game.options.player3 != "random") {
          rf = this.game.options.player3;
        }
      }
    }
    if (i == 3) {
      if (this.game.options.player4 != undefined) {
        if (this.game.options.player4 != "random") {
          rf = this.game.options.player4;
        }
      }
    }
    if (i == 4) {
      if (this.game.options.player5 != undefined) {
        if (this.game.options.player5 != "random") {
          rf = this.game.options.player5;
        }
      }
    }
    if (i == 5) {
      if (this.game.options.player6 != undefined) {
        if (this.game.options.player6 != "random") {
          rf = this.game.options.player6;
        }
      }
    }

    delete factions[rf];


    players[i] = {};
    players[i].can_intervene_in_action_card = 0;
    players[i].secret_objectives_in_hand = 0;
    players[i].action_cards_in_hand = 0;
    players[i].action_cards_per_round = 1;
    players[i].action_card_limit = 7;
    players[i].action_cards_played = [];
    players[i].new_tokens_per_round = 2;
    players[i].command_tokens = 3;
    players[i].strategy_tokens = 2;
    players[i].fleet_supply = 3;
    players[i].fleet_supply_limit = 16;
    players[i].faction = rf;
    players[i].homeworld = "";
    players[i].color = col;
    players[i].goods = 0;
    players[i].commodities = 0;
    players[i].commodity_limit = 3;
    players[i].vp = 0;
    players[i].passed = 0;
    players[i].strategy_cards_played = [];
    players[i].strategy_cards_retained = [];
    players[i].cost_of_technology_primary = 6;
    players[i].cost_of_technology_secondary = 4;
    players[i].promissary_notes = [];

    //
    // unit limits
    //
    players[i].infantry_limit = 30;
    players[i].fighter_limit = 30;
    players[i].carrier_limit = 4;
    players[i].destroyer_limit = 8;
    players[i].cruiser_limit = 8;
    players[i].dreadnaught_limit = 5;
    players[i].flagship_limit = 1;
    players[i].warsun_limit = 2;
    players[i].pds_limit = 4;
    players[i].spacedock_limit = 3;


    players[i].traded_this_turn = 0;


    //
    // gameplay modifiers (action cards + tech)
    //
    players[i].new_token_bonus_when_issued = 0;
    players[i].action_cards_bonus_when_issued = 0;
    players[i].new_tokens_bonus_when_issued = 0;
    players[i].fleet_move_bonus = 0;
    players[i].temporary_fleet_move_bonus = 0;
    players[i].ship_move_bonus = 0;
    players[i].temporary_ship_move_bonus = 0;
    players[i].fly_through_asteroids = 0;
    players[i].fly_through_nebulas = 0;
    players[i].fly_through_supernovas = 0;
    players[i].move_into_supernovas = 0;
    players[i].reinforce_infantry_after_successful_ground_combat = 0;
    players[i].bacterial_weapon = 0;
    players[i].evasive_bonus_on_pds_shots = 0;
    players[i].perform_two_actions = 0;
    players[i].move_through_sectors_with_opponent_ships = 0;
    players[i].temporary_move_through_sectors_with_opponent_ships = 0;
    players[i].assign_pds_hits_to_non_fighters = 0;
    players[i].reallocate_four_infantry_per_round = 0;
    players[i].may_produce_after_gaining_planet = 0;
    players[i].extra_roll_on_bombardment_or_pds = 0;
    players[i].stasis_on_opponent_combat_first_round = 0;
    players[i].may_repair_damaged_ships_after_space_combat = 0;
    players[i].may_assign_first_round_combat_shot = 0;
    players[i].production_bonus = 0;
    players[i].may_player_produce_without_spacedock = 0;
    players[i].may_player_produce_without_spacedock_production_limit = 0;
    players[i].may_player_produce_without_spacedock_cost_limit = 0;
    players[i].may_produce_warsuns = 0;

    //
    // must target certain units when assigning hits, if possible
    //
    players[i].target_units = [];
    players[i].planets_conquered_this_turn = [];
    players[i].objectives_scored_this_round = [];
    players[i].must_exhaust_at_round_start = [];


    //
    // faction-inspired gameplay modifiers 
    //
    players[i].deep_space_conduits = 0; // treat all systems adjacent to activated system
    players[i].resupply_stations = 0; // gain trade goods on system activation if contains ships 
    players[i].turn_nullification = 0; // after player activates system with ships, can end turn ...

    //
    // roll modifiers
    //
    players[i].space_combat_roll_modifier = 0;
    players[i].ground_combat_roll_modifier = 0;
    players[i].pds_combat_roll_modifier = 0;
    players[i].bombardment_combat_roll_modifier = 0;
    players[i].space_combat_roll_bonus_shots = 0;
    players[i].ground_combat_roll_bonus_shots = 0;
    players[i].pds_combat_roll_bonus_shots = 0;
    players[i].bombardment_combat_roll_bonus_shots = 0;

    players[i].ground_combat_dice_reroll = 0;
    players[i].space_combat_dice_reroll = 0;
    players[i].pds_combat_dice_reroll = 0;
    players[i].bombardment_combat_dice_reroll = 0;
    players[i].combat_dice_reroll = 0;

    players[i].temporary_immune_to_pds_fire = 0;
    players[i].temporary_immune_to_planetary_defense = 0;

    players[i].temporary_space_combat_roll_modifier = 0;
    players[i].temporary_ground_combat_roll_modifier = 0;
    players[i].temporary_pds_combat_roll_modifier = 0;
    players[i].temporary_bombardment_combat_roll_modifier = 0;

    players[i].units_i_destroyed_this_combat_round = [];
    players[i].units_i_destroyed_last_combat_round = [];
    players[i].my_units_destroyed_this_combat_round = [];
    players[i].my_units_destroyed_last_combat_round = [];

    //
    // tech upgrades
    //
    players[i].temporary_green_tech_prerequisite = 0;
    players[i].temporary_yellow_tech_prerequisite = 0;
    players[i].temporary_red_tech_prerequisite = 0;
    players[i].temporary_blue_tech_prerequisite = 0;
    players[i].permanent_green_tech_prerequisite = 0;
    players[i].permanent_yellow_tech_prerequisite = 0;
    players[i].permanent_red_tech_prerequisite = 0;
    players[i].permanent_blue_tech_prerequisite = 0;
    players[i].temporary_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 0;
    players[i].permanent_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 0;
    players[i].temporary_infiltrate_infrastructure_on_invasion = 0;
    players[i].permanent_infiltrate_infrastructure_on_invasion = 0;
    players[i].temporary_opponent_cannot_retreat = 0;
    players[i].permanent_opponent_cannot_retreat = 0;
    players[i].permanent_research_technology_card_must_not_spend_resources = 0;

    if (i == 1) { players[i].color = "yellow"; }
    if (i == 2) { players[i].color = "green"; }
    if (i == 3) { players[i].color = "blue"; }
    if (i == 4) { players[i].color = "purple"; }
    if (i == 5) { players[i].color = "black"; }

    players[i].planets = [];
    players[i].tech = [];
    players[i].tech_exhausted_this_turn = [];
    players[i].upgrades = [];
    players[i].strategy = [];        // strategy cards  

    // scored objectives
    players[i].objectives_scored = [];


    // random
    players[i].lost_planet_this_round = -1; // is player to whom lost

  }

  return players;

}








playerTurn(stage = "main") {

  let html = '';
  let imperium_self = this;
  let technologies = this.returnTechnology();
  let relevant_action_cards = ["action", "main", "instant"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  this.updateLeaderboard();
  this.updateTokenDisplay();

  if (stage == "main") {

    let playercol = "player_color_" + this.game.player;

    let html = '';
    html += '<div class="terminal_header2 sf-readable"><div class="player_color_box ' + playercol + '"></div>' + this.returnFaction(this.game.player) + ":</div><p><ul class='terminal_header3'>";

    if (this.canPlayerPass(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 1) {
        //
        // if we have already moved, we end turn rather than pass
        //
        html += '<li class="option" id="endturn">end turn</li>';
      } else {
        //
        // otherwise we pass
        //
        html += '<li class="option" id="pass">pass</li>';
      }
    } else {
      if (this.game.state.active_player_moved == 1) {
        //
        // if we have already moved, we end turn rather than pass
        //
        html += '<li class="option" id="endturn">end turn</li>';
      }
    }

    if (this.game.state.round == 1 && this.game.state.active_player_moved == 0) {
      if (this.tutorial_move_clicked == 0) {
        html += '<li class="option" id="tutorial_move_ships">move ships</li>';
      }
      if (this.tutorial_produce_clicked == 0) {
        html += '<li class="option" id="tutorial_produce_units">produce units</li>';
      }
    }

    if (this.game.players_info[this.game.player - 1].command_tokens > 0) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="activate">activate sector</li>';
      }
    }
    if (this.canPlayerPlayStrategyCard(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="select_strategy_card">play strategy card</li>';
      }
    }
    if (ac.length > 0 && this.game.tracker.action_card == 0 && this.canPlayerPlayActionCard(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="action">play action card</li>';
      }
    }
    if (this.game.tracker.trade == 0 && this.canPlayerTrade(this.game.player) == 1) {
      html += '<li class="option" id="trade">trade</li>';
    }

    //
    // add tech and factional abilities
    //
    let tech_attach_menu_events = 0;
    let tech_attach_menu_triggers = [];
    let tech_attach_menu_index = [];
    let z = this.returnEventObjects();

    if (this.game.state.active_player_moved == 0) {
      for (let i = 0; i < z.length; i++) {
        if (z[i].menuOptionTriggers(this, "main", this.game.player) == 1) {
          let x = z[i].menuOption(this, "main", this.game.player);
          html += x.html;
          tech_attach_menu_index.push(i);
          tech_attach_menu_triggers.push(x.event);
          tech_attach_menu_events = 1;
        }
      }
    }



    html += '</ul></p>';

    this.updateStatus(html);

    $('.option').on('click', function () {

      let action2 = $(this).attr("id");

      //
      // respond to tech and factional abilities
      //
      if (tech_attach_menu_events == 1) {
        for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
          if (action2 == tech_attach_menu_triggers[i]) {
            $(this).remove();
            imperium_self.game.state.active_player_moved = 1;
            z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "main", imperium_self.game.player);
            return;
          }
        }
      }

      if (action2 == "activate") {
        imperium_self.playerActivateSystem();
      }

      if (action2 == "tutorial_move_ships") {
        imperium_self.tutorial_move_clicked = 1;
        imperium_self.playerAcknowledgeNotice("To move ships select \"activate sector\". Be careful as most ships can only move 1-hexagon and you cannot move ships from sectors that are already activated. You will be able to choose the ships to move, and load infantry and fighters into units that can carry them.", function () {
          imperium_self.playerTurn();
        });
        return;
      }
      if (action2 == "tutorial_produce_units") {
        imperium_self.tutorial_produce_clicked = 1;
        imperium_self.playerAcknowledgeNotice("To produce units, select \"activate sector\" and activate a sector with a space dock (like your home system). You can only have as many non-fighter ships in any sector as your fleet supply, so move your ships out before producing more!", function () {
          imperium_self.playerTurn();
        });
        return;
      }

      if (action2 == "select_strategy_card") {
        imperium_self.playerSelectStrategyCard(function (success) {
          imperium_self.game.state.active_player_moved = 1;
          imperium_self.addMove("strategy_card_after\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.addMove("strategy\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.addMove("strategy_card_before\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.endTurn();
        });
      }
      if (action2 == "action") {
        imperium_self.playerSelectActionCard(function (card) {
          if (imperium_self.action_cards[card].type == "action") { imperium_self.game.state.active_player_moved = 1; }
          imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
          imperium_self.endTurn();
        }, function () { imperium_self.playerTurn(); },
          relevant_action_cards);
      }
      if (action2 == "trade") {
        imperium_self.playerTrade();
        return 0;
      }
      if (action2 == "pass") {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
        imperium_self.addMove("pass\t" + imperium_self.game.player);
        imperium_self.endTurn();
      }
      if (action2 == "endturn") {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
        imperium_self.endTurn();
      }
    });
  }
}




playerPlayActionCardMenu(action_card_player, card, action_cards_played = []) {

  let imperium_self = this;
  let relevant_action_cards = ["counter"];

  for (let i = 0; i < this.game.deck[1].hand.length; i++) {
    if (this.game.deck[1].hand[i].indexOf("sabotage") > -1) {
      this.game.players_info[this.game.player - 1].can_intervene_in_action_card = 1;
    }
  }

  if (this.game.players_info[this.game.player - 1].can_intervene_in_action_card) {

    let html = '<div class="action_card_instructions_hud">' + this.returnFaction(action_card_player) + ' has played an action card:</div>';
    html += '<div class="action_card_name_hud">' + imperium_self.action_cards[card].name + '</div>';
    html += '<div class="action_card_text_hud">';
    html += this.action_cards[card].text;
    html += '</div>';
    html += '<ul>';

    let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);
    if (ac.length > 0) {
      html += '<li class="option" id="cont">continue</li>';
      html += '<li class="option" id="action">play action card</li>';
    } else {
      html += '<li class="option" id="cont">continue</li>';
    }

    let tech_attach_menu_events = 0;
    let tech_attach_menu_triggers = [];
    let tech_attach_menu_index = [];

    let z = this.returnEventObjects();
    for (let i = 0; i < z.length; i++) {
      if (z[i].menuOptionTriggers(this, "action_card", this.game.player) == 1) {
        let x = z[i].menuOption(this, "action_card", this.game.player);
        html += x.html;
        tech_attach_menu_index.push(i);
        tech_attach_menu_triggers.push(x.event);
        tech_attach_menu_events = 1;
      }
    }
    html += '</ul>';

    this.updateStatus(html);

    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");

      //
      // respond to tech and factional abilities
      //
      if (tech_attach_menu_events == 1) {
        for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
          if (action2 == tech_attach_menu_triggers[i]) {
            $(this).remove();
            z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "action_card", imperium_self.game.player);
          }
        }
      }

      if (action2 == "action") {
        imperium_self.playerSelectActionCard(function (card) {
          imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(card);
          imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
          imperium_self.playerPlayActionCardMenu(action_card_player, card);
        }, function () {
          imperium_self.playerPlayActionCardMenu(action_card_player, card);
        }, relevant_action_cards);
      }

      if (action2 == "cont") {
        imperium_self.endTurn();
      }
      return 0;
    });

  } else {

    let notice = '<div class="action_card_instructions_hud">' + this.returnFaction(action_card_player) + ' has played an action card:</div>';
    notice += '<div class="action_card_name_hud">' + imperium_self.action_cards[card].name + '</div>';
    notice += '<div class="action_card_text_hud">';
    notice += this.action_cards[card].text;
    notice += '</div>';

    this.playerAcknowledgeNotice(notice, function () { imperium_self.endTurn(); });
    return 0;
  }

}





playerPlayBombardment(attacker, sector, planet_idx) {

  let imperium_self = this;

  this.game.state.bombardment_sector = sector;
  this.game.state.bombardment_planet_idx = planet_idx;

  let sys = imperium_self.returnSectorAndPlanets(sector);


  //
  // some laws prohibit bombardment against
  //
  if (this.game.state.bombardment_against_cultural_planets == 0 && sys.p[planet_idx].type == "cultural") {
    this.updateLog("Bombardment not possible against cultural planets. Skipping.");
    this.endTurn();
  }
  if (this.game.state.bombardment_against_industrial_planets == 0 && sys.p[planet_idx].type == "industrial") {
    this.updateLog("Bombardment not possible against industrial planets. Skipping.");
    this.endTurn();
  }
  if (this.game.state.bombardment_against_hazardous_planets == 0 && sys.p[planet_idx].type == "hazardous") {
    this.updateLog("Bombardment not possible against hazardous planets. Skipping.");
    this.endTurn();
  }
  //
  // no bombardment of my own planets (i.e. if parlay ends invasion)
  //
  if (sys.p[planet_idx].owner == imperium_self.game.player) {
    imperium_self.endTurn();
    return 0;
  }
  //
  // no bombardment of PDS-defended territories
  //
  if (this.doesPlanetHavePDS(sys.p[planet_idx])) {
    this.updateLog("Bombardment not possible against PDS-defended planets. Skipping.");
    imperium_self.endTurn();
    return 0;
  }

  html = '<div class="sf-readable">Do you wish to bombard ' + sys.p[planet_idx].name + '? </div><ul>';

  let ac = this.returnPlayerActionCards(this.game.player, ["pre_bombardment"]);
  if (ac.length > 0) {
    html += '<li class="option" id="bombard">bombard planet</li>';
    html += '<li class="option" id="action">play action card</li>';
    html += '<li class="option" id="skip">skip bombardment</li>';
  } else {
    html += '<li class="option" id="bombard">bombard planet</li>';
    html += '<li class="option" id="skip">skip bombardment</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pre_bombardment", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pre_bombardment", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pre_bombardment", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.game.players_info[this.game.player - 1].action_cards_played.push(card);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, function () {
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, ["pre_bombardment"]);
    }

    if (action2 == "bombard") {
      imperium_self.addMove("bombard\t" + imperium_self.game.player + "\t" + sector + "\t" + planet_idx);
      imperium_self.endTurn();
    }
    if (action2 == "skip") {
      imperium_self.endTurn();
    }
    return 0;
  });


}


playerAcknowledgeNotice(msg, mycallback) {

  let html = '<div class="sf-readable">' + msg + "</div><ul>";
  html += '<li class="textchoice" id="confirmit">I understand...</li>';
  html += '</ul></p>';

  this.updateStatus(html);

  try {
  $('.textchoice').off();
  $('.textchoice').on('click', function () { mycallback(); });
  } catch (err) {}

  return 0;

}

//
// assign hits to capital ships without triggering events or special abilities
//  -- this is used by special abilities that assign damage outside combat, where they
//  -- cannot be removed by normal factional abilities, etc.
//
 playerAssignHitsCapitalShips(player, sector, total_hits) {

  let imperium_self = this;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let total_targetted_units = 0;

  let targetted_units = ["destroyer","cruiser","carrier","dreadnaught","warsun","flagship"];

  html = '<div class="sf-readable">You must assign ' + total_hits + ' to your capital ships (if possible):</div><ul>';
  html += '<li class="option" id="assign">continue</li>';
  html += '</ul>';
  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "assign") {

      let sys = imperium_self.returnSectorAndPlanets(sector);

      let html = '';
      html += '<div class="sf-readable">Assign <div style="display:inline" id="total_hits_to_assign">' + total_hits + '</div> hits:</div>';
      html += '<ul>';

      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].destroyed == 0 && sys.s.units[imperium_self.game.player - 1][i].strength > 0) {

          let unit = sys.s.units[imperium_self.game.player - 1][i];
          maximum_assignable_hits++;
          if (targetted_units.includes(unit.type)) { total_targetted_units++; }
          html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name;
          if (unit.capacity >= 1) {
	    let fleet = '';
            let fighters = 0;
            let infantry = 0;
            for (let ii = 0; ii < sys.s.units[imperium_self.game.player-1][i].storage.length; ii++) {
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "infantry") {
                infantry++;
              }
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
                fighters++;
              }
            }
            if (infantry > 0 || fighters > 0) {
              fleet += ' ';
              if (infantry > 0) { fleet += infantry + "i"; }
              if (fighters > 0) {
                if (infantry > 0) { fleet += ", "; }
                fleet += fighters + "f";
              }
              fleet += ' ';
            }
	    html += fleet;
	  }
          if (unit.strength > 1) {
            maximum_assignable_hits += (unit.strength - 1);
            html += ' <div style="display:inline" id="player_ship_' + i + '_hits">(';
            for (let bb = 1; bb < unit.strength; bb++) { html += '*'; }
            html += ')';
	    html += '</div>'
          }
          html += '</li>';
        }

      }
      html += '</ul>';

      if (maximum_assignable_hits == 0) {
        imperium_self.endTurn();
        return 0;
      }

      imperium_self.updateStatus(html);

      $('.textchoice').off();
      $('.textchoice').on('click', function () {

        let ship_idx = $(this).attr("id");
        let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

        if (total_targetted_units > 0) {
          if (!targetted_units.includes(selected_unit.type)) {
            salert("You must first assign hits to the required unit types");
            return;
          } else {
            total_targetted_units--;
          }
        }

        imperium_self.addMove("assign_hit\t" + player + "\t" + player + "\t" + imperium_self.game.player + "\tship\t" + sector + "\t" + ship_idx + "\t0"); // last argument --> player should not assign again 


        total_hits--;
        hits_assigned++;

        $('#total_hits_to_assign').innerHTML = total_hits;

        if (selected_unit.strength > 1) {
          selected_unit.strength--;
          let ship_to_reduce = "#player_ship_" + ship_idx + '_hits';
          let rhtml = '';
          if (selected_unit.strength > 1) {
            html += '(';
            for (let bb = 1; bb < selected_unit.strength; bb++) {
              rhtml += '*';
            }
            rhtml += ')';
          }
          $(ship_to_reduce).html(rhtml);
        } else {
          selected_unit.strength = 0;
          selected_unit.destroyed = 0;
          $(this).remove();
        }

        //
        // we have assigned damage, so make sure sys is updated
        //
        imperium_self.saveSystemAndPlanets(sys);

        if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
          imperium_self.updateStatus("Notifying players of hits assignment...");
          imperium_self.endTurn();
          imperium_self.updateStatus("Hits taken...");
        }

      });
    }

  });

}



//
// assign hits to my forces
//
 playerAssignHits(attacker, defender, type, sector, details, total_hits, source = "") {

  let imperium_self = this;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let relevant_action_cards = ["assign_hits"];
  if (details == "pds") { relevant_action_cards = ["post_pds"]; }

  html = '<div class="sf-readable">You must assign ' + total_hits + ' to your fleet:</div><ul>';

  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);
  if (ac.length > 0) {
    html += '<li class="option" id="assign">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="assign">continue</li>';
  }

  let menu_type = "";
  if (details == "pds") { menu_type = "assign_hits_pds"; }
  if (menu_type == "" && type == "space") { menu_type = "assign_hits_space"; }
  if (type == "ground") { menu_type = "assign_hits_ground"; }
  if (type == "anti_fighter_barrage") { menu_type = "assign_hits_anti_fighter_barrage"; }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, menu_type, this.game.player) == 1) {
      let x = z[i].menuOption(this, menu_type, this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          let mytech = this.tech[imperium_self.game.players_info[imperium_self.game.player - 1].tech[tech_attach_menu_index]];
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, menu_type, imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove(imperium_self.game.state.assign_hits_queue_instruction);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
        imperium_self.updateStatus("playing action card before hits assignment");
      }, function () {
        imperium_self.playerAssignHits(attacker, defender, type, sector, details, total_hits, source);
      }, relevant_action_cards);
    }

    if (action2 == "assign") {

      if (imperium_self.game.state.assign_hits_to_cancel > 0) {
        total_hits -= imperium_self.game.state.assign_hits_to_cancel;
        if (total_hits < 0) { total_hits = 0; }
        if (total_hits == 0) {
          imperium_self.updateLog("NOTIFY\t" + imperium_self.returnFactionNickname(imperium_self.game.player) + " does not take any hits");
          imperium_self.endTurn();
          return 0;
        }
      }

      let sys = imperium_self.returnSectorAndPlanets(sector);

      let html = '';
      html += '<div class="sf-readable">Assign <div style="display:inline" id="total_hits_to_assign">' + total_hits + '</div> hits:</div>';
      html += '<ul>';

      let total_targetted_units = 0;
      let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;
      if (type == "anti_fighter_barrage") {
	//
	// overwrite
	//
	targetted_units = [	"fighter", "fighter", "fighter" , "fighter" , "fighter" , 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter" ];
      }

      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].destroyed == 0 && sys.s.units[imperium_self.game.player - 1][i].strength > 0) {

          let unit = sys.s.units[imperium_self.game.player - 1][i];
          maximum_assignable_hits++;
          if (targetted_units.includes(unit.type)) { total_targetted_units++; }
          html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name;
          if (unit.capacity >= 1) {
	    let fleet = '';
            let fighters = 0;
            let infantry = 0;
            for (let ii = 0; ii < sys.s.units[imperium_self.game.player-1][i].storage.length; ii++) {
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "infantry") {
                infantry++;
              }
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
                fighters++;
              }
            }
            if (infantry > 0 || fighters > 0) {
              fleet += ' ';
              if (infantry > 0) { fleet += infantry + "i"; }
              if (fighters > 0) {
                if (infantry > 0) { fleet += ", "; }
                fleet += fighters + "f";
              }
              fleet += ' ';
            }
	    html += fleet;
	  }
          if (unit.strength > 1) {
            maximum_assignable_hits += (unit.strength - 1);
            html += ' <div style="display:inline" id="player_ship_' + i + '_hits">(';
            for (let bb = 1; bb < unit.strength; bb++) { html += '*'; }
            html += ')';
	    html += '</div>'
          }
          html += '</li>';
        }

      }
      html += '</ul>';

      if (maximum_assignable_hits == 0) {
        console.log("ERROR: you had no hits left to assign, bug?");
        console.log("SHIPS: " + JSON.stringify(sys.s.units[imperium_self.game.player - 1]));
//        imperium_self.eliminateDestroyedUnitsInSector(imperium_self.game.player, sector);
//        imperium_self.saveSystemAndPlanets(sys);
//        imperium_self.updateSectorGraphics(sector);
        imperium_self.endTurn();
        return 0;
      }

      imperium_self.updateStatus(html);

      $('.textchoice').off();
      $('.textchoice').on('click', function () {

        let ship_idx = $(this).attr("id");
        let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

        if (total_targetted_units > 0) {
          if (!targetted_units.includes(selected_unit.type)) {
            salert("You must first assign hits to the required unit types");
            return;
          } else {
            total_targetted_units--;
          }
        }

        imperium_self.addMove("assign_hit\t" + attacker + "\t" + defender + "\t" + imperium_self.game.player + "\tship\t" + sector + "\t" + ship_idx + "\t0"); // last argument --> player should not assign again 

        total_hits--;
        hits_assigned++;

        $('#total_hits_to_assign').innerHTML = total_hits;

        if (selected_unit.strength > 1) {
          selected_unit.strength--;
          let ship_to_reduce = "#player_ship_" + ship_idx + '_hits';
          let rhtml = '';
          if (selected_unit.strength > 1) {
            html += '(';
            for (let bb = 1; bb < selected_unit.strength; bb++) {
              rhtml += '*';
            }
            rhtml += ')';
          }
          $(ship_to_reduce).html(rhtml);
        } else {
          selected_unit.strength = 0;
          selected_unit.destroyed = 0;
          $(this).remove();
        }

        //
        // we have assigned damage, so make sure sys is updated
        //
        imperium_self.saveSystemAndPlanets(sys);

        if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
          imperium_self.updateStatus("Notifying players of hits assignment...");
          imperium_self.endTurn();
          imperium_self.updateStatus("Hits taken...");
        }

      });
    }

  });
}





//
// destroy units
//
playerDestroyUnits(player, total, sector, capital = 0) {

  let imperium_self = this;
  let total_hits = total;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  html = '<div class="sf-readable">You must destroy ' + total + ' units in sector: ' + imperium_self.game.sectors[sector].name + ':</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
    let unit = sys.s.units[imperium_self.game.player - 1][i];
    maximum_assignable_hits++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  for (let p = 0; i < sys.p.length; p++) {
    for (let i = 0; i < sys.p[p].units[imperium_self.game.player - 1].length; i++) {
      let unit = sys.p[p].units[imperium_self.game.player - 1][i];
      maximum_assignable_hits++;
      if (targetted_units.includes(unit.type)) { total_targetted_units++; }
      html += '<li class="textchoice player_unit_' + p + '_' + i + '" id="ground_unit_' + p + '_' + i + '">' + unit.name + '</li>';
    }
  }
  html += '</ul>';

  if (maximum_assignable_hits == 0) {
    this.addMove("NOTIFY\t" + this.returnFaction(player) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }


  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {


    let ship_idx = $(this).attr("id");
    let planet_idx = 0;
    let unit_idx = 0;
    let unit_type = "ship";

    if (ship_idx.indexOf("_unit_") > 0) {
      unit_type = "ground";
      let tmpk = ship_idx.split("_");
      planet_idx = tmpk[1];
      unit_idx = tmpk[2];

    }

    let selected_unit = null;
    if (unit_type == "ship") {
      selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];
    } else {
      selected_unit = sys.p[planet_idx].units[imperium_self.game.player - 1][unit_idx];
    }

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    if (unit_type == "ship") {
      imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");
    } else {
      imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "ground\t" + sector + "\t" + planet_idx + "\t" + unit_idx + "\t1");
    }

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total_hits--;
    hits_assigned++;

    if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
      imperium_self.updateStatus("Notifying players of units destroyed...");
      imperium_self.endTurn();
    }

  });
}





//
// destroy ships
//
playerDestroyShips(player, total, sector, capital = 0) {

  let imperium_self = this;
  let total_hits = total;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  html = '<div class="sf-readable">You must destroy ' + total + ' ships in your fleet:</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
    let unit = sys.s.units[imperium_self.game.player - 1][i];
    maximum_assignable_hits++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  html += '</ul>';

  if (maximum_assignable_hits == 0) {
    this.addMove("NOTIFY\t" + this.returnFaction(player) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }


  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let ship_idx = $(this).attr("id");
    let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total_hits--;
    hits_assigned++;

    if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
      imperium_self.updateStatus("Notifying players of hits assignment...");
      imperium_self.endTurn();
    }

  });
}


//
// destroy opponent ships (not assigning hits)
//
playerDestroyOpponentShips(player, total, sector, capital = 0) {

  let imperium_self = this;
  let ships_destroyed = 0;
  let maximum_destroyable_ships = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  let opponent = imperium_self.returnOpponentInSector(player, sector);

  if (opponent == -1) {
    this.addMove("NOTIFY\t" + this.returnFactionNickname(opponent) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }

  html = '<div class="sf-readable">You may destroy ' + total + ' ships in opponent fleet:</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[opponent-1].length; i++) {
    let unit = sys.s.units[opponent-1][i];
    maximum_destroyable_ships++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  html += '</ul>';

  if (maximum_destroyable_ships == 0) {
    this.addMove("NOTIFY\t" + this.returnFactionNickname(opponent) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }

  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

   let ship_idx = $(this).attr("id");
    let selected_unit = sys.s.units[opponent - 1][ship_idx];

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    imperium_self.addMove("destroy_unit\t" + player + "\t" + opponent + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total--;
    ships_destroyed++;

    if (total == 0 || ships_destroyed >= maximum_destroyable_ships) {
      imperium_self.updateStatus("Notifying players of destroyed ships...");
      imperium_self.endTurn();
    }

  });
}








//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlaySpaceCombat(attacker, defender, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let html = '';
  let relevant_action_cards = ["space_combat"];
  if (this.game.state.space_combat_round > 1) {
    relevant_action_cards.push("space_combat_post");
  }

  let opponent = attacker;
  if (imperium_self.game.player == attacker) { opponent = defender; }

  this.game.state.space_combat_sector = sector;

  html = '<div class="sf-readable"><b>Space Combat: round ' + this.game.state.space_combat_round + ':</b><div class="combat_attacker">' + this.returnFaction(attacker) + '</div><div class="combat_attacker_fleet">' + this.returnPlayerFleetInSector(attacker, sector) + '</div><div class="combat_defender">' + this.returnFaction(defender) + '</div><div class="combat_defender_fleet">' + this.returnPlayerFleetInSector(defender, sector) + '</div><ul>';

  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards)
  if (ac.length > 0) {
    html += '<li class="option" id="attack">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="attack">continue</li>';
  }

  //
  // can I retreat
  //
  if (this.canPlayerRetreat(imperium_self.game.player, attacker, defender, sector)) {
    html += '<li class="option" id="retreat">announce retreat</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "space_combat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "space_combat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }, function () {
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }, relevant_action_cards);
    }

    if (action2 == "attack") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.prependMove("ships_fire\t" + attacker + "\t" + defender + "\t" + sector);
      imperium_self.endTurn();
    }

    if (action2 == "retreat") {
      if (imperium_self.canPlayerRetreat(imperium_self.game.player, attacker, defender, sector)) {
        let retreat_options = imperium_self.returnSectorsWherePlayerCanRetreat(imperium_self.game.player, sector);

        let html = '<div clss="sf-readable">Retreat into which Sector? </div><ul>';
        for (let i = 0; i < retreat_options.length; i++) {
	  let sys = imperium_self.returnSectorAndPlanets(retreat_options[i]);
          html += '<li class="option" id="' + i + '">' + sys.s.name + '</li>';
        }
        html += '</ul>';

        imperium_self.updateStatus(html);

        $('.option').off();
        $('.option').on('click', function () {

          let opt = $(this).attr("id");
          let retreat_to_sector = retreat_options[opt];

          imperium_self.addMove("announce_retreat\t" + imperium_self.game.player + "\t" + opponent + "\t" + sector + "\t" + retreat_to_sector);
          imperium_self.endTurn();
          return 0;
        });


      } else {
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }
    }

  });
}




playerRespondToRetreat(player, opponent, from, to) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(to);
  let relevant_action_cards = ["retreat"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);

  let html = '<div class="sf-readable">Your opponent has announced a retreat into ' + sys.s.name + ' at the end of this round of combat: </div><p></p><ul>';
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  html += '<li class="option" id="permit">permit retreat</li>';
  html += '</ul>';

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "retreat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "retreat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';


  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerRespondToRetreat(player, opponent, from, to);
      }, function () {
        imperium_self.playerRespondToRetreat(player, opponent, from, to);
      }.relevant_action_cards);
    }


    if (action2 == "permit") {
      imperium_self.endTurn();
    }
  });
}






//
// ground combat is over -- provide options for scoring cards, action cards
//
playerPlayGroundCombatOver(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let relevant_action_cards = ["ground_combat_victory", "ground_combat_over", "ground_combat_loss"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);

  let html = '';
  let win = 0;

  if (player == sys.p[planet_idx].owner) {
    html = '<div class="sf-readable">Ground Combat is Over (you win): </div><ul>';
    win = 1;
  } else {
    html = '<div class="sf-readable">Space Combat is Over (you lose): </div><ul>';
  }

  if (ac.length > 0) {
    html += '<li class="option" id="ok">acknowledge</li>';
    html += '<li class="option" id="action">action card</li>';
  } else {
    html += '<li class="option" id="ok">acknowledge</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "ground_combat_over", this.game.player) == 1) {
      let x = z[i].menuOption(this, "ground_combat_over", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 === "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayGroundCombatOver(player, sector, planet_idx);
      }, function () {
        imperium_self.playerPlayGroundCombatOver(player, sector, planet_idx);
      });
    }

    if (action2 === "ok") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.endTurn();
    }

  });
}




//
// space combat is over -- provide options for scoring cards, action cards
//
playerPlaySpaceCombatOver(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let relevant_action_cards = ["space_combat_victory", "space_combat_over", "space_combat_loss"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);
  let html = '';
  let win = 0;

  if (this.doesPlayerHaveShipsInSector(player, sector)) {
    html = '<div class="sf-readable">Space Combat is Over (you win): </div><ul>';
    win = 1;
  } else {
    html = '<div class="sf-readable">Space Combat is Over (you lose): </div><ul>';
  }

  if (ac.length > 0) {
    html += '<li class="option" id="ok">acknowledge</li>';
    html += '<li class="option" id="action">action card</li>';
  } else {
    html += '<li class="option" id="ok">acknowledge</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "space_combat_over", this.game.player) == 1) {
      let x = z[i].menuOption(this, "space_combat_over", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat_over", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlaySpaceCombatOver(player, sector, planet_idx);
      }, function () {
        imperium_self.playerPlaySpaceCombatOver(player, sector, planet_idx);
      });
    }

    if (action2 === "ok") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.endTurn();
    }

  });
}







//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayGroundCombat(attacker, defender, sector, planet_idx) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let html = '';

  this.game.state.ground_combat_sector = sector;
  this.game.state.ground_combat_planet_idx = planet_idx;

  let attacker_forces = this.returnNumberOfGroundForcesOnPlanet(attacker, sector, planet_idx);
  let defender_forces = this.returnNumberOfGroundForcesOnPlanet(defender, sector, planet_idx);

  if (sys.p[planet_idx].owner != attacker) {
    html = '<div class="sf-readable">'+this.returnFactionNickname(attacker)+' are invading ' + sys.p[planet_idx].name + ' with ' + attacker_forces + ' infantry. ' + this.returnFactionNickname(defender) + ' is defending with ' + defender_forces + ' infantry. This is round ' + this.game.state.ground_combat_round + ' of ground combat. </div><ul>';
  } else {
    html = '<div class="sf-readable">' + this.returnFactionNickname(defender) + ' are invading ' + sys.p[planet_idx].name + ' with ' + defender_forces + ' infantry. You have ' + attacker_forces + ' infantry remaining. This is round ' + this.game.state.ground_combat_round + ' of ground combat. </div><ul>';
  }

  let ac = this.returnPlayerActionCards(this.game.player, ["combat", "ground_combat"])
  if (ac.length > 0) {
    html += '<li class="option" id="attack">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="attack">continue</li>';
  }


  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "ground_combat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "ground_combat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "ground_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayGroundCombat(attacker, defender, sector, planet_idx);
      }, function () {
        imperium_self.playerPlayGroundCombat(attacker, defender, sector, planet_idx);
      });
    }

    if (action2 == "attack") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.prependMove("infantry_fire\t" + attacker + "\t" + defender + "\t" + sector + "\t" + planet_idx);
      imperium_self.endTurn();
    }

  });
}







//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPDSAttack(player, attacker, sector) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_pds"];
  let can_target_with_pds_fire = 1;

  let defender = -1;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  for (let i = 0; i < sys.s.units.length; i++) {
    if ((i + 1) != attacker) {
      if (sys.s.units[i].length > 0) {
        defender = (i + 1);
      }
    }
  }

  html = '<div class="sf-readable">Do you wish to fire your PDS before moving into the sector?</div><ul>';

  //
  // skip if attacker is immune
  //
  if (defender != -1) {
    if (imperium_self.game.players_info[defender - 1].temporary_immune_to_pds_fire) {
      html = '<div class="sf-readable">' + imperium_self.returnFaction(defender) + ' cannot be targeted by PDS fire during this invasion:</div><ul>';
      can_target_with_pds_fire = 0;
    }
  } else {
    html = '<div class="sf-readable">You cannot target any ships with PDS fire and must skip firing:</div><ul>';
    can_target_with_pds_fire = 0;
  }


  let ac = this.returnPlayerActionCards(player, relevant_action_cards);
  if (1 == 1) {
    html += '<li class="option" id="skip">skip PDS</li>';
  }
  if (can_target_with_pds_fire == 1) {
    html += '<li class="option" id="fire">fire PDS</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pds", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pds", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pds", imperium_self.game.player);
        }
      }
    }


    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPDSAttack(player, attacker, sector);
      }, function () {
        imperium_self.playerPlayPDSAttack(player, attacker, sector);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

    if (action2 == "fire") {
      // prepend so it happens after the modifiers -- defender instead of attacker here
      imperium_self.prependMove("pds_fire\t" + imperium_self.game.player + "\t" + defender + "\t" + sector);
      imperium_self.endTurn();
    };

  });

}


//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPDSDefense(player, attacker, sector) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_pds"];
  let can_target_with_pds_fire = 1;

  html = '<div class="sf-readable">Do you wish to fire your PDS?</div><ul>';

  //
  // skip if attacker is immune
  //
  if (imperium_self.game.players_info[attacker - 1].temporary_immune_to_pds_fire) {
    html = '<div class="sf-readable">Your attacker cannot be targeted by PDS fire during this invasion:</div><ul>';
    can_target_with_pds_fire = 0;
  }


  let ac = this.returnPlayerActionCards(player, relevant_action_cards);
  if (1 == 1) {
    html += '<li class="option" id="skip">skip PDS</li>';
  }
  if (can_target_with_pds_fire == 1) {
    html += '<li class="option" id="fire">fire PDS</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pds", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pds", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pds", imperium_self.game.player);
        }
      }
    }


    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPDSDefense(player, attacker, sector);
      }, function () {
        imperium_self.playerPlayPDSDefense(player, attacker, sector);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

    if (action2 == "fire") {
      // prepend so it happens after the modifiers
      imperium_self.prependMove("pds_fire\t" + imperium_self.game.player + "\t" + attacker + "\t" + sector);
      imperium_self.endTurn();
    };

  });

}


//
// reaching this implies that the player can choose to fire / not-fire
//
playerResolveDeadlockedAgenda(agenda, choices) {

  let imperium_self = this;
  let html = '';

  html = '<div class="sf-readable">The agenda has become deadlocked in the Senate. You - the Speaker - must resolve it: </div><ul>';
  for (let i = 0; i < choices.length; i++) {
    html += '<li class="option" id="' + i + '">' + this.returnNameFromIndex(choices[i]) + '</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    imperium_self.addMove("resolve_agenda\t" + agenda + "\tspeaker\t" + choices[action2]);
    imperium_self.endTurn();
    return 0;

  });
}




//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPreAgendaStage(player, agenda, agenda_idx) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_agenda", "rider"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  if (this.doesPlayerHaveRider(imperium_self.game.player)) {
    html = '<div class="sf-readable">With your riders depending on how the other factions vote, your emissaries track the mood in the Senate closely...:</div><ul>';
  } else {
    html = '<div class="sf-readable">As the Senators gather to vote on ' + this.agenda_cards[agenda].name + ', your emissaries nervously tally the votes in their head:</div><ul>';
  }

  if (1 == 1) {
    html += '<li class="option" id="skip">proceed into Senate</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pre_agenda", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pre_agenda", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "agenda", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPreAgendaStage(player, agenda, agenda_idx);
      }, function () {
        imperium_self.playerPlayPreAgendaStage(player, agenda, agenda_idx);
      }, ["pre_agenda", "rider"]);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

  });

}
playerPlayPostAgendaStage(player, agenda, array_of_winning_options) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["post_agenda"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  if (array_of_winning_options.length > 0) {
    html = '<div class="sf-readable">The Senate has apparently voted for "' + this.returnNameFromIndex(array_of_winning_options[0]) + '". As the Speaker confirms the final tally, you get the feeling the issue may not be fully settled:</div><ul>';
  } else {
    html = '<div class="sf-readable">No-one in the Senate bothered to show-up and vote, leaving the matter to be decided by the Speaker:</div><ul>';
  }
  if (array_of_winning_options.length > 1) {
    html = '<div class="sf-readable">The voting has concluded in deadlock. The Speaker must resolve the agenda:</div><ul>';
  }

  if (1 == 1) {
    html += '<li class="option" id="skip">await results</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "post_agenda", this.game.player) == 1) {
      let x = z[i].menuOption(this, "post_agenda", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "post_agenda", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPostAgendaStage(player, agenda, array_of_winning_options);
      }, function () {
        imperium_self.playerPlayPostAgendaStage(player, agenda, array_of_winning_options);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

  });

}



playerContinueTurn(player, sector) {

  let imperium_self = this;
  let options_available = 0;

  if (this.game.tracker.invasion == undefined) { this.game.tracker = this.returnPlayerTurnTracker(); this.game.tracker.activate_system = 1; }

  //
  // check to see if any ships survived....
  //
  let playercol = "player_color_" + this.game.player;
  let html = "<div class='sf-readable'><div class='player_color_box " + playercol + "'></div>" + this.returnFaction(player) + ": </div><ul>";

  if (this.canPlayerScoreActionStageVictoryPoints(player) != "") {
    html += '<li class="option" id="score">score secret objective</li>';
    options_available++;
  }
  if (this.canPlayerProduceInSector(player, sector) && this.game.tracker.production == 0) {
    html += '<li class="option" id="produce">produce units</li>';
    options_available++;
  }

  if (this.canPlayerInvadePlanet(player, sector) && this.game.tracker.invasion == 0) {
    if (sector == "new-byzantium" || sector == "4_4") {
      if ((imperium_self.game.planets['new-byzantium'].owner != -1) || (imperium_self.returnAvailableInfluence(imperium_self.game.player) + imperium_self.game.players_info[imperium_self.game.player - 1].goods) >= 6) {
        html += '<li class="option" id="invade">invade planet</li>';
        options_available++;
      }
    } else {
      html += '<li class="option" id="invade">invade planet</li>';
      options_available++;
    }
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">reassign infantry</li>';
    options_available++;
  }
  if (this.game.tracker.trade == 0 && this.canPlayerTrade(this.game.player) == 1) {
    html += '<li class="option" id="trade">trade</li>';
  }

  //if (this.canPlayerPlayActionCard(player) && this.game.tracker.action_card == 0) {
  //  html += '<li class="option" id="action">action card</li>';
  //  options_available++;
  //}

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "continue", this.game.player) == 1) {
      let x = z[i].menuOption(this, "continue", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }

  html += '<li class="option" id="endturn">end turn</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "continue", imperium_self.game.player);
        }
      }
    }

    if (action2 == "endturn") {
      imperium_self.addMove("resolve\tplay");
      imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
      imperium_self.endTurn();
      return 0;
    }

    if (action2 == "trade") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerTurn();
      return 0;
    }

    if (action2 == "land") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerSelectInfantryToLand(sector);
      return 0;
    }

    if (action2 == "produce") {

      //
      // check the fleet supply and NOTIFY users if they are about to surpass it
      //
      let fleet_supply_in_sector = imperium_self.returnSpareFleetSupplyInSector(imperium_self.game.player, sector);
      if (fleet_supply_in_sector <= 1) {
        let notice = "You have no spare fleet supply in this sector. Do you still wish to produce more ships?";
        if (fleet_supply_in_sector == 1) {
          notice = "You have fleet supply for 1 additional capital ship in this sector. Do you still wish to produce more ships?";
        }
        let c = sconfirm(notice);
        if (c) {
          imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
          imperium_self.playerProduceUnits(sector);
        }
        return;
      }
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerProduceUnits(sector);
    }

    if (action2 == "invade") {

      //
      // New Byzantium requires 6 influence to conquer
      //
      if (sector === "new-byzantium" || sector == "4_4") {
        if (imperium_self.game.planets['new-byzantium'].owner == -1) {
          if (imperium_self.returnAvailableInfluence(imperium_self.game.player) >= 6) {
            imperium_self.playerSelectInfluence(6, function (success) {
              imperium_self.game.tracker.invasion = 1;
              imperium_self.playerInvadePlanet(player, sector);
            });
          } else {
            salert("The first conquest of New Byzantium requires spending 6 influence, which you lack.");
            return;
          }
          return;
        }
      }

      imperium_self.game.tracker.invasion = 1;
      imperium_self.playerInvadePlanet(player, sector);
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.game.tracker.action_card = 1;
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
      }, function () {
        imperium_self.playerContinueTurn(player, sector);
        return;
      });
    }

    if (action2 == "score") {
      imperium_self.playerScoreActionStageVictoryPoints(imperium_self, function (imperium_self, vp, objective) {
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
        if (vp > 0) { imperium_self.addMove("score\t" + imperium_self.game.player + "\t" + vp + "\t" + objective); }
        imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.push(objective);
        imperium_self.endTurn();
        return;
      });
    }
  });
}





////////////////
// Production //
////////////////
playerBuyTokens(stage = 0, resolve = 1) {

  let imperium_self = this;

  if (this.returnAvailableInfluence(this.game.player) <= 2) {
    this.updateLog("You skip the initiative secondary, as you lack adequate influence...");
    this.updateStatus("Skipping purchase of tokens as insufficient influence...");
    if (resolve == 1) {
      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
    }
    this.endTurn();
    return 0;
  }

  let html = '<div class="sf-readable">Do you wish to purchase any command or strategy tokens, or increase your fleet supply?</div><ul>';

  if (stage == 2) {
    html = '<div class="sf-readable">Leadership has been played. Do you wish to purchase any additional command or strategy tokens, or increase your fleet supply?</div><ul>';
    if (imperium_self.game.state.round == 1)  {
      html = `The Leadership strategy card has been played. This lets you spend 3 influence to purchase additional command tokens, strategy tokens or fleet supply. Do you wish to purchase any additional tokens: </p><ul>`;
    }
  }

  html += '<li class="buildchoice textchoice" id="skip">Do Not Purchase</li>';
  html += '<li class="buildchoice textchoice" id="command">Command Tokens  +<span class="command_total">0</span></li>';
  html += '<li class="buildchoice textchoice" id="strategy">Strategy Tokens +<span class="strategy_total">0</span></li>';
  html += '<li class="buildchoice textchoice" id="fleet">Fleet Supply  +<span class="fleet_total">0</span></li>';
  html += '</ul></p>';
  html += '';
  html += '<div id="buildcost" class="buildcost"><span class="buildcost_total">0</span> influence</div>';
  html += '<div id="confirm" class="buildchoice">click here to finish</div>';

  this.updateStatus(html);


  let command_tokens = 0;
  let strategy_tokens = 0;
  let fleet_supply = 0;
  let total_cost = 0;

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let id = $(this).attr("id");

    if (id == "skip") {
      if (resolve == 1) {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      }
      imperium_self.endTurn();
      return;
    }

    if (id == "confirm") {

      total_cost = 3 * (fleet_supply + command_tokens + strategy_tokens);

      if (resolve == 1) {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
        imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      }

      imperium_self.playerSelectInfluence(total_cost, function (success) {

        if (success == 1) {
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tcommand\t" + command_tokens);
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tcommand\t" + strategy_tokens);
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tfleetsupply\t" + fleet_supply);
          imperium_self.endTurn();
          return;
        } else {
          imperium_self.endTurn();
        }
      });
    };

    //
    //  figure out if we need to load infantry / fighters
    //
    if (id == "command") { command_tokens++; }
    if (id == "strategy") { strategy_tokens++; }
    if (id == "fleet") { fleet_supply++; }

    let divtotal = "." + id + "_total";
    let x = parseInt($(divtotal).html());
    x++;
    $(divtotal).html(x);

    total_cost = 3 * (command_tokens + strategy_tokens + fleet_supply);
    $('.buildcost_total').html(total_cost);


    let return_to_zero = 0;
    if (total_cost > imperium_self.returnAvailableInfluence(imperium_self.game.player)) {
      salert("You cannot buy more tokens than you have influence available to pay");
      return_to_zero = 1;
    }
    if (return_to_zero == 1) {
      total_cost = 0;
      command_tokens = 0;
      strategy_tokens = 0;
      fleet_supply = 0;
      $('.command_total').html(0);
      $('.strategy_total').html(0);
      $('.fleet_total').html(0);
      return;
    }

  });
}





 playerBuyActionCards(stage = 0, resolve = 1) {

  let imperium_self = this;

  let html = '<div class="sf-readable">Do you wish to spend 1 strategy token to purchase 2 action cards?</div><ul>';
  if (stage == 2) {
    html = '<div class="sf-readable">Politics has been played: do you wish to spend 1 strategy token to purchase 2 action cards?</div><ul>';
    if (imperium_self.game.state.round == 1) {
      html = `${imperium_self.returnFaction(imperium_self.game.player)} has played the Politics strategy card. This lets you to spend 1 strategy token to purchase 2 action cards, which provide special one-time abilities. You have ${imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens} strategy tokens. Purchase action cards: </p><ul>`;
    }
  }
  html += '<li class="buildchoice textchoice" id="yes">Purchase Action Cards</li>';
  html += '<li class="buildchoice textchoice" id="no">Do Not Purchase Action Cards</li>';
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let id = $(this).attr("id");

    if (id == "yes") {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " gets action cards");
      imperium_self.addMove("gain\t" + imperium_self.game.player + "\taction_cards\t2");
      imperium_self.addMove("DEAL\t2\t" + imperium_self.game.player + "\t2");
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    } else {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    }
  });

 }




 playerBuySecretObjective(stage = 0, resolve = 1) {

  let imperium_self = this;

  let html = '<div class="sf-readable">Do you wish to spend 1 strategy token to purchase a Secret Objective?</div><ul>';
  if (stage == 2) {
    html = '<div class="sf-readable">The Imperial Strategy card has been played: do you wish to spend 1 strategy token to purchase a Secret Objective?</div><ul>';
    if (imperium_self.game.state.round == 1) {
      html = `${imperium_self.returnFaction(imperium_self.game.player)} has played the Imperial strategy card. This lets you to spend 1 strategy token to purchase an additional secret bjective. You have ${imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens} strategy tokens. Purchase secret objective: </p><ul>`;
    }
  }
  html += '<li class="buildchoice textchoice" id="yes">Purchase Secret Objective</li>';
  html += '<li class="buildchoice textchoice" id="no">Do Not Purchase</li>';
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let id = $(this).attr("id");

    if (id == "yes") {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.addMove("gain\t" + imperium_self.game.player + "\tsecret_objective\t1");
      imperium_self.addMove("DEAL\t6\t" + imperium_self.game.player + "\t1");
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    } else {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    }
  });

}





playerResearchTechnology(mycallback) {

  let imperium_self = this;
  let html = '<div class="sf-readable">You are eligible to upgrade to the following technologies: </div><ul>';

  for (var i in this.tech) {
    if (this.canPlayerResearchTechnology(i)) {
      html += '<li class="option" id="' + i + '">' + this.tech[i].name + '</li>';
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showTechCard(s); });
  $('.option').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideTechCard(s); });
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let i = $(this).attr("id");
    imperium_self.hideTechCard(i);

    //
    // handle prerequisites
    //
    imperium_self.exhaustPlayerResearchTechnologyPrerequisites(i);
    mycallback($(this).attr("id"));

  });

}


//
// return string if YES, empty string if NO
//
canPlayerScoreActionStageVictoryPoints(player) {

  let imperium_self = this;
  let html = "";

  //
  // Secret Objectives - Action Phase
  //
  for (let i = 0; i < imperium_self.game.deck[5].hand.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (imperium_self.secret_objectives[imperium_self.game.deck[5].hand[i]].phase === "action") {
          html += '<li class="option secret3" id="' + imperium_self.game.deck[5].hand[i] + '">' + imperium_self.secret_objectives[imperium_self.game.deck[5].hand[i]].name + '</li>';
        }
      }
    }
  }

  return html;

}




playerScoreActionStageVictoryPoints(imperium_self, mycallback, stage = 0) {

  let html = '';
  let player = imperium_self.game.player;

  html += '<div class="sf-readable">Do you wish to score a secret objective? </div><ul>';

  html += this.canPlayerScoreActionStageVictoryPoints(player);
  html += '<li class="option cancel" id="cancel">cancel</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);
  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    let objective_type = 3;

    if ($(this).hasClass("stage1")) { objective_type = 1; }
    if ($(this).hasClass("stage2")) { objective_type = 2; }
    if ($(this).hasClass("secret3")) { objective_type = 3; }

    if (action === "no") {
      mycallback(imperium_self, 0, "");

    } else {

      let objective = action;
      let vp = 1;
      if (imperium_self.secret_objectives[objective]) {
        if (imperium_self.secret_objectives[objective].vp > 1) { vp = imperium_self.stage_ii_objectives[objective].vp; }
      }

      mycallback(imperium_self, vp, objective);

    }
  });
}



canPlayerScoreVictoryPoints(player, card = "", deck = 1) {

  if (card == "") { return 0; }

  let imperium_self = this;

  // deck 1 = primary
  // deck 2 = secondary
  // deck 3 = secret

  if (deck == 1) {
    let objectives = this.returnStageIPublicObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  if (deck == 2) {
    let objectives = this.returnStageIIPublicObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  if (deck == 3) {
    let objectives = this.returnSecretObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  return 0;

}




playerScoreSecretObjective(imperium_self, mycallback, stage = 0) {

  let html = '';
  let can_score = 0;

  html += '<div class="sf-readable">Do you wish to score any Secret Objectives? </div><ul>';

  // Secret Objectives
  for (let i = 0; i < imperium_self.game.deck[5].hand.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.deck[5].hand[i])) {
          can_score = 1;
          html += '1 VP Secret Objective: <li class="option secret3" id="' + imperium_self.game.deck[5].hand[i] + '">' + imperium_self.game.deck[5].cards[imperium_self.game.deck[5].hand[i]].name + '</li>';
        }
      }
    }
  }

  html += '<li class="option" id="no">I choose not to score...</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);

  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    if (action == "no") {
      mycallback(imperium_self, 0, "");
    } else {
      let objective = action;
      let vp = 1;
      if (imperium_self.secret_objectives[objective]) {
        if (imperium_self.secret_objectives[objective].vp > 1) { vp = imperium_self.secret_objectives[objective].vp; }
      }
      mycallback(imperium_self, vp, objective);
    }
  });
}


playerScoreVictoryPoints(imperium_self, mycallback, stage = 0) {

  let html = '';
  html += '<div class="sf-readable">Do you wish to score any public objectives? </div><ul>';

  // Stage I Public Objectives
  for (let i = 0; i < imperium_self.game.state.stage_i_objectives.length; i++) {

    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.state.stage_i_objectives[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.state.stage_i_objectives[i], 1)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.state.stage_i_objectives[i])) {
          html += '1 VP Public Objective: <li class="option stage1" id="' + imperium_self.game.state.stage_i_objectives[i] + '">' + imperium_self.game.deck[3].cards[imperium_self.game.state.stage_i_objectives[i]].name + '</li>';
        }
      }
    }
  }

  // Stage II Public Objectives
  for (let i = 0; i < imperium_self.game.state.stage_ii_objectives.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.state.stage_ii_objectives[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.state.stage_ii_objectives[i], 2)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.state.stage_ii_objectives[i])) {
          html += '2 VP Public Objective: <li class="option stage2" id="' + imperium_self.game.state.stage_ii_objectives[i] + '">' + imperium_self.game.deck[4].cards[imperium_self.game.state.stage_ii_objectives[i]].name + '</li>';
        }
      }
    }
  }

  /***
      // Secret Objectives
      for (let i = 0 ; i < imperium_self.game.deck[5].hand.length; i++) {
        if (!imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
          if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (!imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.includes(imperium_self.game.deck[5].hand[i])) {
              html += '1 VP Secret Objective: <li class="option secret3" id="'+imperium_self.game.deck[5].hand[i]+'">'+imperium_self.game.deck[5].cards[imperium_self.game.deck[5].hand[i]].name+'</li>';
            }
          }
        }
      }
  ***/

  html += '<li class="option" id="no">I choose not to score...</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);
  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    let objective_type = 3;

    if ($(this).hasClass("stage1")) { objective_type = 1; }
    if ($(this).hasClass("stage2")) { objective_type = 2; }
    if ($(this).hasClass("secret3")) { objective_type = 3; }

    if (action === "no") {
      mycallback(imperium_self, 0, "");
    } else {
      let objective = action;
      let vp = 1;
      if (imperium_self.stage_ii_objectives[objective]) {
        if (imperium_self.stage_ii_objectives[objective].vp > 1) { vp = imperium_self.stage_ii_objectives[objective].vp; }
      }
      mycallback(imperium_self, vp, objective);

    }
  });
}




 playerBuildInfrastructure(mycallback, stage = 1) {

  let imperium_self = this;

  let html = '';

  if (stage == 1) { html += "<div class='sf-readable'>Which would you like to build: </div><ul>"; }
  else { html += "<div class='sf_readable'>You may also build an additional PDS: </div><ul>"; }

  html += '<li class="buildchoice" id="pds">Planetary Defense System</li>';
  if (stage == 1) {
    html += '<li class="buildchoice" id="spacedock">Space Dock</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  let stuff_to_build = [];

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showUnit(s); });
  $('.buildchoice').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideUnit(s); });
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();
    $('.buildchoice').off();

    let id = $(this).attr("id");

    imperium_self.playerSelectPlanetWithFilter(
      "Select a planet on which to build: ",
      function (planet) {
        let existing_units = 0;
        if (imperium_self.game.planets[planet].owner == imperium_self.game.player) {
          for (let i = 0; i < imperium_self.game.planets[planet].units[imperium_self.game.player - 1].length; i++) {
            if (imperium_self.game.planets[planet].units[imperium_self.game.player - 1][i].type == id) {
              existing_units++;
            }
          }
          if (id === "pds") {
            if (existing_units >= imperium_self.game.state_pds_limit_per_planet) { return 0; }
          }
          if (id === "spacedock") {
            if (existing_units >= 1) { return 0; }
          }
          return 1;
        }
        return 0;
      },
      function (planet) {
        if (id == "pds") {
          imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + imperium_self.game.planets[planet].idx + "\tpds\t" + imperium_self.game.planets[planet].sector);
          mycallback(imperium_self.game.planets[planet].sector);
        }
        if (id == "spacedock") {
          imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + imperium_self.game.planets[planet].idx + "\tspacedock\t" + imperium_self.game.planets[planet].sector);
          mycallback(imperium_self.game.planets[planet].sector);
        }
      },
      function() {
        imperium_self.unlockInterface();
        imperium_self.playerBuildInfrastructure(mycallback, stage);
      },
    );
  });

}


 playerProduceUnits(sector, production_limit = 0, cost_limit = 0, stage = 0, warfare = 0) {

  let imperium_self = this;

  let player_fleet = this.returnPlayerFleet(imperium_self.game.player);
  let player_build = {};
  player_build.infantry = 0;
  player_build.fighters = 0;
  player_build.carriers = 0;
  player_build.cruisers = 0;
  player_build.dreadnaughts = 0;
  player_build.destroyers = 0;
  player_build.flagships = 0;
  player_build.warsuns = 0;

  //
  // determine production_limit from sector
  //
  let sys = this.returnSectorAndPlanets(sector);
  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
  available_resources += imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;

  let calculated_production_limit = 0;
  for (let i = 0; i < sys.s.units[this.game.player - 1].length; i++) {
    calculated_production_limit += sys.s.units[this.game.player - 1][i].production;
  }
  for (let p = 0; p < sys.p.length; p++) {
    for (let i = 0; i < sys.p[p].units[this.game.player - 1].length; i++) {
      calculated_production_limit += sys.p[p].units[this.game.player - 1][i].production;
      if (sys.p[p].units[this.game.player - 1][i].type === "spacedock") {
        calculated_production_limit += sys.p[p].resources;
      }
    }
  }

  if (this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock == 1) {
    if (production_limit == 0 && this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_production_limit >= 0) { production_limit = this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_production_limit; }
    if (cost_limit == 0 && this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_cost_limit >= 0) { cost_limit = this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_cost_limit; }
  };

  if (calculated_production_limit > production_limit) { production_limit = calculated_production_limit; }


  let html = '<div class="sf-readable">Produce Units in this Sector: ';
  if (production_limit != 0) { html += '(' + production_limit + ' units max)'; }
  if (cost_limit != 0) { html += '(' + cost_limit + ' cost max)'; }
  html += '</div><ul>';
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="infantry">Infantry - <span class="infantry_total">0</span></li>';
  }
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="fighter">Fighter - <span class="fighter_total">0</span></li>';
  }
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="destroyer">Destroyer - <span class="destroyer_total">0</span></li>';
  }
  if (available_resources >= 3) {
    html += '<li class="buildchoice" id="carrier">Carrier - <span class="carrier_total">0</span></li>';
  }
  if (available_resources >= 2) {
    html += '<li class="buildchoice" id="cruiser">Cruiser - <span class="cruiser_total">0</span></li>';
  }
  if (available_resources >= 4) {
    html += '<li class="buildchoice" id="dreadnaught">Dreadnaught - <span class="dreadnaught_total">0</span></li>';
  }
  if (available_resources >= 8 && this.canPlayerProduceFlagship(imperium_self.game.player)) {
    html += '<li class="buildchoice" id="flagship">Flagship - <span class="flagship_total">0</span></li>';
  }
  if (imperium_self.game.players_info[imperium_self.game.player - 1].may_produce_warsuns == 1) {
    if (available_resources >= 12) {
      html += '<li class="buildchoice" id="warsun">War Sun - <span class="warsun_total">0</span></li>';
    }
  }
  html += '</ul>';
  html += '</p>';
  html += '<div id="buildcost" class="buildcost"><span class="buildcost_total">0 resources</span></div>';
  html += '<div id="confirm" class="buildchoice">click here to build</div>';

  this.updateStatus(html);

  let stuff_to_build = [];

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showUnit(s); });
  $('.buildchoice').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideUnit(s); });
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let id = $(this).attr("id");

    //
    // submit when done
    //
    if (id == "confirm") {

      $('.buildchoice').off();

      let total_cost = 0;
      for (let i = 0; i < stuff_to_build.length; i++) {
        total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
      }

      if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
        total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
      }

      if (warfare == 0) {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      } else {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
        imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      }

      imperium_self.playerSelectResources(total_cost, function (success) {

        if (success == 1) {
          imperium_self.addMove("post_production\t" + imperium_self.game.player + "\t" + sector + "\t" + JSON.stringify(stuff_to_build));
          for (let y = 0; y < stuff_to_build.length; y++) {
            let planet_idx = imperium_self.returnPlayersLeastDefendedPlanetInSector(imperium_self.game.player, sector);
            if (stuff_to_build[y] != "infantry") { planet_idx = -1; }
            imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + planet_idx + "\t" + stuff_to_build[y] + "\t" + sector);
            imperium_self.addMove("setvar"+"\t"+"state"+"\t"+"0"+"\t"+"active_player_has_produced"+"\t"+1)
            imperium_self.game.tracker.production = 1;
          }
          imperium_self.endTurn();
          return;
        } else {
          salert("failure to find appropriate influence");
        }
      });

      return;
    };


    let calculated_total_cost = 0;
    for (let i = 0; i < stuff_to_build.length; i++) {
      calculated_total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
    }
    calculated_total_cost += imperium_self.returnUnitCost(id, imperium_self.game.player);

    //
    // reduce production costs if needed
    //
    if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
      calculated_total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
    }




    //
    // respect production / cost limits
    //
    let return_to_zero = 0;
    if (id == "fighter" && (player_build.fighters + player_fleet.fighters) > imperium_self.game.players_info[imperium_self.game.player - 1].fighter_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].fighter_limit + " fighters on the board");
      return_to_zero = 1;
    }
    if (id == "infantry" && (player_build.infantry + player_fleet.infantry) > imperium_self.game.players_info[imperium_self.game.player - 1].infantry_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].infantry_limit + " infantry on the board");
      return_to_zero = 1;
    }
    if (id == "destroyer" && (player_build.destroyers + player_fleet.destroyers) > imperium_self.game.players_info[imperium_self.game.player - 1].destroyer_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].destroyer_limit + " destroyers on the board");
      return_to_zero = 1;
    }
    if (id == "carrier" && (player_build.carriers + player_fleet.carriers) > imperium_self.game.players_info[imperium_self.game.player - 1].carrier_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].carrier_limit + " carriers on the board");
      return_to_zero = 1;
    }
    if (id == "cruiser" && (player_build.cruisers + player_fleet.cruisers) > imperium_self.game.players_info[imperium_self.game.player - 1].cruiser_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].cruiser_limit + " cruisers on the board");
      return_to_zero = 1;
    }
    if (id == "dreadnaught" && (player_build.dreadnaughts + player_fleet.dreadnaughts) > imperium_self.game.players_info[imperium_self.game.player - 1].dreadnaught_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].dreadnaught_limit + " dreadnaughts on the board");
      return_to_zero = 1;
    }
    if (id == "flagship" && (player_build.flagships + player_fleet.flagships) > imperium_self.game.players_info[imperium_self.game.player - 1].flagships_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].flagship_limit + " flagships on the board");
      return_to_zero = 1;
    }
    if (id == "warsun" && (player_build.warsuns + player_fleet.warsuns) > imperium_self.game.players_info[imperium_self.game.player - 1].warsun_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].warsun_limit + " warsuns on the board");
      return_to_zero = 1;
    }
    if (calculated_total_cost > imperium_self.returnAvailableResources(imperium_self.game.player)) {
      salert("You cannot build more than you have available to pay for it.");
      return_to_zero = 1;
    }
    if (production_limit < stuff_to_build.length && production_limit > 0) {
      salert("You cannot build more units than your production limit");
      return_to_zero = 1;
    }
    if (cost_limit < calculated_total_cost && cost_limit > 0) {
      salert("You cannot build units that cost more than your cost limit");
      return_to_zero = 1;
    }
    if ((stuff_to_build.length + 1) > calculated_production_limit) {
      salert("You cannot build more units than your production limit");
      return_to_zero = 1;
    }
    if (return_to_zero == 1) {
      stuff_to_build = [];
      $('.infantry_total').html(0);
      $('.fighter_total').html(0);
      $('.destroyer_total').html(0);
      $('.carrier_total').html(0);
      $('.cruiser_total').html(0);
      $('.dreadnaught_total').html(0);
      $('.flagship_total').html(0);
      $('.warsun_total').html(0);
      player_build = {};
      player_build.infantry = 0;
      player_build.fighters = 0;
      player_build.carriers = 0;
      player_build.cruisers = 0;
      player_build.dreadnaughts = 0;
      player_build.destroyers = 0;
      player_build.flagships = 0;
      player_build.warsuns = 0;
      return;
    }

    //
    //  figure out if we need to load infantry / fighters
    //
    stuff_to_build.push(id);

    let total_cost = 0;
    for (let i = 0; i < stuff_to_build.length; i++) {
      total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
    }

    let divtotal = "." + id + "_total";
    let x = parseInt($(divtotal).html());
    x++;
    $(divtotal).html(x);

    //
    // reduce production costs if needed
    //
    if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
      total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
      imperium_self.updateLog("Production Costs reduced by 1");
    }

    let resourcetxt = " resources";
    if (total_cost == 1) { resourcetxt = " resource"; }
    $('.buildcost_total').html(total_cost + resourcetxt);

  });

}


playerHandleTradeOffer(faction_offering, their_offer, my_offer, offer_log) {

  let imperium_self = this;

  let goods_offered = 0;
  let goods_received = 0;
  let promissaries_offered = "";
  let promissaries_received = "";

  if (their_offer.promissaries) {
    if (their_offer.promissaries.length > 0) {
      for (let i = 0; i < their_offer.promissaries.length; i++) {
        let pm = their_offer.promissaries[i].promissary;
	let tmpar = pm.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
        if (i > 0) { promissaries_received += ', '; }
        promissaries_received += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }
    }
  }

  if (my_offer.promissaries) {
    if (my_offer.promissaries.length > 0) {
      for (let i = 0; i < my_offer.promissaries.length; i++) {
        let pm = my_offer.promissaries[i].promissary;
	let tmpar = pm.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
        if (i > 0) { promissaries_offered += ', '; }
        promissaries_offered += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }
    }
  }

  let html = '<div class="sf-readable">You have received a trade offer from ' + imperium_self.returnFaction(faction_offering) + '. ';
  html += offer_log;
  html += ': </div><ul>';
  html += `  <li class="option" id="yes">accept trade</li>`;
  html += `  <li class="option" id="no">refuse trade</li>`;
  html += '</ul>';

  imperium_self.updateStatus(html);


  $('.option').off();
  $('.option').on('click', function () {

    let action = $(this).attr("id");

    if (action == "no") {
      imperium_self.addMove("refuse_offer\t" + imperium_self.game.player + "\t" + faction_offering);
      imperium_self.endTurn();
      return 0;
    }

    if (action == "yes") {
      imperium_self.addMove("trade\t" + faction_offering + "\t" + imperium_self.game.player + "\t" + JSON.stringify(their_offer) + "\t" + JSON.stringify(my_offer));
      imperium_self.endTurn();
      return 0;
    }

  });


}


  playerTrade() {

    let imperium_self = this;
    let factions = this.returnFactions();

    let offer_selected = 0;
    let receive_selected = 0;
    let offer_promissaries = [];
    let receive_promissaries = [];
    let max_offer = 0;
    let max_receipt = 0;


    let goodsTradeInterface = function (imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      let receive_promissary_text = 'no promissaries';
      for (let i = 0; i < receive_promissaries.length; i++) {
        if (i == 0) { receive_promissary_text = ''; }
        let pm = receive_promissaries[i];
	let tmpar = pm.promissary.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	if (i > 0) { receive_promissary_text += ', '; }
        receive_promissary_text += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }

      let offer_promissary_text = 'no promissaries';
      for (let i = 0; i < offer_promissaries.length; i++) {
        if (i == 0) { offer_promissary_text = ''; }
        let pm = offer_promissaries[i];
	let tmpar = pm.promissary.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	if (i > 0) { offer_promissary_text += ', '; }
        offer_promissary_text += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }

      let html = "<div class='sf-readable'>Make an Offer: </div><ul>";
      html += '<li id="to_offer" class="option">you give <span class="offer_total">'+offer_selected+'</span> trade goods</li>';
      html += '<li id="to_receive" class="option">you receive <span class="receive_total">'+receive_selected+'</span> trade goods</li>';
      html += '<li id="promissary_offer" class="option">you give <span class="give_promissary">'+offer_promissary_text+'</span></li>';
      html += '<li id="promissary_receive" class="option">you receive <span class="receive_promissary">'+receive_promissary_text+'</span></li>';
      html += '<li id="confirm" class="option">submit offer</li>';
      html += '<li id="cancel" class="option">cancel</li>';
      html += '</ul>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let selected = $(this).attr("id");

        if (selected == "to_offer") { offer_selected++; if (offer_selected > max_offer) { offer_selected = 0; } }
        if (selected == "to_receive") { receive_selected++; if (receive_selected > max_receipt) { receive_selected = 0; } }

	if (selected == "cancel") {
	  imperium_self.playerTurn();
	  return;
	}
	if (selected == "promissary_offer") {
	  promissaryTradeInterface(imperium_self, player, 1, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;
	}
	if (selected == "promissary_receive") {
	  promissaryTradeInterface(imperium_self, player, 2, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;
	}

        if (selected == "confirm") {

          let my_offer = {};
          my_offer.goods = $('.offer_total').html();
	  my_offer.promissaries = offer_promissaries;
          let my_receive = {};
          my_receive.goods = $('.receive_total').html();
	  my_receive.promissaries = receive_promissaries;

          imperium_self.addMove("offer\t" + imperium_self.game.player + "\t" + player + "\t" + JSON.stringify(my_offer) + "\t" + JSON.stringify(my_receive));
          imperium_self.updateStatus("trade offer submitted");
          imperium_self.endTurn();

        }

        $('.offer_total').html(offer_selected);
        $('.receive_total').html(receive_selected);

      });
    }
    //
    // mode = 1 // offer
	      2 // receive
    //
    let promissaryTradeInterface = function (imperium_self, player, mode, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      // offer mine to them
      if (mode == 1) {

        let html = '<div class="sf-readable">Add Promissary to YOUR Offer: </div><ul>';
        for (let i = 0; i < imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes.length; i++) {

	  let pm = imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes[i];
	  let tmpar = pm.split("-");
          let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	  let already_offered = 0;
	  for (let b = 0; b < offer_promissaries.length; b++) {
	    if (offer_promissaries[b].promissary === pm) {
	      already_offered = 1;
	    }
	  }
	  if (already_offered == 0) {
            html += `  <li class="option" id="${i}">${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
        }
        html += `  <li class="option" id="cancel">cancel</li>`;

	imperium_self.updateStatus(html);
        $('.option').off();
        $('.option').on('click', function () {

          let prom = $(this).attr("id");

          if (prom == "cancel") {
            goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
            return 0;
          }
	  
	  let promobj = { player : imperium_self.game.player , promissary : imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes[prom] }
	  offer_promissaries.push(promobj);
          goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;

	});
      }



      // request theirs
      if (mode == 2) {

        let html = '<div class="sf-readable">Request Promissary FROM them: </div><ul>';
        for (let i = 0; i < imperium_self.game.players_info[player-1].promissary_notes.length; i++) {
	  let pm = imperium_self.game.players_info[player-1].promissary_notes[i];
	  let tmpar = pm.split("-");
          let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	  let already_offered = 0;
	  for (let b = 0; b < receive_promissaries.length; b++) {
	    if (receive_promissaries[b].promissary === pm) {
	      already_offered = 1;
	    }
	  }
	  if (already_offered == 0) {
            html += `  <li class="option" id="${i}">${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
        }
        html += `  <li class="option" id="cancel">cancel</li>`;

	imperium_self.updateStatus(html);
        $('.option').off();
        $('.option').on('click', function () {

          let prom = $(this).attr("id");

          if (prom == "cancel") {
            goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
            return 0;
          }
	  
	  let promobj = { player : player , promissary : imperium_self.game.players_info[player-1].promissary_notes[prom] }
	  receive_promissaries.push(promobj);
          goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;

	});


      }

    }
    let mainTradeInterface = function (imperium_self, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      let html = '<div class="sf-readable">Make Trade Offer to Faction: </div><ul>';
      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
        if (imperium_self.game.players_info[i].traded_this_turn == 0 && (i + 1) != imperium_self.game.player) {
          if (imperium_self.arePlayersAdjacent(imperium_self.game.player, (i + 1))) {
            html += `  <li class="option" id="${i}">${factions[imperium_self.game.players_info[i].faction].name}</li>`;
          }
        }
      }
      html += `  <li class="option" id="cancel">cancel</li>`;
      html += '</ul>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let faction = $(this).attr("id");

        if (faction == "cancel") {
          imperium_self.playerTurn();
          return 0;
        }

        max_offer = imperium_self.game.players_info[imperium_self.game.player - 1].commodities + imperium_self.game.players_info[imperium_self.game.player - 1].goods;
        max_receipt = imperium_self.game.players_info[parseInt(faction)].commodities + imperium_self.game.players_info[parseInt(faction)].goods;

	goodsTradeInterface(imperium_self, (parseInt(faction)+1), mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);

      });
    }

    //
    // start with the main interface
    //
    mainTradeInterface(imperium_self, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);

  }




playerSelectSector(mycallback, mode = 0) {

  //
  // mode
  //
  // 0 = any sector
  // 1 = activated actor
  //
  let imperium_self = this;

  $('.sector').off();
  $('.sector').on('click', function () {
    $('.sector').off();
    let pid = $(this).attr("id");
    mycallback(pid);
  });

}




playerSelectPlanet(mycallback, mode = 0) {

  //
  // mode
  //
  // 0 = in any sector
  // 1 = in unactivated actor
  // 2 = controlled by me
  //

  let imperium_self = this;

  let html = "Select a system in which to select a planet: ";
  this.updateStatus(html);

  $('.sector').on('click', function () {

    let sector = $(this).attr("id");
    let sys = imperium_self.returnSectorAndPlanets(sector);

    //
    // exit if no planets are controlled
    //
    if (mode == 2) {
      let exist_controlled_planets = 0;
      for (let i = 0; i < sys.p.length; i++) {
        if (sys.p[i].owner == imperium_self.game.player) {
          exist_controlled_planets = 1;
        }
      }
      if (exist_controlled_planets == 0) {
        salert("Invalid Choice: you do not control planets in that sector");
        return;
      }
    }


    html = '<div class="sf-readable">Select a planet in this system: </div><ul>';
    for (let i = 0; i < sys.p.length; i++) {
      if (mode == 0) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
      }
      if (mode == 1) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
      }
      if (mode == 2 && sys.p[i].owner == imperium_self.game.player) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + '</li>';
      }
    }
    html += '</ul>';


    imperium_self.updateStatus(html);

    $('.option').off();
    $('.option').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showPlanetCard(sector, s); imperium_self.showSectorHighlight(sector); });
    $('.option').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hidePlanetCard(sector, s); imperium_self.hideSectorHighlight(sector); });
    $('.option').on('click', function () {
      let pid = $(this).attr("id");
      imperium_self.hidePlanetCard(sector, pid);
      mycallback(sector, pid);
    });

  });

}



playerSelectInfluence(cost, mycallback) {

  if (cost == 0) { mycallback(1); return; }

  let imperium_self = this;
  let array_of_cards = this.returnPlayerUnexhaustedPlanetCards(this.game.player); // unexhausted
  let array_of_cards_to_exhaust = [];
  let selected_cost = 0;
  let total_trade_goods = imperium_self.game.players_info[imperium_self.game.player - 1].goods;


  let html = "<div class='sf-readable'>Select " + cost + " in influence: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    html += '<li class="cardchoice cardchoice-card" id="cardchoice_' + array_of_cards[z] + '">' + this.returnPlanetCard(array_of_cards[z]) + '</li>';
  }
  if (1 == imperium_self.game.players_info[imperium_self.game.player - 1].goods) {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade good</li>';
  } else {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade goods</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.cardchoice , .textchoice').on('click', function () {

    let action2 = $(this).attr("id");
    let tmpx = action2.split("_");

    let divid = "#" + action2;
    let y = tmpx[1];
    let idx = 0;
    for (let i = 0; i < array_of_cards.length; i++) {
      if (array_of_cards[i] === y) {
        idx = i;
      }
    }



    //
    // handle spending trade goods
    //
    if (action2 == "trade_goods") {
      if (total_trade_goods > 0) {
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tgoods\t1");
        total_trade_goods--;
        selected_cost += 1;

        if (1 == total_trade_goods) {
          $('#trade_goods').html(('' + total_trade_goods + ' trade good'));
        } else {
          $('#trade_goods').html(('' + total_trade_goods + ' trade goods'));
        }
      }
    } else {
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tplanet\t" + array_of_cards[idx]);
      array_of_cards_to_exhaust.push(array_of_cards[idx]);
      $(divid).off();
      $(divid).css('opacity', '0.2');
      selected_cost += imperium_self.game.planets[array_of_cards[idx]].influence;
    }

    if (cost <= selected_cost) {

      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.cardchoice , .textchoice').off();

      mycallback(1);
    }

  });
}






playerSelectStrategyAndCommandTokens(cost, mycallback) {

  if (cost == 0) { mycallback(1); }

  let imperium_self = this;
  let selected_cost = 0;

  let html = "<div class='sf-readable'>Select " + cost + " in Strategy and Command Tokens: </div><ul>";
  html += '<li class="textchoice" id="strategy">strategy tokens - <span class="available_strategy_tokens">'+imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens+'</span></li>';
  html += '<li class="textchoice" id="command">command tokens - <span class="available_command_tokens">'+imperium_self.game.players_info[imperium_self.game.player-1].command_tokens+'</span></li>';
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();

  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "strategy") {
      let x = parseInt($('.available_strategy_tokens').html());
      if (x > 0) {
        selected_cost++;
        $('.available_strategy_tokens').html((x-1));
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      }
    }
    if (action2 == "command") {
      let x = parseInt($('.available_command_tokens').html());
      if (x > 0) {
        selected_cost++;
        $('.available_command_tokens').html((x-1));
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tcommand\t1");
      }
    }

    if (cost <= selected_cost) { 
      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.textchoice').off();
      mycallback(1); 
    }

  });

}



playerSelectResources(cost, mycallback) {

  if (cost == 0) { mycallback(1); return; }

  let imperium_self = this;
  let array_of_cards = this.returnPlayerUnexhaustedPlanetCards(this.game.player); // unexhausted
  let array_of_cards_to_exhaust = [];
  let selected_cost = 0;
  let total_trade_goods = imperium_self.game.players_info[imperium_self.game.player - 1].goods;

  let html = "<div class='sf-readable'>Select " + cost + " in resources: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    html += '<li class="cardchoice cardchoice-card" id="cardchoice_' + array_of_cards[z] + '">' + this.returnPlanetCard(array_of_cards[z]) + '</li>';
  }
  if (1 == imperium_self.game.players_info[imperium_self.game.player - 1].goods) {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade good</li>';
  } else {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade goods</li>';
  }
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();

  $('.cardchoice , .textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    let tmpx = action2.split("_");

    let divid = "#" + action2;
    let y = tmpx[1];
    let idx = 0;
    for (let i = 0; i < array_of_cards.length; i++) {
      if (array_of_cards[i] === y) {
        idx = i;
      }
    }

    //
    // handle spending trade goods
    //
    if (action2 == "trade_goods") {
      if (total_trade_goods > 0) {
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tgoods\t1");
        total_trade_goods--;
        selected_cost += 1;

        if (1 == total_trade_goods) {
          $('#trade_goods').html(('' + total_trade_goods + ' trade good'));
        } else {
          $('#trade_goods').html(('' + total_trade_goods + ' trade goods'));
        }
      }
    } else {
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tplanet\t" + array_of_cards[idx]);
      array_of_cards_to_exhaust.push(array_of_cards[idx]);
      $(divid).off();
      $(divid).css('opacity', '0.2');
      selected_cost += parseInt(imperium_self.game.planets[array_of_cards[idx]].resources);
    }

    if (cost <= selected_cost) { 

      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.cardchoice , .textchoice').off();

      mycallback(1); 

    }

  });

}








playerSelectActionCard(mycallback, cancel_callback, types = []) {

  let imperium_self = this;
  let array_of_cards = this.returnPlayerActionCards(this.game.player, types);
  if (array_of_cards.length == 0) {
    this.playerAcknowledgeNotice("You do not have any action cards that can be played now", function () {
      if (cancel_callback != null) { cancel_callback(); return 0; }
      imperium_self.playerTurn();
      return 0;
    });
    return 0;
  }

  let html = '';

  html += "<div class='sf-readable'>Select an action card: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    if (!this.game.players_info[this.game.player - 1].action_cards_played.includes(array_of_cards[z])) {
      let thiscard = imperium_self.action_cards[array_of_cards[z]];
      html += '<li class="textchoice pointer" id="' + array_of_cards[z] + '">' + thiscard.name + '</li>';
    }
  }
  html += '<li class="textchoice pointer" id="cancel">cancel</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showActionCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideActionCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 != "cancel") { imperium_self.hideActionCard(action2); }
    if (action2 === "cancel") { cancel_callback(); return 0; }

    if (imperium_self.game.tracker) { imperium_self.game.tracker.action_card = 1; }
    if (imperium_self.action_cards[action2].type == "action") { imperium_self.game.state.active_player_moved = 1; }

    imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(action2);

    mycallback(action2);

  });

}


//
// this is when players are choosing to play the cards that they have 
// already chosen.
//
playerSelectStrategyCard(mycallback, mode = 0) {

  let array_of_cards = this.game.players_info[this.game.player - 1].strategy;
  let strategy_cards = this.returnStrategyCards();
  let imperium_self = this;

  let html = "";

  html += "<div class='sf-readable'>Select a strategy card: </div><ul>";
  for (let z in array_of_cards) {
    if (!this.game.players_info[this.game.player - 1].strategy_cards_played.includes(array_of_cards[z])) {
      html += '<li class="textchoice" id="' + array_of_cards[z] + '">' + strategy_cards[array_of_cards[z]].name + '</li>';
    }
  }
  html += '<li class="textchoice pointer" id="cancel">cancel</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showStrategyCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideStrategyCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 != "cancel") { imperium_self.hideStrategyCard(action2); }

    if (action2 === "cancel") {
      imperium_self.playerTurn();
      return;
    }

    mycallback(action2);

  });
}




//
// this is when players select at the begining of the round, not when they 
// are chosing to play the cards that they have already selected
//
playerSelectStrategyCards(mycallback) {

  let imperium_self = this;
  let cards = this.returnStrategyCards();
  let playercol = "player_color_" + this.game.player;
  let relevant_action_cards = ["strategy"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);


  let html = "<div class='terminal_header'><div class='player_color_box " + playercol + "'></div>" + this.returnFaction(this.game.player) + ": select your strategy card:</div><ul>";
  if (this.game.state.round > 1) {
    html = "<div class='terminal_header'>" + this.returnFaction(this.game.player) + ": select your strategy card:</div><ul>";
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  let scards = [];

  for (let z in this.strategy_cards) {
    scards.push("");
  }

  for (let z = 0; z < this.game.state.strategy_cards.length; z++) {
    let rank = parseInt(this.strategy_cards[this.game.state.strategy_cards[z]].rank);
    while (scards[rank - 1] != "") { rank++; }
    scards[rank - 1] = '<li class="textchoice" id="' + this.game.state.strategy_cards[z] + '">' + cards[this.game.state.strategy_cards[z]].name + '</li>';
  }

  for (let z = 0; z < scards.length; z++) {
    if (scards[z] != "") {
      html += scards[z];
    }
  }

  html += '</ul></p>';
  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showStrategyCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideStrategyCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("pickstrategy\t" + imperium_self.game.player);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
        return 0;
      }, function () {
        imperium_self.playerSelectActionCards(action_card_player, card);
      }, ["action"]);
      return 0;
    }

    imperium_self.hideStrategyCard(action2);
    mycallback(action2);
  });

}



playerRemoveInfantryFromPlanets(player, total = 1, mycallback) {

  let imperium_self = this;

  let html = '';
  html += '<div class="sf-readable">Remove ' + total + ' infantry from planets you control:</div>';
  html += '<ul>';

  let infantry_to_remove = [];

  for (let s in this.game.planets) {
    let planet = this.game.planets[s];
    if (planet.owner == player) {
      let infantry_available_here = 0;
      for (let ss = 0; ss < planet.units[player - 1].length; ss++) {
        if (planet.units[player - 1][ss].type == "infantry") { infantry_available_here++; }
      }
      if (infantry_available_here > 0) {
        html += '<li class="option textchoice" id="' + s + '">' + planet.name + ' - <div style="display:inline" id="' + s + '_infantry">' + infantry_available_here + '</div></li>';
      }
    }
  }
  html += '<li class="option textchoice" id="end"></li>';
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "end") {

      for (let i = 0; i < infantry_to_remove.length; i++) {

        let planet_in_question = imperium_self.game.planets[infantry_to_remove[i].planet];

        let total_units_on_planet = planet_in_question.units[player - 1].length;
        for (let ii = 0; ii < total_units_on_planet; ii++) {
          let thisunit = planet_in_question.units[player - 1][ii];
          if (thisunit.type == "infantry") {
            planet_in_question.units[player - 1].splice(ii, 1);
            ii = total_units_on_planet + 2; // 0 as player_moves below because we have removed above
            imperium_self.addMove("remove_infantry_from_planet\t" + player + "\t" + infantry_to_remove[i].planet + "\t" + "0");
            imperium_self.addMove("NOTIFY\tREMOVING INFANTRY FROM PLANET: " + infantry_to_remove[i].planet);
          }
        }
      }
      mycallback(infantry_to_remove.length);
      return;
    }

    infantry_to_remove.push({ infantry: 1, planet: action2 });
    let divname = "#" + action2 + "_infantry";
    let existing_infantry = $(divname).html();
    let updated_infantry = parseInt(existing_infantry) - 1;
    if (updated_infantry < 0) { updated_infantry = 0; }

    $(divname).html(updated_infantry);

    if (updated_infantry == 0) {
      $(this).remove();
    }

    if (infantry_to_remove.length >= total) {
      $('#end').click();
    }

  });

}

playerAddInfantryToPlanets(player, total = 1, mycallback) {

  let imperium_self = this;

  let html = '';
  html += '<div class="sf-readable">Add ' + total + ' infantry to planets you control:</div>';
  html += '<ul>';

  let infantry_to_add = [];

  for (let s in this.game.planets) {
    let planet = this.game.planets[s];
    if (planet.owner == player) {
      let infantry_available_here = 0;
      for (let ss = 0; ss < planet.units[player - 1].length; ss++) {
        if (planet.units[player - 1][ss].type == "infantry") { infantry_available_here++; }
      }
      html += '<li class="option textchoice" id="' + s + '">' + planet.name + ' - <div style="display:inline" id="' + s + '_infantry">' + infantry_available_here + '</div></li>';
    }
  }
  html += '<li class="option textchoice" id="end"></li>';
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "end") {
      for (let i = 0; i < infantry_to_add.length; i++) {
        imperium_self.addMove("add_infantry_to_planet\t" + player + "\t" + infantry_to_add[i].planet + "\t" + "1");
      }
      mycallback(infantry_to_add.length);
      return;
    }

    infantry_to_add.push({ infantry: 1, planet: action2 });
    let divname = "#" + action2 + "_infantry";
    let existing_infantry = $(divname).html();
    let updated_infantry = parseInt(existing_infantry) + 1;

    $(divname).html(updated_infantry);

    if (infantry_to_add.length >= total) {
      $('#end').click();
    }

  });

}


//////////////////////////
// Select Units to Move //
//////////////////////////
playerSelectUnitsToMove(destination) {

  let imperium_self = this;
  let html = '';
  let hops = 3;
  let sectors = [];
  let distance = [];
  let hazards = [];
  let hoppable = [];
  let fighters_loaded = 0;
  let infantry_loaded = 0;

  let obj = {};
  obj.max_hops = 2;
  obj.ship_move_bonus = this.game.players_info[this.game.player - 1].ship_move_bonus + this.game.players_info[this.game.player - 1].temporary_ship_move_bonus;
  obj.fleet_move_bonus = this.game.players_info[this.game.player - 1].fleet_move_bonus + this.game.players_info[this.game.player - 1].temporary_fleet_move_bonus;
  obj.ships_and_sectors = [];
  obj.stuff_to_move = [];
  obj.stuff_to_load = [];
  obj.distance_adjustment = 0;

  obj.max_hops += obj.ship_move_bonus;
  obj.max_hops += obj.fleet_move_bonus;

  let x = imperium_self.returnSectorsWithinHopDistance(destination, obj.max_hops, imperium_self.game.player);
  sectors = x.sectors;
  distance = x.distance;
  hazards = x.hazards;
  hoppable = x.hoppable;

  for (let i = 0; i < distance.length; i++) {
    if (obj.ship_move_bonus > 0) {
      distance[i]--;
    }
    if (obj.fleet_move_bonus > 0) {
      distance[i]--;
    }
  }

  if (obj.ship_move_bonus > 0) {
    obj.distance_adjustment += obj.ship_move_bonus;
  }
  if (obj.fleet_move_bonus > 0) {
    obj.distance_adjustment += obj.fleet_move_bonus;
  }

  obj.ships_and_sectors = imperium_self.returnShipsMovableToDestinationFromSectors(destination, sectors, distance, hazards, hoppable);

  let updateInterface = function (imperium_self, obj, updateInterface) {

    let subjective_distance_adjustment = 0;
    if (obj.ship_move_bonus > 0) {
      subjective_distance_adjustment += obj.ship_move_bonus;
    }
    if (obj.fleet_move_bonus > 0) {
      subjective_distance_adjustment += obj.fleet_move_bonus;
    }
    let spent_distance_boost = (obj.distance_adjustment - subjective_distance_adjustment);

    let playercol = "player_color_" + imperium_self.game.player;
    let html = "<div class='player_color_box " + playercol + "'></div> " + imperium_self.returnFaction(imperium_self.game.player) + ': select ships to move<ul>';

    //
    // select ships
    //
    for (let i = 0; i < obj.ships_and_sectors.length; i++) {

      let sys = imperium_self.returnSectorAndPlanets(obj.ships_and_sectors[i].sector);
      html += '<b class="sector_name" id="' + obj.ships_and_sectors[i].sector + '" style="margin-top:10px">' + sys.s.name + '</b>';
      html += '<ul class="ship_selector">';
      for (let ii = 0; ii < obj.ships_and_sectors[i].ships.length; ii++) {

        //
        // figure out if we can still move this ship
        //
        let already_moved = 0;
        for (let z = 0; z < obj.stuff_to_move.length; z++) {
          if (obj.stuff_to_move[z].already_moved == 1) {
            already_moved = 1;
          }
          if (obj.stuff_to_move[z].sector == obj.ships_and_sectors[i].sector) {
            if (obj.stuff_to_move[z].i == i) {
              if (obj.stuff_to_move[z].ii == ii) {
                already_moved = 1;
              }
            }
          }
        }

	let rift_passage = 0;
	if (obj.ships_and_sectors[i].hazards[ii] === "rift") { rift_passage = 1; }

        if (already_moved == 1) {
          if (rift_passage == 0) {
            html += `<li id="sector_${i}_${ii}" class=""><b>${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</b></li>`;
	  } else {
            html += `<li id="sector_${i}_${ii}" class=""><b>${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</b> - rift</li>`;
	  }
        } else {
          if (obj.ships_and_sectors[i].ships[ii].move - (obj.ships_and_sectors[i].adjusted_distance[ii] + spent_distance_boost) >= 0) {
            if (rift_passage == 0) {
	      html += `<li id="sector_${i}_${ii}" class="option">${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</li>`;
            } else {
	      html += `<li id="sector_${i}_${ii}" class="option">${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])} - rift</li>`;
	    }
          }
        }
      }

      html += '</ul>';
    }
    html += '<hr />';
    html += '<div id="confirm" class="option">click here to move</div>';
//    html += '<hr />';
//    html += '<div id="clear" class="option">clear selected</div>';
    html += '<hr />';
    imperium_self.updateStatus(html);

    //
    // add hover / mouseover to sector names
    //
    let adddiv = ".sector_name";
    $(adddiv).on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.addSectorHighlight(s); });
    $(adddiv).on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.removeSectorHighlight(s); });


    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");

      //
      // submit when done
      //
      if (id == "confirm") {

        imperium_self.addMove("resolve\tplay");
        // source should be OK as moving out does not add units
        imperium_self.addMove("space_invasion\t" + imperium_self.game.player + "\t" + destination);
        imperium_self.addMove("check_fleet_supply\t" + imperium_self.game.player + "\t" + destination);
        for (let y = 0; y < obj.stuff_to_move.length; y++) {

	  let this_ship_i = obj.stuff_to_move[y].i;
	  let this_ship_ii = obj.stuff_to_move[y].ii;
	  let this_ship_hazard = obj.ships_and_sectors[this_ship_i].hazards[this_ship_ii];

          imperium_self.addMove("move\t" + imperium_self.game.player + "\t" + 1 + "\t" + obj.ships_and_sectors[obj.stuff_to_move[y].i].sector + "\t" + destination + "\t" + JSON.stringify(obj.ships_and_sectors[obj.stuff_to_move[y].i].ships[obj.stuff_to_move[y].ii]) + "\t" + this_ship_hazard);
        }
        for (let y = obj.stuff_to_load.length - 1; y >= 0; y--) {
          imperium_self.addMove("load\t" + imperium_self.game.player + "\t" + 0 + "\t" + obj.stuff_to_load[y].sector + "\t" + obj.stuff_to_load[y].source + "\t" + obj.stuff_to_load[y].source_idx + "\t" + obj.stuff_to_load[y].unitjson + "\t" + obj.stuff_to_load[y].shipjson);
        }

        imperium_self.endTurn();
        return;
      };

      //
      // clear the list to start again
      //
      if (id == "clear") {
        salert("To change movement options, please reload!");
	window.location.reload(true);
        return;
      }


      //
      // highlight ship on menu
      //
      $(this).css("font-weight", "bold");
      this.classList.add("ship_selected");

      //
      //  figure out if we need to load infantry / fighters
      //
      let tmpx = id.split("_");
      let i = tmpx[1];
      let ii = tmpx[2];
      let calcdist = obj.ships_and_sectors[i].distance;
      let sector = obj.ships_and_sectors[i].sector;
      let sys = imperium_self.returnSectorAndPlanets(sector);
      let ship = obj.ships_and_sectors[i].ships[ii];
      let total_ship_capacity = imperium_self.returnRemainingCapacity(ship);
      let x = { i: i, ii: ii, sector: sector };


      //
      // calculate actual distance
      //
      let real_distance = calcdist + obj.distance_adjustment;
      let free_distance = ship.move + obj.fleet_move_bonus;

      if (real_distance > free_distance) {
        //
        // 
        //
        obj.ship_move_bonus--;
      }


      //
      // if this is a fighter, remove it from the underlying
      // list of units we can move, so that it is not double-added
      //
      if (ship.type == "fighter") {
        obj.ships_and_sectors[i].ships[ii].already_moved = 1;
      }




      obj.stuff_to_move.push(x);
      updateInterface(imperium_self, obj, updateInterface);


      //
      // is there stuff left to move?
      //
      let stuff_available_to_move = 0;
      for (let i = 0; i < sys.p.length; i++) {
        let planetary_units = sys.p[i].units[imperium_self.game.player - 1];
        for (let k = 0; k < planetary_units.length; k++) {
          if (planetary_units[k].type == "infantry") {
            stuff_available_to_move++;
          }
        }
      }
      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].type == "fighter") {
          stuff_available_to_move++;
        }
      }


      //
      // remove already-moved fighters from stuff-available-to-move
      // 
      let fighters_available_to_move = 0;
      for (let iii = 0; iii < sys.s.units[imperium_self.game.player - 1].length; iii++) {
        if (sys.s.units[imperium_self.game.player - 1][iii].type == "fighter") {
          let fighter_already_moved = 0;
          for (let z = 0; z < obj.stuff_to_move.length; z++) {
            if (obj.stuff_to_move[z].sector == sector) {
              if (obj.stuff_to_move[z].ii == iii) {
                fighter_already_moved = 1;
              }
            }
          }
          if (fighter_already_moved == 1) {
            stuff_available_to_move--;
          }
        }
      }


      if (total_ship_capacity > 0 && stuff_available_to_move > 0) {
        let remove_what_capacity = 0;
        for (let z = 0; z < obj.stuff_to_load.length; z++) {
          let x = obj.stuff_to_load[z];
          if (x.i == i && x.ii == ii) {
            let thisunit = JSON.parse(obj.stuff_to_load[z].unitjson);
            remove_what_capacity += thisunit.capacity_required;
          }
        }


        let user_message = `<div class="sf-readable">This ship has <span class="capacity_remaining">${total_ship_capacity}</span> capacity. Infantry can capture planets and fighters can protect your fleet. Do you wish to add them? </div><ul>`;

        for (let i = 0; i < sys.p.length; i++) {
          let planetary_units = sys.p[i].units[imperium_self.game.player - 1];
          let infantry_available_to_move = 0;
          for (let k = 0; k < planetary_units.length; k++) {
            if (planetary_units[k].type == "infantry") {
              infantry_available_to_move++;
            }
          }
          if (infantry_available_to_move > 0) {
            user_message += '<li class="option textchoice" id="addinfantry_p_' + i + '">add infantry from ' + sys.p[i].name + ' - <span class="add_infantry_remaining_' + i + '">' + infantry_available_to_move + '</span></li>';
          }
        }

        let fighters_available_to_move = 0;
        for (let iii = 0; iii < sys.s.units[imperium_self.game.player - 1].length; iii++) {
          if (sys.s.units[imperium_self.game.player - 1][iii].type == "fighter") {
            let fighter_already_moved = 0;
            for (let z = 0; z < obj.stuff_to_move.length; z++) {
              if (obj.stuff_to_move[z].sector == sector) {
                if (obj.stuff_to_move[z].ii == iii) {
                  fighter_already_moved = 1;
                }
              }
            }
            if (fighter_already_moved == 0) {
              fighters_available_to_move++;
            }
          }
        }
        user_message += '<li class="option textchoice" id="addfighter_s_s">add fighter - <span class="add_fighters_remaining">' + fighters_available_to_move + '</span></li>';
        user_message += '<li class="option textchoice" id="skip">finish</li>';
        user_message += '</ul></div>';


        //
        // choice
        //
        $('.status-overlay').html(user_message);
        $('.status-overlay').show();
        $('.status').hide();
        $('.textchoice').off();

        //
        // add hover / mouseover to message
        //
        for (let i = 0; i < sys.p.length; i++) {
          adddiv = "#addinfantry_p_" + i;
          $(adddiv).on('mouseenter', function () { imperium_self.addPlanetHighlight(sector, i); });
          $(adddiv).on('mouseleave', function () { imperium_self.removePlanetHighlight(sector, i); });
        }
        adddiv = "#addfighter_s_s";
        $(adddiv).on('mouseenter', function () { imperium_self.addSectorHighlight(sector); });
        $(adddiv).on('mouseleave', function () { imperium_self.removeSectorHighlight(sector); });


        // leave action enabled on other panels
        $('.textchoice').on('click', function () {

          let id = $(this).attr("id");
          let tmpx = id.split("_");
          let action2 = tmpx[0];

          if (total_ship_capacity > 0) {

            if (action2 === "addinfantry") {

              let planet_idx = tmpx[2];
              let irdiv = '.add_infantry_remaining_' + planet_idx;
              let ir = parseInt($(irdiv).html());
              let ic = parseInt($('.capacity_remaining').html());

              //
              // we have to load prematurely. so JSON will be accurate when we move the ship, so player_move is 0 for load
              //
              let unitjson = imperium_self.unloadUnitFromPlanet(imperium_self.game.player, sector, planet_idx, "infantry");
              let shipjson_preload = JSON.stringify(sys.s.units[imperium_self.game.player - 1][obj.ships_and_sectors[i].ship_idxs[ii]]);
              imperium_self.loadUnitByJSONOntoShip(imperium_self.game.player, sector, obj.ships_and_sectors[i].ship_idxs[ii], unitjson);

              $(irdiv).html((ir - 1));
              $('.capacity_remaining').html((ic - 1));

              let loading = {};
              loading.sector = sector;
              loading.source = "planet";
              loading.source_idx = planet_idx;
              loading.unitjson = unitjson;
              loading.ship_idx = obj.ships_and_sectors[i].ship_idxs[ii];
              loading.shipjson = shipjson_preload;
              loading.i = i;
              loading.ii = ii;

              total_ship_capacity--;

              obj.stuff_to_load.push(loading);

              if (ic === 1 && total_ship_capacity == 0) {
                $('.status').show();
                $('.status-overlay').hide();
              }

            }


            if (action2 === "addfighter") {

              if (fighters_available_to_move <= 0) { return; }

              let ir = parseInt($('.add_fighters_remaining').html());
              let ic = parseInt($('.capacity_remaining').html());
              $('.add_fighters_remaining').html((ir - 1));
              fighters_available_to_move--;
              $('.capacity_remaining').html((ic - 1));

              //
              // remove this fighter ...
              //
              let secs_to_check = obj.ships_and_sectors.length;
              for (let sec = 0; sec < obj.ships_and_sectors.length; sec++) {
                if (obj.ships_and_sectors[sec].sector === sector) {
                  let ships_to_check = obj.ships_and_sectors[sec].ships.length;
                  for (let f = 0; f < ships_to_check; f++) {
                    if (obj.ships_and_sectors[sec].ships[f].already_moved == 1) { } else {
                      if (obj.ships_and_sectors[sec].ships[f].type == "fighter") {

                        // remove fighter from status menu
                        let status_div = '#sector_' + sec + '_' + f;
                        $(status_div).remove();

                        // remove from arrays (as loaded)
                        // removed fri june 12
                        //obj.ships_and_sectors[sec].ships.splice(f, 1);
                        //obj.ships_and_sectors[sec].adjusted_distance.splice(f, 1);
                        obj.ships_and_sectors[sec].ships[f] = {};
                        obj.ships_and_sectors[sec].adjusted_distance[f] = 0;
                        f = ships_to_check + 2;
                        sec = secs_to_check + 2;

                      }
                    }
                  }
                }
              }

              let unitjson = imperium_self.removeSpaceUnit(imperium_self.game.player, sector, "fighter");
              let shipjson_preload = JSON.stringify(sys.s.units[imperium_self.game.player - 1][obj.ships_and_sectors[i].ship_idxs[ii]]);

              imperium_self.loadUnitByJSONOntoShip(imperium_self.game.player, sector, obj.ships_and_sectors[i].ship_idxs[ii], unitjson);

              let loading = {};
              obj.stuff_to_load.push(loading);

              loading.sector = sector;
              loading.source = "ship";
              loading.source_idx = "";
              loading.unitjson = unitjson;
              loading.ship_idx = obj.ships_and_sectors[i].ship_idxs[ii];
              loading.shipjson = shipjson_preload;
              loading.i = i;
              loading.ii = ii;

              total_ship_capacity--;

              if (ic == 1 && total_ship_capacity == 0) {
                $('.status').show();
                $('.status-overlay').hide();
              }
            }
          } // total ship capacity

          if (action2 === "skip") {
            $('.status-overlay').hide();
            $('.status').show();
          }

        });
      }
    });
  };

  updateInterface(imperium_self, obj, updateInterface);

  return;

}

//////////////////////////
// Select Units to Move //
//////////////////////////
playerSelectInfantryToLand(sector) {

  let imperium_self = this;
  let html = '<div id="status-message" class="imperial-status-message">Unload Infantry (source): <ul>';
  let sys = imperium_self.returnSectorAndPlanets(sector);

  let space_infantry = [];
  let ground_infantry = [];

  for (let i = 0; i < sys.s.units[this.game.player-1].length; i++) {
    let unit = sys.s.units[this.game.player-1][i];
    if (imperium_self.returnInfantryInUnit(unit) > 0) { 
      html += `<li class="option textchoice" id="addinfantry_s_${i}">remove infantry from ${unit.name} - <span class="add_infantry_remaining_s_${i}">${imperium_self.returnInfantryInUnit(unit)}</span></li>`;
    }
  }

  for (let p = 0; p < sys.p.length; p++) {
    let planet = sys.p[p];
    if (imperium_self.returnInfantryOnPlanet(planet) > 0) { 
      html += `<li class="option textchoice" id="addinfantry_p_${p}">remove infantry from ${planet.name} - <span class="add_infantry_remaining_p_${p}">${imperium_self.returnInfantryOnPlanet(planet)}</span></li>`;
    }
  }

  html += '</ul>';
  html += '</div>';

  html += '<div id="confirm" class="option">click here to move</div>';
//  html += '<hr />';
//  html += '<div id="clear" class="option">clear selected</div>';
  imperium_self.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let id = $(this).attr("id");
    let assigned_planets = [];
    let infantry_available_for_reassignment = 0;
    for (let i = 0; i < sys.p.length; i++) {
      assigned_planets.push(0);
    }

    //
    // submit when done
    //
    if (id == "confirm") {

      for (let i = 0; i < space_infantry.length; i++) {
	imperium_self.addMove("unload_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"ship"+"\t"+space_infantry[i].ship_idx);
        infantry_available_for_reassignment++;
      }
      for (let i = 0; i < ground_infantry.length; i++) {
	imperium_self.addMove("unload_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"planet"+"\t"+ground_infantry[i].planet_idx);
        infantry_available_for_reassignment++;
      }

      let html = '<div class="sf-readable" id="status-message">Reassign Infantry to Planets: <ul>';
          for (let i = 0; i < sys.p.length; i++) {
	    let infantry_remaining_on_planet = imperium_self.returnInfantryOnPlanet(sys.p[i]);
	    for (let ii = 0; ii < ground_infantry.length; ii++) {
	      if (ground_infantry[ii].planet_idx == i) { infantry_remaining_on_planet--; }
	    }
  	    html += `<li class="option textchoice" id="${i}">${sys.p[i].name} - <span class="infantry_on_${i}">${infantry_remaining_on_planet}</span></li>`;
          }
          html += '<div id="confirm" class="option">click here to move</div>';
          html += '</ul'; 
          html += '</div>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "confirm") {
	  imperium_self.endTurn();
        }

        if (infantry_available_for_reassignment > 0)  {
          infantry_available_for_reassignment--;
          let divname = ".infantry_on_"+id;
          let v = parseInt($(divname).html());
          v++;
	  $(divname).html((v));
	  imperium_self.addMove("load_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"planet"+"\t"+id);
	}

      });
    };

    //
    // clear the list to start again
    //
    if (id == "clear") {
      salert("To change movement options, just reload!");
      window.location.reload(true);
    }


    //
    // otherwise we selected
    //
    let user_selected = id.split("_");
    if (user_selected[1] === "p") {
      let divname = ".add_infantry_remaining_p_"+user_selected[2];
      let v = parseInt($(divname).html());
      if (v > 0) {
        ground_infantry.push({ planet_idx : user_selected[2] });
	$(divname).html((v-1));
      }
    }
    if (user_selected[1] === "s") {
      let divname = ".add_infantry_remaining_s_"+user_selected[2];
      let v = parseInt($(divname).html());
      if (v > 0) {
        space_infantry.push({ ship_idx : user_selected[2] });
	$(divname).html((v-1));
      }
    }

  });

  return;

}



playerInvadePlanet(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);

  let total_available_infantry = 0;
  let space_transport_available = 0;
  let space_transport_used = 0;

  let landing_forces = [];
  let landing_on_planet_idx = [];
  let planets_invaded = [];

  html = '<div class="sf-readable">Which planet(s) do you invade: </div><ul>';
  for (let i = 0; i < sys.p.length; i++) {
    if (sys.p[i].owner != player) {
      html += '<li class="option sector_name" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
    }
  }
  html += '<li class="option" id="confirm">launch invasion(s)</li>';
  html += '</ul>';
  this.updateStatus(html);

  let populated_planet_forces = 0;
  let populated_ship_forces = 0;
  let forces_on_planets = [];
  let forces_on_ships = [];

  $('.option').off();
  let adiv = ".sector_name";
  $(adiv).on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.addPlanetHighlight(sector, s); });
  $(adiv).on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.removePlanetHighlight(sector, s); });
  $('.option').on('click', function () {

    let planet_idx = $(this).attr('id');

    if (planet_idx === "confirm") {

/***
      if (landing_forces.length == 0) {
	let sanity_check = confirm("Invade without landing forces? Are you sure -- the invasion will fail.");
	if (!sanity_check) { return; }
      }
***/

      for (let i = 0; i < planets_invaded.length; i++) {

	if (landing_on_planet_idx.includes(planets_invaded[i])) {

            let owner = sys.p[planets_invaded[i]].owner;

            imperium_self.prependMove("bombardment\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("bombardment_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("bombardment_post\t" + owner + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("planetary_defense\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("planetary_defense_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_start\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_end\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);

        }

      }

      imperium_self.prependMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.endTurn();
      return;
    }

    //
    // looks like we have selected a planet for invasion
    //
    if (!planets_invaded.includes(planet_idx)) {
      planets_invaded.push(planet_idx);
    }

    //
    // figure out available infantry and ships capacity
    //
    for (let i = 0; i < sys.s.units[player - 1].length; i++) {
      let unit = sys.s.units[player - 1][i];
      for (let k = 0; k < unit.storage.length; k++) {
        if (unit.storage[k].type == "infantry") {
          if (populated_ship_forces == 0) {
            total_available_infantry += 1;
          }
        }
      }
      if (sys.s.units[player - 1][i].capacity > 0) {
        if (populated_ship_forces == 0) {
          space_transport_available += sys.s.units[player - 1][i].capacity;
        }
      }
    }

    html = '<div class="sf-readable">Select Ground Forces for Invasion of ' + sys.p[planet_idx].name + ': </div><ul>';

    //
    // other planets in system
    //
    for (let i = 0; i < sys.p.length; i++) {
      forces_on_planets.push(0);
      if (space_transport_available > 0 && sys.p[i].units[player - 1].length > 0) {
        for (let j = 0; j < sys.p[i].units[player - 1].length; j++) {
          if (sys.p[i].units[player - 1][j].type == "infantry") {
            if (populated_planet_forces == 0) {
              forces_on_planets[i]++;;
            }
          }
        }
        html += '<li class="invadechoice textchoice option" id="invasion_planet_' + i + '">' + sys.p[i].name + ' - <span class="planet_' + i + '_infantry">' + forces_on_planets[i] + '</span></li>';
      }
    }
    populated_planet_forces = 1;



    //
    // ships in system
    //
    for (let i = 0; i < sys.s.units[player - 1].length; i++) {
      let ship = sys.s.units[player - 1][i];
      forces_on_ships.push(0);
      for (let j = 0; j < ship.storage.length; j++) {
        if (ship.storage[j].type === "infantry") {
          if (populated_ship_forces == 0) {
            forces_on_ships[i]++;
          }
        }
      }
      if (forces_on_ships[i] > 0) {
        html += '<li class="invadechoice textchoice" id="invasion_ship_' + i + '">' + ship.name + ' - <span class="ship_' + i + '_infantry">' + forces_on_ships[i] + '</span></li>';
      }
    }
    populated_ship_forces = 1;
    html += '<li class="invadechoice textchoice" id="finished_0_0">finish selecting</li>';
    html += '</ul></p>';


    //
    // choice
    //
    $('.status-overlay').html(html);
    $('.status').hide();
    $('.status-overlay').show();


    $('.invadechoice').off();
    $('.invadechoice').on('click', function () {

      let id = $(this).attr("id");
      let tmpx = id.split("_");

      let action2 = tmpx[0];
      let source = tmpx[1];
      let source_idx = tmpx[2];
      let counter_div = "." + source + "_" + source_idx + "_infantry";
      let counter = parseInt($(counter_div).html());

      if (action2 == "invasion") {

        if (source == "planet") {
          if (space_transport_available <= 0) { salert("Invalid Choice! No space transport available!"); return; }
          forces_on_planets[source_idx]--;
        } else {
          forces_on_ships[source_idx]--;
        }
        if (counter == 0) {
          salert("You cannot attack with forces you do not have available."); return;
        }

        let unitjson = JSON.stringify(imperium_self.returnUnit("infantry", imperium_self.game.player));

        let landing = {};
        landing.sector = sector;
        landing.source = source;
        landing.source_idx = source_idx;
        landing.planet_idx = planet_idx;
        landing.unitjson = unitjson;

        landing_forces.push(landing);

        let planet_counter = ".invadeplanet_" + planet_idx;
        let planet_forces = parseInt($(planet_counter).html());

        planet_forces++;
        $(planet_counter).html(planet_forces);

        counter--;
        $(counter_div).html(counter);

      }

      if (action2 === "finished") {

        for (let y = 0; y < landing_forces.length; y++) {
          imperium_self.addMove("land\t" + imperium_self.game.player + "\t" + 1 + "\t" + landing_forces[y].sector + "\t" + landing_forces[y].source + "\t" + landing_forces[y].source_idx + "\t" + landing_forces[y].planet_idx + "\t" + landing_forces[y].unitjson);
	  if (!landing_on_planet_idx.includes(landing_forces[y].planet_idx)) { landing_on_planet_idx.push(landing_forces[y].planet_idx); }
        };
        landing_forces = [];
	

        $('.status').show();
        $('.status-overlay').hide();

        return;
      }
    });
  });
}



playerActivateSystem() {

  let imperium_self = this;
  let html = "Select a sector to activate: ";
  let activated_once = 0;
  let xpos = 0;
  let ypos = 0;

  imperium_self.updateStatus(html);

  $('.sector').off();
  $('.sector').on('mousedown', function (e) {
    xpos = e.clientX;
    ypos = e.clientY;
  });
  $('.sector').on('mouseup', function (e) {

    if (Math.abs(xpos-e.clientX) > 4) { return; }
    if (Math.abs(ypos-e.clientY) > 4) { return; }

    //
    // only allowed 1 at a time
    //
    if (activated_once == 1) { return; }

    let pid = $(this).attr("id");

    if (imperium_self.canPlayerActivateSystem(pid) == 0) {
      salert("You cannot activate that system.");
    } else {

      let sys = imperium_self.returnSectorAndPlanets(pid);

      //
      // sanity check on whether we want to do this
      //
      let do_we_permit_this_activation = 1;
      if (!imperium_self.canPlayerMoveShipsIntoSector(imperium_self.game.player, pid)) {
	let c = confirm("You cannot move ships into this sector. Are you sure you wish to activate it?");
	if (c) {
        } else {
	  return;
	}
      }
 
      //
      // if this is our homeworld, it is round 1 and we haven't moved ships out, we may not 
      // understand 
      //
      if (imperium_self.returnPlayerHomeworldSector() == sys.s.sector && imperium_self.game.state.round == 1) {
	let confirm_choice = confirm("If you activate your homeworld you will not be able to move ships out of it until Round 2. Are you sure you want to do this?");
	if (!confirm_choice) { return; }
      }


      activated_once = 1;
      let divpid = '#' + pid;

      $(divpid).find('.hex_activated').css('background-color', 'var(--p' + imperium_self.game.player + ')');
      $(divpid).find('.hex_activated').css('opacity', '0.3');


      let chtml = "<div class='sf-readable'>Activate this system?</div><ul>";
          chtml += '<li class="option" id="yes">yes, do it</li>';
          chtml += '<li class="option" id="no">choose again</li>';
          chtml += '</ul>';

      imperium_self.updateStatus(chtml);
      
      $('.option').off();
      $('.option').on('click', function() {

        let action2 = $(this).attr("id");

        if (action2 === "yes") {
          sys.s.activated[imperium_self.game.player - 1] = 1;
          imperium_self.addMove("activate_system_post\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("pds_space_attack_post\t"+imperium_self.game.player+"\t"+pid);
          imperium_self.addMove("pds_space_attack\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("activate_system\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("expend\t" + imperium_self.game.player + "\t" + "command" + "\t" + 1);
          imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "1");
          imperium_self.endTurn();

        } else {

          activated_once = 0;
          $(divpid).find('.hex_activated').css('background-color', 'transparent');
          $(divpid).find('.hex_activated').css('opacity', '1');

	  imperium_self.playerActivateSystem();

        }
      });
    }

  });
}


//
// if we have arrived here, we are ready to continue with our options post
// systems activation, which are move / pds combat / space combat / bombardment
// planetary invasion / ground combat
//
playerPostActivateSystem(sector) {

  let imperium_self = this;
  let relevant_action_cards = ["post_activate_system"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);
  let player = imperium_self.game.player;

  let html = "<div class='sf-readable'>" + this.returnFaction(this.game.player) + ": </div><ul>";

  if (imperium_self.canPlayerMoveShipsIntoSector(player, sector)) {
    html += '<li class="option" id="move">move into sector</li>';
  }


  if (this.canPlayerInvadePlanet(player, sector) && this.game.tracker.invasion == 0) {
    if (sector == "new-byzantium" || sector == "4_4") {
      if ((imperium_self.game.planets['new-byzantium'].owner != -1) || (imperium_self.returnAvailableInfluence(imperium_self.game.player) + imperium_self.game.players_info[imperium_self.game.player - 1].goods) >= 6) {
        html += '<li class="option" id="invade">invade planet</li>';
      }
    } else {
      html += '<li class="option" id="invade">invade planet</li>';
    }
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">reassign infantry</li>';
  }

  if (this.canPlayerProduceInSector(this.game.player, sector)) {
    html += '<li class="option" id="produce">produce units</li>';
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">relocate infantry</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  html += '<li class="option" id="finish">finish turn</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("activate_system_post\t" + imperium_self.game.player + "\t" + sector);
        imperium_self.game.players_info[this.game.player - 1].action_cards_played.push(card);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
      }, function () {
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, ["action"]);
    }


    if (action2 == "invade") {

      //
      // New Byzantium requires 6 influence to conquer
      //
      if (sector === "new-byzantium" || sector == "4_4") {
        if (imperium_self.game.planets['new-byzantium'].owner == -1) {
          if (imperium_self.returnAvailableInfluence(imperium_self.game.player) >= 6) {
            imperium_self.playerSelectInfluence(6, function (success) {
              imperium_self.game.tracker.invasion = 1;
              imperium_self.playerInvadePlanet(player, sector);
            });
          } else {
            salert("The first conquest of New Byzantium requires spending 6 influence, which you lack.");
            return;
          }
          return;
        }
      }

      imperium_self.game.tracker.invasion = 1;
      imperium_self.playerInvadePlanet(player, sector);
    }



    if (action2 == "land") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerSelectInfantryToLand(sector);
      return 0;
    }

    if (action2 == "move") {
      imperium_self.playerSelectUnitsToMove(sector);
    }
    if (action2 == "produce") {
      //
      // check the fleet supply and NOTIFY users if they are about to surpass it
      //
      let fleet_supply_in_sector = imperium_self.returnSpareFleetSupplyInSector(player, sector);
      if (fleet_supply_in_sector <= 1) {
        let notice = "You have no spare fleet supply in this sector. Do you still wish to produce more ships?";
        if (fleet_supply_in_sector == 1) {
          notice = "You have fleet supply for 1 additional capital ship in this sector. Do you still wish to produce more ships?";
        }
        let c = confirm(notice);
        if (c) {
          imperium_self.playerProduceUnits(sector);
        }
        return;
      }
      imperium_self.playerProduceUnits(sector);
    }
    if (action2 == "finish") {
      if (!imperium_self.moves.includes("resolve\tplay")) { imperium_self.addMove("resolve\tplay"); }
      imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
      imperium_self.endTurn();
    }
  });
}






playerAllocateNewTokens(player, tokens, resolve_needed = 1, stage = 0, leadership_primary = 0) {

  let imperium_self = this;

  if (this.game.player == player) {

    let obj = {};
    obj.current_command = this.game.players_info[player - 1].command_tokens;
    obj.current_strategy = this.game.players_info[player - 1].strategy_tokens;
    obj.current_fleet = this.game.players_info[player - 1].fleet_supply;
    obj.new_command = 0;
    obj.new_strategy = 0;
    obj.new_fleet = 0;
    obj.new_tokens = tokens;


    let updateInterface = function (imperium_self, obj, updateInterface) {

      let html = '<div class="sf-readable">You have ' + obj.new_tokens + ' tokens to allocate. How do you want to allocate them? </div><ul>';

      if (stage == 1) {
        html = '<div class="sf-readable">The Leadership card gives you ' + obj.new_tokens + ' tokens to allocate. How do you wish to allocate them? </div><ul>';
      }
      if (stage == 2) {
        html = '<div class="sf-readable">Leadership has been played and you have purchased ' + obj.new_tokens + ' additional tokens. How do you wish to allocate them? </div><ul>';
      }
      if (stage == 3) {
        html = '<div class="sf-readable">You have ' + obj.new_tokens + ' new tokens to allocate: </div><ul>';
      }

      html += '<li class="option" id="command">Command Token - ' + (parseInt(obj.current_command) + parseInt(obj.new_command)) + '</li>';
      html += '<li class="option" id="strategy">Strategy Token - ' + (parseInt(obj.current_strategy) + parseInt(obj.new_strategy)) + '</li>';
      html += '<li class="option" id="fleet">Fleet Supply - ' + (parseInt(obj.current_fleet) + parseInt(obj.new_fleet)) + '</li>';
      html += '</ul>';

      imperium_self.updateStatus(html);
      imperium_self.lockInterface();

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "strategy") {
          obj.new_strategy++;
          obj.new_tokens--;
        }

        if (id == "command") {
          obj.new_command++;
          obj.new_tokens--;
        }

        if (id == "fleet") {
          obj.new_fleet++;
          obj.new_tokens--;
        }

        if (obj.new_tokens == 0) {
          if (resolve_needed == 1) {
            if (imperium_self.game.confirms_needed > 0 && leadership_primary == 0) {
              imperium_self.addMove("resolve\ttokenallocation\t1\t" + imperium_self.app.wallet.returnPublicKey());
            } else {
              imperium_self.addMove("resolve\ttokenallocation");
            }
          }
          imperium_self.addMove("purchase\t" + player + "\tstrategy\t" + obj.new_strategy);
          imperium_self.addMove("purchase\t" + player + "\tcommand\t" + obj.new_command);
          imperium_self.addMove("purchase\t" + player + "\tfleetsupply\t" + obj.new_fleet);
          imperium_self.unlockInterface();
          imperium_self.endTurn();
        } else {
          imperium_self.unlockInterface();
          updateInterface(imperium_self, obj, updateInterface);
        }

      });
    };

    updateInterface(imperium_self, obj, updateInterface);

  }

  return 0;
}





playerSelectPlayerWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < this.game.players_info.length; i++) {
    if (filter_func(this.game.players_info[i]) == 1) {
      html += '<li class="textchoice" id="' + (i + 1) + '">' + this.returnFaction((i + 1)) + '</li>';
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();



    let action = $(this).attr("id");

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    mycallback(action);

  });
}



playerSelectSectorWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.board) {
    if (filter_func(this.game.board[i].tile) == 1) {
      html += '<li class="textchoice" id="' + i + '">' + this.game.sectors[this.game.board[i].tile].name + '</li>';
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();


  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.showSectorHighlight(s);
    }
  });
  $('.textchoice').on('mouseleave', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.hideSectorHighlight(s);
    }
  });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");

    if (action != "cancel") {
      imperium_self.hideSectorHighlight(action);
    }

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    imperium_self.updateStatus("");
    mycallback(imperium_self.game.board[action].tile);

  });
}





playerSelectChoice(msg, choices, elect = "other", mycallback = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < choices.length; i++) {
    if (elect == "player") {
      if (this.returnFaction(choices[i]) != "Unknown") {
        html += '<li class="textchoice" id="' + i + '">' + this.returnFaction(choices[i]) + '</li>';
      } else {
        html += '<li class="textchoice" id="' + i + '">' + choices[i] + '</li>';
      }
    }
    if (elect == "planet") {
      html += '<li class="textchoice" id="' + i + '">' + this.game.planets[choices[i]].name + '</li>';
    }
    if (elect == "sector") {
      html += '<li class="textchoice" id="' + i + '">' + this.game.sectors[this.game.board[choices[i]].tile].name + '</li>';
    }
    if (elect == "other") {
      html += '<li class="textchoice" id="' + i + '">' + choices[i] + '</li>';
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    mycallback(action);

  });

}










playerSelectPlanetWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.planets) {
    if (this.game.planets[i].tile != "") {
      if (filter_func(i) == 1) {
        html += '<li class="textchoice" id="' + i + '">' + this.game.planets[i].name + '</li>';
      }
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx);
      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
    }
  });
  $('.textchoice').on('mouseleave', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx);
      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
    }
  });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    if (action != "cancel") {
      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx);
      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);
    }

    if (action == "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }

    imperium_self.updateStatus("");
    imperium_self.hideSectorHighlight(action);
    mycallback(action);

  });
}




playerSelectUnitInSectorWithFilter(msg, sector, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let unit_array = [];
  let sector_array = [];
  let planet_array = [];
  let unit_idx = [];
  let exists_unit = 0;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  let sys = this.returnSectorAndPlanets(sector);

  for (let k = 0; k < sys.s.units[imperium_self.game.player - 1].length; k++) {
    if (filter_func(sys.s.units[imperium_self.game.player - 1][k])) {
      unit_array.push(sys.s.units[imperium_self.game.player - 1][k]);
      sector_array.push(sector);
      planet_array.push(-1);
      unit_idx.push(k);
      exists_unit = 1;
      html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.name + ' - ' + unit_array[unit_array.length - 1].name + '</li>';
    }
  }

// HACK
  for (let p = 0; p < sys.p.length; p++) {
    for (let k = 0; k < sys.p[p].units[imperium_self.game.player - 1].length; k++) {
      if (filter_func(sys.p[p].units[imperium_self.game.player - 1][k])) {
        unit_array.push(sys.p[p].units[imperium_self.game.player - 1][k]);
        sector_array.push(sector);
        planet_array.push(p);
        unit_idx.push(k);
        exists_unit = 1;
        html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.sector + ' / ' + sys.p[p].name + " - " + unit_array[unit_array.length - 1].name + '</li>';
      }
    }
  }

  if (exists_unit == 0) {
    html += '<li class="textchoice" id="none">no unit available</li>';
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  //    $('.textchoice').on('mouseenter', function() { 
  //      let s = $(this).attr("id"); 
  //      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  //    $('.textchoice').on('mouseleave', function() { 
  //      let s = $(this).attr("id");
  //      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
  //    });

  this.lockInterface();

  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    //      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx); 
    //      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);

    if (action === "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }
    if (action === "none") {
      let unit_to_return = { sector: "", planet_idx: "", unit_idx: -1, unit: null }
      mycallback(unit_to_return);
      return;
    }

    let unit_to_return = { sector: sector_array[action], planet_idx: planet_array[action], unit_idx: unit_idx[action], unit: unit_array[action] }
    //      imperium_self.hideSectorHighlight(action);

    imperium_self.updateStatus("");
    mycallback(unit_to_return);

  });
}






playerSelectUnitWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let unit_array = [];
  let sector_array = [];
  let planet_array = [];
  let unit_idx = [];
  let exists_unit = 0;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.sectors) {

    let sys = this.returnSectorAndPlanets(i);
    let sector = i;

    for (let k = 0; k < sys.s.units[imperium_self.game.player - 1].length; k++) {
      if (filter_func(sys.s.units[imperium_self.game.player - 1][k])) {
        unit_array.push(sys.s.units[imperium_self.game.player - 1][k]);
        sector_array.push(sector);
        planet_array.push(-1);
        unit_idx.push(k);
        exists_unit = 1;
        html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.name + ' - ' + unit_array[unit_array.length - 1].name + '</li>';
      }
    }

    for (let p = 0; p < sys.p.length; p++) {
      for (let k = 0; k < sys.p[p].units[imperium_self.game.player - 1].length; k++) {
        if (filter_func(sys.p[p].units[imperium_self.game.player - 1][k])) {
          unit_array.push(sys.p[p].units[imperium_self.game.player - 1][k]);
          sector_array.push(sector);
          planet_array.push(p);
          unit_idx.push(k);
          exists_unit = 1;
          html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.sector + ' / ' + sys.p[p].name + " - " + unit_array[unit_array.length - 1].name + '</li>';
        }
      }
    }

  }
  if (exists_unit == 0) {
    html += '<li class="textchoice" id="none">no unit available</li>';
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  //    $('.textchoice').on('mouseenter', function() { 
  //      let s = $(this).attr("id"); 
  //      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  //    $('.textchoice').on('mouseleave', function() { 
  //      let s = $(this).attr("id");
  //      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    //      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx); 
    //      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);

    if (action === "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }
    if (action === "none") {
      let unit_to_return = { sector: "", planet_idx: "", unit_idx: -1, unit: null }
      mycallback(unit_to_return);
      return;
    }

    let unit_to_return = { sector: sector_array[action], planet_idx: planet_array[action], unit_idx: unit_idx[action], unit: unit_array[action] }
    //      imperium_self.hideSectorHighlight(action);

    imperium_self.updateStatus("");
    mycallback(unit_to_return);

  });
}





playerSelectUnitInSectorFilter(msg, sector, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < this.game.players_info.length; i++) {
    for (let ii = 0; ii < sys.s.units[i].length; ii++) {
      if (filter_func(sys.s.units[i][ii]) == 1) {
        html += '<li class="textchoice" id="' + sector + '_' + i + '_' + i + '">' + this.returnFaction((i + 1)) + " - " + sys.s.units[i][ii].name + '</li>';
      }
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action = $(this).attr("id");

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    let tmpar = action.split("_");

    let s = tmpar[0];
    let p = tmpar[1];
    let unitidx = tmpar[2];

    mycallback({ sector: s, player: p, unitidx: unitidx });

  });
}



playerDiscardActionCards(num, mycallback=null) {

  let imperium_self = this;

  if (num < 0) { imperium_self.endTurn(); }

  let html = "<div class='sf-readable'>You must discard <div style='display:inline' class='totalnum' id='totalnum'>" + num + "</div> action card"; if (num > 1) { html += 's'; }; html += ':</div>';
  html += '<ul>';
  let ac_in_hand = this.returnPlayerActionCards(imperium_self.game.player);

  for (let i = 0; i < ac_in_hand.length; i++) {
    html += '<li class="textchoice" id="' + i + '">' + this.action_cards[ac_in_hand[i]].name + '</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showActionCard(ac_in_hand[s]); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideActionCard(ac_in_hand[s]); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    num--;

    $('.totalnum').html(num);
    $(this).remove();

    imperium_self.hideActionCard(action2);
    imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(ac_in_hand[action2]);
    imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");

    if (num == 0) {

      if (mycallback == null) {
        imperium_self.updateStatus("discarding...");
        imperium_self.endTurn();
      } else {
	mycallback();
      }
    }

  });

}




/************************************
  
ACTION CARD - types

"action" -> main menu
"bombardment_attacker"
"bombardment_defender"
"combat"
"ground_combat"
"pds" -> before pds fire
"post_pds" -> after pds fire
"pre_agenda" --> before agenda voting
"post_agenda" --> after agenda voting
"space_combat"
"space_combat_victory"
"rider"


************************************/


    this.importActionCard('infiltrate', {
  	name : "Infiltrate" ,
  	type : "instant" ,
  	text : "The next time you invade a planet, you may takeover any existing PDS units or Space Docks" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_infiltrate_infrastructure_on_invasion = 1;
	  return 1;
	},
    });




    this.importActionCard('reparations', {
  	name : "Reparations" ,
  	type : "action" ,
  	text : "If you have lost a planet this round, refresh one of your planets" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.players_info[action_card_player-1].lost_planet_this_round != -1) {

	    let my_planets = imperium_self.returnPlayerExhaustedPlanetCards(imperium_self.game.player);

            imperium_self.playerSelectPlanetWithFilter(
              "Select an exhausted planet to refresh: " ,
              function(planet) {
		if (my_planets.includes(planet)) { return 1; } return 0;
              },
              function(planet) {
                imperium_self.addMove("unexhaust\tplanet\t"+planet);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player)+" refreshes " + imperium_self.game.planets[planet].name);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	    return 0;
	  }
	  return 1;
	},
    });



    this.importActionCard('political-stability', {
  	name : "Political Stability" ,
  	type : "instant" ,
  	text : "Pick a strategy card you have already played this round. You may keep this for next round" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let html = '<div class="sf-readable">Pick a Strategy Card to keep for next round: </div><ul>';
	    for (let i = 0; i < imperium_self.game.players_info[action_card_player-1].strategy_cards_played.length; i++) {
	      let card = imperium_self.game.players_info[action_card_player-1].strategy_cards_played[i];
              html += '<li class="option" id="'+card+'">' + imperium_self.strategy_cards[card].name + '</li>';
	    }
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.option').off();
	    $('.option').on('click', function() {
	      let card = $(this).attr("id");
	      imperium_self.addMove("strategy_card_retained\t"+imperium_self.game.player+"\t"+card);
	      imperium_self.endTurn();
	      return 0;
	    });

	  }

	  return 0;
	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "strategy_card_retained") {

            let player = parseInt(mv[1]);
            let card = mv[2];
            imperium_self.game.queue.splice(qe, 1);
	    imperium_self.game.players_info[player-1].strategy_cards_retained.push(card);

            return 1;
          }

	  return 1;
        }
    });



    this.importActionCard('lost-star-chart', {
  	name : "Lost Star Chart" ,
  	type : "instant" ,
  	text : "During this turn, all wormholes are adjacent to each other" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.temporary_wormholes_adjacent = 1;
	  return 1;
	},
    });


    this.importActionCard('plague', {
  	name : "Plague" ,
  	type : "action" ,
  	text : "ACTION: Select a planet. Roll a dice for each infantry on planet and destroy number of rolls 6 or higher." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet to cripple with the plague:",
              function(planet) {
		return imperium_self.doesPlanetHaveInfantry(planet);
              },
	      function(planet) {
		imperium_self.addMove("plague\t"+imperium_self.game.player+"\t"+planet);
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " unleashes a plague on " + imperium_self.game.planets[planet].name);
		imperium_self.endTurn();
		return 0;
	      },
	      null
	    );
	  }
	  return 0;
	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "plague") {

            let attacker = parseInt(mv[1]);
            let target = mv[2];
	    let sector = imperium_self.game.planets[target].sector;
	    let planet_idx = imperium_self.game.planets[target].idx;
	    let sys = imperium_self.returnSectorAndPlanets(sector);
	    let z = imperium_self.returnEventObjects();
	    let player = sys.p[planet_idx].owner;

	    let total_units_destroyed = 0;

            for (let i = 0; i < sys.p[planet_idx].units.length; i++) {
              for (let ii = 0; ii < sys.p[planet_idx].units[i].length; ii++) {
		let thisunit = sys.p[planet_idx].units[i][ii];

		if (thisunit.type == "infantry") {
		  let roll = imperium_self.rollDice(10);
		  if (roll > 6) {
		    thisunit.destroyed = 1;
		    for (z_index in z) {
		      thisunit = z[z_index].unitDestroyed(this, attacker, thisunit);
		    }
	            total_units_destroyed++;
		  }
		}
	      }
            }

	    imperium_self.updateLog("The plague destroys " + total_units_destroyed + " infantry");

            imperium_self.eliminateDestroyedUnitsInSector(player, sector);
            imperium_self.saveSystemAndPlanets(sys);
            imperium_self.updateSectorGraphics(sector);
            imperium_self.game.queue.splice(qe, 1);

            return 1;
          }

	  return 1;
        }

    });



    this.importActionCard('repeal-law', {
  	name : "Repeal Law" ,
  	type : "action" ,
  	text : "ACTION: Repeal one law that is in effect." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

	    let html = '<div class="sf-readable">Pick a Law to Repeal: </div><ul>';
	    for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	      let law = imperium_self.game.state.laws[i];
	      let agenda = imperium_self.agenda_cards[law];
              html += '<li class="option" id="'+agenda+'">' + imperium_self.agenda_cards[card].name + '</li>';
	    }
            html += '<li class="option" id="cancel">cancel</li>';
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.option').off();
	    $('.option').on('click', function() {

	      let card = $(this).attr("id");

	      if (card === "cancel") {
	        imperium_self.endTurn();
		return 0;
	      }

	      imperium_self.addMove("repeal_law\t"+card);
	      imperium_self.endTurn();
	      return 0;
	    });
          }

	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "repeal_law") {

            let card = mv[2];
            imperium_self.game.queue.splice(qe, 1);
	    for (let i = 0; i < imperium_self.game.state.laws.length; i++) {
	      if (imperium_self.game.state.laws[i] == card) {
		imperium_self.agenda_cards[card].repealAgenda(imperium_self);
	        return 1;
	      }
	    }

            return 1;
          }

	  return 1;
        }
    });



    this.importActionCard('veto', {
  	name : "Veto" ,
  	type : "action" ,
  	text : "ACTION: Select one agenda to remove from consideration and draw a replacement" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            let html = '';
            html += 'Select one agenda to quash in the Galactic Senate.<ul>';
            for (i = 0; i < 3; i++) {
              html += '<li class="option" id="'+imperium_self.game.state.agendas[i]+'">' + imperium_self.agenda_cards[imperium_self.game.state.agendas[i]].name + '</li>';
            }
            html += '</ul>';

            imperium_self.updateStatus(html);

            $('.option').off();
            $('.option').on('mouseenter', function() { let s = $(this).attr("id"); imperium_self.showAgendaCard(s); });
            $('.option').on('mouseleave', function() { let s = $(this).attr("id"); imperium_self.hideAgendaCard(s); });
            $('.option').on('click', function() {

              let agenda_to_quash = $(this).attr('id');

	      imperium_self.hideAgendaCard(agenda_to_quash);

              imperium_self.updateStatus("Quashing Agenda");
              imperium_self.addMove("quash\t"+agenda_to_quash+"\t"+"1"); // 1 = re-deal
              imperium_self.endTurn();
            });
          }

	  return 0;
        }
    });


    this.importActionCard('flank-speed1', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed2', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed3', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });
    this.importActionCard('flank-speed4', {
  	name : "Flank Speed" ,
  	type : "instant" ,
  	text : "Gain +1 movement on all ships moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_fleet_move_bonus = 1;
	  return 1;
	}
    });



    this.importActionCard('propulsion-research', {
  	name : "Propulsion Research" ,
  	type : "instant" ,
  	text : "Gain +1 movement on a single ship moved this turn" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_ship_move_bonus = 1;
	  return 1;
	}
    });




    this.importActionCard('military-drills', {
  	name : "Military Drills" ,
  	type : "action" ,
  	text : "ACTION: Gain two new command tokens" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    imperium_self.playerAllocateNewTokens(action_card_player, 2);
	  }
	  return 0;
	}
    });



    this.importActionCard('cripple-defenses', {
  	name : "Cripple Defenses" ,
  	type : "action" ,
  	text : "ACTION: Select a planet and destroy all PDS units on that planet" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet to destroy all PDS units on that planet: ",
              function(planet) {
		return imperium_self.doesPlanetHavePDS(planet);
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
		let tile = planet.tile;	        
		let planet_idx = planet.idx;
		let sys = imperium_self.returnSectorAndPlanets(sector);

		for (let b = 0; b < sys.p[planet_idx].units.length; b++) {
		  for (let bb = 0; bb < sys.p[planet_idx].units[b].length; bb++) {
		    if (sys.p[planet_idx].units[b][bb].type == "pds") {
		      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+(b+1)+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+bb+"\t"+"1");
		    }
                  }
                }

		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys all PDS units destroyed on "+sys.p[planet_idx].name);
		imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('reactor-meltdown', {
  	name : "Reactor Meltdown" ,
  	type : "action" ,
  	text : "ACTION: Select a non-homeworld planet and destroy one Space Dock on that planet" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a non-homeworld planet and destroy one Space Dock on that planet: " ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
	        if (planet.hw == 0 && imperium_self.doesPlanetHaveSpaceDock(planet)) {
		  return 1;
		}
              },
	      function(planet) {
		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
		let tile = planet.tile;	        
		let planet_idx = planet.idx;
		let sys = imperium_self.returnSectorAndPlanets(sector);

		for (let b = 0; b < sys.p[planet_idx].units.length; b++) {
		  for (let bb = 0; bb < sys.p[planet_idx].units[b].length; bb++) {
		    if (sys.p[planet_idx].units[b][bb].type == "spacedock") {
		      imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+(b+1)+"\t"+"ground"+"\t"+sector+"\t"+planet_idx+"\t"+bb+"\t"+"1");
		    }
                  }
                }

		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys all Space Docks on "+sys.p[planet_idx].name);
		imperium_self.endTurn();
		return 0;

	      },
	      // cancel -- no space dock available?
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('lost-mission', {
  	name : "Lost Mission" ,
  	type : "action" ,
  	text : "ACTION: Place 1 Destroyer in a system with no existing ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector with no existing ships in which to place a Destroyer: ",
              function(sector) {
		return !imperium_self.doesSectorContainShips(sector);
              },
	      function(sector) {

                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdestroyer\t"+sector);
                imperium_self.addMove("NOTIFY\tAdding destroyer to gamebaord");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });

    this.importActionCard('accidental-colonization', {
  	name : "Accidental Colonization" ,
  	type : "action" ,
  	text : "ACTION: Gain control of one planet not controlled by any player" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a planet not controlled by another player: ",
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner == -1) { return 1; } return 0;
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let sector = planet.sector;
                imperium_self.addMove("gain_planet\t"+imperium_self.game.player+"\t"+sector+"\t"+planet.idx);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " gains planet " + planet.name);
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('uprising', {
  	name : "Uprising" ,
  	type : "action" ,
  	text : "ACTION: Exhaust a non-home planet card held by another player. Gain trade goods equal to resource value." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Exhaust a non-homeworld planet card held by another player. Gain trade goods equal to resource value." ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner != -1 && planet.owner != imperium_self.game.player && planet.exhausted == 0 && planet.hw == 0) { return 1; } return 0;
              },
	      function(planet) {

		planet = imperium_self.game.planets[planet];
		let goods = planet.resources;

                imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+goods);
                imperium_self.addMove("expend\t"+imperium_self.game.player+"\tplanet\t"+planet.planet);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " exhausting "+planet.name + " and gaining " + goods + " trade goods");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });



    this.importActionCard('diaspora-conflict', {
  	name : "Diaspora Conflict" ,
  	type : "action" ,
  	text : "ACTION: Exhaust a non-home planet card held by another player. Gain trade goods equal to resource value." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Exhaust a planet card held by another player. Gain trade goods equal to resource value." ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
		if (planet.owner != -1 && planet.owner != imperium_self.game.player && planet.exhausted == 0 && planet.hw ==0) { return 1; } return 0;
              },
	      function(planet) {

	        let planetname = planet;
		planet = imperium_self.game.planets[planet];
		let goods = planet.resources;

                imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+goods);
                imperium_self.addMove("expend\t"+imperium_self.game.player+"\tplanet\t"+planetname);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " exhausting "+planet.name + " and gaining " + goods + " trade goods");
                imperium_self.endTurn();
		return 0;

	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });



    this.importActionCard('economic-initiative', {
  	name : "Economic Initiative" ,
  	type : "action" ,
  	text : "ACTION: Ready each cultural planet in your control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      if (imperium_self.game.planets[i].type == "cultural") {
		imperium_self.game.planets[i].exhausted = 0;
	      }
	    }
	  }
	  return 1;
	}
    });


    this.importActionCard('focused-research', {
  	name : "Focused Research" ,
  	type : "action" ,
  	text : "ACTION: Spend 4 Trade Goods to Research 1 Technology" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let p = imperium_self.game.players_info[imperium_self.game.player-1];

	  if (p.goods < 4) {
	    imperium_self.updateLog("Player does not have enough trade goods to research a technology");
	    return 1;
	  }

	  //
	  // otherwise go for it
	  //
	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerResearchTechnology(function(tech) {
              imperium_self.addMove("purchase\t"+imperium_self.game.player+"\ttech\t"+tech);
              imperium_self.addMove("expend\t"+imperium_self.game.player+"\tgoods\t4");
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " researches " + imperium_self.tech[tech].name);
              imperium_self.endTurn();
	    });

	  }
	  return 0;
	}
    });



    this.importActionCard('frontline-deployment', {
  	name : "Frontline Deployment" ,
  	type : "action" ,
  	text : "ACTION: Deploy three infantry on one planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
              "Deploy three infantry to a planet you control: ",
              function(planet) {
                if (imperium_self.game.planets[planet].owner == imperium_self.game.player) { return 1; } return 0;
              },
              function(planet) {
		planet = imperium_self.game.planets[planet];
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+planet.idx+"\t"+"infantry"+"\t"+planet.sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys three infantry to " + planet.name);
                imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
	}
    });



    this.importActionCard('ghost-ship', {
  	name : "Ghost Ship" ,
  	type : "action" ,
  	text : "ACTION: Place a destroyer in a sector with a wormhole and no enemy ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {
            imperium_self.playerSelectSectorWithFilter(
              "Place a destroyer in a sector with a wormhole and no enemy ships: " ,
              function(sector) {
                if (imperium_self.doesSectorContainShips(sector) == 0 && imperium_self.game.sectors[sector].wormhole != 0) { return 1; } return 0;
              },
              function(sector) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+"-1"+"\t"+"destroyer"+"\t"+sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys a Destroyer to " + imperium_self.game.sectors[sector].name);
               imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
        }
    });



    this.importActionCard('war-effort', {
  	name : "War Effort" ,
  	type : "action" ,
  	text : "ACTION: Place a cruiser in a sector with one of your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
              "Place a cruiser in a sector with one of your ships: " ,
              function(sector) {
                if (imperium_self.doesSectorContainPlayerShips(player, sector) == 1) { return 1; } return 0;
              },
              function(sector) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t"+"1"+"\t"+"-1"+"\t"+"cruiser"+"\t"+sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " deploys a Cruiser to " + imperium_self.game.sectors[sector].name);
                imperium_self.endTurn();
                return 0;
              },
	      function() {
		imperium_self.playerTurn();
	      }
            );
          }
          return 0;
        }
    });





    this.importActionCard('industrial-initiative', {
  	name : "Industrial Initiative" ,
  	type : "action" ,
  	text : "ACTION: Gain a trade good for each industrial planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let trade_goods_to_gain = 0;

	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      if (imperium_self.game.planets[i].type == "industrial") {
		trade_goods_to_gain++;
	      }
	    }
	  }

	  if (trade_goods_to_gain > 0 ) {
            imperium_self.game.queue.push("purchase\t"+imperium_self.game.player+"\tgoods\t"+trade_goods_to_gain);
	  }

	  return 1;
	}
    });




    this.importActionCard('Insubordination', {
  	name : "Insubordination" ,
  	type : "action" ,
  	text : "ACTION: Select a player and remove 1 token from their command pool" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player and remove one token from their command pool: " ,
              function(player) {
	        if (player != imperium_self.game.player) { return 1; } return 0;
              },
	      function(player) {
                imperium_self.addMove("expend\t"+player+"\tcommand\t"+"1");
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFactionNickname(player) + " loses one comand token");
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
        }
    });




    this.importActionCard('Lucky Shot', {
  	name : "Lucky Shot" ,
  	type : "action" ,
  	text : "ACTION: Destroy a destroyer, cruiser or dreadnaught in a sector with a planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Destroy a destroyer, cruiser or dreadnaught in a sector containing a planet you control: " ,
              function(sector) {
  		if (imperium_self.doesSectorContainPlanetOwnedByPlayer(sector, imperium_self.game.player)) {
  		  if (imperium_self.doesSectorContainUnit(sector, "destroyer") || imperium_self.doesSectorContainUnit(sector, "cruiser") || imperium_self.doesSectorContainUnit(sector, "dreadnaught")) {
		    return 1;
		  }
		}
		return 0;
              },
	      function(sector) {

                imperium_self.playerSelectUnitInSectorWithFilter(
	          "Select a ship in this sector to destroy: " ,
		  sector,
                  function(unit) {
		    if (unit.type == "destroyer") { return 1; }
		    if (unit.type == "cruiser") { return 1; }
		    if (unit.type == "dreadnaught") { return 1; }
		    return 0;
                  },
	          function(unit_info) {

		    let s = unit_info.sector;
		    let p = parseInt(unit_info.unit.owner);
		    let uidx = unit_info.unit_idx;

		    let sys = imperium_self.returnSectorAndPlanets(s);
		    let unit_to_destroy = unit_info.unit;

                    imperium_self.addMove("destroy_unit\t"+imperium_self.game.player+"\t"+unit_to_destroy.owner+"\t"+"space"+"\t"+s+"\t"+"-1"+"\t"+uidx+"\t"+"1");
		    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " destroys a " + unit_to_destroy.name + " in " + sys.name);
		    imperium_self.endTurn();
		    return 0;
	          },
	          null
	        );
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
        }
    });





    this.importActionCard('mining-initiative-ac', {
  	name : "Mining Initiative" ,
  	type : "action" ,
  	text : "ACTION: Gain trade goods equal to the highest resource value planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

   	    let maximum_resources = 0;
	    for (let i in imperium_self.game.planets) {
	      if (imperium_self.game.planets[i].owner == action_card_player && imperium_self.game.planets[i].resources > maximum_resources) {
		maximum_resources = imperium_self.game.planets[i].resources;
	      }
	    }

            imperium_self.addMove("purchase\t"+imperium_self.game.player+"\tgoods\t"+maximum_resources);
            imperium_self.endTurn();
	    return 0;

	  }
	  return 0;
	}
    });




    this.importActionCard('rise-of-a-messiah', {
  	name : "Rise of a Messiah" ,
  	type : "action" ,
  	text : "ACTION: Add one infantry to each planet player controls" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i in imperium_self.game.planets) {
	    if (imperium_self.game.planets[i].owner == action_card_player) {
	      imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " adds 1 infantry to " + imperium_self.game.planets[i].name);
	      imperium_self.addPlanetaryUnit(action_card_player, imperium_self.game.planets[i].sector, imperium_self.game.planets[i].idx, "infantry");
	    }
	  }
	  return 1;
	}
    });



    this.importActionCard('unstable-planet', {
  	name : "Unstable Planet" ,
  	type : "action" ,
  	text : "ACTION: Choose a hazardous planet and exhaust it. Destroy 3 infantry on that planet if they exist" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlanetWithFilter(
	      "Select a hazardous planet and exhaust it. Destroy 3 infantry on that planet if they exist" ,
              function(planet) {
		planet = imperium_self.game.planets[planet];
	        if (planet.type == "hazardous") { return 1; } return 0;
              },
	      function(planet) {
                imperium_self.addMove("expend\t"+player+"\tplanet\t"+planet);

		let planet_obj   = imperium_self.game.planets[planet];	
		let planet_owner = parseInt(planet_obj.owner);
		let planet_res   = parseInt(planet_obj.resources);

		let infantry_destroyed = 0;

		if (planet_owner >= 0) {
		  for (let i = 0; i < planet_obj.units[planet_owner-1].length; i++) {
		    if (infantry_destroyed < 3) {
		      if (planet_obj.units[planet_owner-1][i].type == "infantry") {
		        imperium_self.addMove("destroy_unit\t"+action_card_player+"\t"+planet_owner+"\t"+"ground"+"\t"+planet_obj.sector+"\t"+planet_obj.idx+"\t"+"1");
		    	infantry_destroyed++;
		      }
		    }
		  }
		}
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });






    this.importActionCard('Covert Operation', {
  	name : "Covert Operation" ,
  	type : "action" ,
  	text : "ACTION: Choose a player. They give you one of their action cards, if possible" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectPlayerWithFilter(
	      "Select a player. They give you one of their action cards: ",
              function(player) {
	        if (player != imperium_self.game.player) { return 1; } return 0;
              },
	      function(player) {
                imperium_self.addMove("pull\t"+imperium_self.game.player+"\t"+player+"\t"+"action"+"\t"+"random");
		imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " pulls a random action card from " + imperium_self.returnFaction(player));
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('tactical-bombardment', {
  	name : "Tactical Bombardment" ,
  	type : "action" ,
  	text : "ACTION: Choose a sector in which you have ships with bombardment. Exhaust all planets in that sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector in which you have ships with bombardment. Exhaust all planets in that sector" ,
              function(sector) {
	        if (imperium_self.doesSectorContainPlayerUnit(player, sector, "dreadnaught") == 1) { return 1; }
	        if (imperium_self.doesSectorContainPlayerUnit(player, sector, "warsun") == 1) { return 1; }
		return 0;
              },

	      function(sector) {

		let planets_in_sector = imperium_self.game.sectors[sector].planets;
		for (let i = 0; i < planets_in_sector.length; i++) {
                  imperium_self.addMove("expend\t"+player+"\tplanet\t"+planets_in_sector[i]);
		  imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " exhausts " + imperium_self.game.planets[planets_in_sector[i]].name);
		}
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('signal-jamming', {
  	name : "Signal Jamming" ,
  	type : "action" ,
  	text : "ACTION: Choose a player. They must activate a system in or next to a system in which you have a ship" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector in which you have a ship or one adjacent to one: ",
              function(sector) {
	        if (imperium_self.isPlayerShipAdjacentToSector(action_card_player, sector)) {
		  return 1;
		}
	        return 0;
              },
	      function(sector) {

            	imperium_self.playerSelectPlayerWithFilter(
	          "Select a player to signal jam in that sector: " ,
                  function(p) {
	            if (p != imperium_self.game.player) { return 1; } return 0;
                  },
	          function(p) {
                    imperium_self.addMove("activate\t"+p+"\t"+sector);
		    imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(p) + " suffers signal jamming in " + imperium_self.game.sectors[sector].name);
		    imperium_self.endTurn();
		    return 0;
	          },
	          null
	        );
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });


    this.importActionCard('unexpected-action', {
  	name : "Unexpected Action" ,
  	type : "action" ,
  	text : "ACTION: Deactivate a stystem you have activated. Gain one command or strategy token: ", 
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
	      "Select a sector that you have activated and deactivate it: " ,
              function(sector) {
		if (imperium_self.game.sectors[sector].activated[action_card_player-1] == 1) {
		  return 1;
		}
              },
	      function(sector) {
                imperium_self.addMove("purchase\t"+action_card_player+"\tcommand\t"+"1");
                imperium_self.addMove("deactivate\t"+action_card_player+"\t"+sector);
                imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " deactivates " + imperium_self.game.sectors[sector].name);
		imperium_self.endTurn();
		return 0;
	      },
	      function() {
		imperium_self.playerTurn();
	      }
	    );
	  }
	  return 0;
	}
    });




    this.importActionCard('in-the-silence-of-space', {
  	name : "In the Silence of Space" ,
  	type : "instant" ,
  	text : "Your ships may move through sectors with other player ships this turn: " ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_move_through_sectors_with_opponent_ships = 1;
	  return 1;
	}
    });



    this.importActionCard('upgrade', {
  	name : "Upgrade" ,
  	type : "activate" ,
  	text : "After you activate a system containing one of your ships, place a Dreadnaught from your reinforcements in that sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let sector = imperium_self.game.state.activated_sector;
	  if (imperium_self.doesSectorContainPlayerShips(action_card_player, sector)) {
	    imperium_self.addSpaceUnit(action_card_player, sector, "dreadnaught");
	  }

	  return 1;
	}
    });



    this.importActionCard('disable', {
  	name : "Disable" ,
  	type : "activate" ,
  	text : "Your fleet cannot be hit by PDS fire or Planetary Defense during this invasion" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].temporary_immune_to_pds_fire = 1;
	  imperium_self.game.players_info[action_card_player-1].temporary_immune_to_planetary_defense = 1;
	  return 1;
	}
    });





    this.importActionCard('bunker', {
  	name : "Bunker" ,
  	type : "bombardment_defender" ,
  	text : "During this bombardment, attacker gets -4 applied to each bombardment roll." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_bombardment_combat_roll_modifier = -4;
	  }
	  return 1;
	}
    });


    this.importActionCard('thunder-from-the-heavens', {
  	name : "Thunder from the Heavens" ,
  	type : "bombardment_attacker" ,
  	text : "During this bombardment, attacker gets +2 applied to each bombardment roll." ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  for (let i = 0; i < imperium_self.game.players_info.length; i++) {
	    imperium_self.game.players_info[i].temporary_bombardment_combat_roll_modifier = 2;
	  }
	  return 1;
	}
    });




    this.importActionCard('sabotage1', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage2', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage3', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });
    this.importActionCard('sabotage4', {
  	name : "Sabotage" ,
  	type : "counter" , 
 	text : "When another player plays an action card, you may cancel that action card" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // this runs in actioncard post...
	  //
	  for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	    if (imperium_self.game.queue[i].indexOf("action_card_") == 0) {
	      let removed_previous = 0;
	      if (imperium_self.game.queue[i].indexOf("action_card_post") == 0) { removed_previous = 1; }
	      imperium_self.game.queue.splice(i, 1);
	      if (removed_previous == 1) { return 1; }
	    }
	  }

	  return 1;
	}
    });



    this.importActionCard('fire-team', {
  	name : "Fire Team" ,
  	type : "ground_combat" ,
  	text : "Reroll up to 15 dice during this round of ground combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.players_info[action_card_player-1].combat_dice_reroll = 15; // 15 
	  return 1;

	}
    });


    this.importActionCard('parley', {
  	name : "Parley" ,
  	type : "ground_combat" ,
  	text : "Return invading infantry to space if player ships exist in the sector" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	
	  if (player == action_card_player) {

	    let sector = imperium_self.game.state.ground_combat_sector;
	    let planet_idx = imperium_self.game.state.ground_combat_planet_idx;
	    let attacker = imperium_self.game.state.ground_combat_attacker;

	    let sys = imperium_self.returnSectorAndPlanets(sector);

	    let attacker_infantry = sys.p[planet_idx].units[attacker-1];
	    sys.p[planet_idx].units[attacker-1] = [];;

	    for (let i = 0; i < sys.s.units[attacker-1].length; i++) {
	      while (imperium_self.returnRemainingCapacity(sys.s.units[attacker-1][i]) > 0 && attacker_infantry.length > 0) {
		imperium_self.loadUnitByJSONOntoShip(attacker, sector, i, JSON.stringify(attacker_infantry[0]));
	        attacker_infantry.splice(0, 1);
	      }
	    }

	  }

	  imperium_self.updateSectorGraphics(sector);
	  return 1;

	}

    });




/*****
    this.importActionCard('confusing-legal-text', {
  	name : "Confusing Legal Text" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his votes, pick another player to win if you are the leading candidate" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

//	    imperium_self.game.state.votes_cast[bribing_player-1].votes += goods_spent;

	  if (imperium_self.agenda_cards[card].elect === "player") {

            let winning_options = [];
            for (let i = 0; i < imperium_self.game.state.choices.length; i++) {
              winning_options.push(0);
            }
            for (let i = 0; i < imperium_self.game.players.length; i++) {
              winning_options[imperium_self.game.state.how_voted_on_agenda[i]] += imperium_self.game.state.votes_cast[i];
            }

            //
            // determine winning option
            //
            let max_votes_options = -1;
            let max_votes_options_idx = 0;
            for (let i = 0; i < winning_options.length; i++) {
              if (winning_options[i] > max_votes_options) {
                max_votes_options = winning_options[i];
                max_votes_options_idx = i;
              }
            }

            let total_options_at_winning_strength = 0;
            for (let i = 0; i < winning_options.length; i++) {
              if (winning_options[i] == max_votes_options) { total_options_at_winning_strength++; }
            }

	    if (total_options_at_winning_strength == 1) {

	      //
	      // cast 1000 votes for someone else
	      //
	      if (imperium_self.game.player == action_card_player) { 
                html = '<div class="sf-readable">Who do you wish to be elected instead? </div><ul>';
	        for (let i = 0; i < imperium_self.game.state.choices.length; i++) {
		  if (imperium_self.game.state.choices[i] != imperium_self.game.player) {
		    html += '<li class="options textchoice" id="'+imperium_self.game.state.choices[i]+'">'+imperium_self.returnFaction(imperium_self.game.state.choices[i])+'</li>';
		  }
	        }
		html += '</ul>';
	      }

      	      $('.textchoice').off();
	      $('.textchoice').on('click', function() {

		let action = $(this).attr("id");

		imperium_self.addMove("vote\t"+imperium_self.returnActiveAgenda()+"\t"+action+"\t"+"1000");
		imperium_self.endTurn();
		return 0;

	      });
	
	      return 0;
	    } else {
	      return 1;
	    }
	  }
	  return 1;
	}
    });
****/


    this.importActionCard('distinguished-councillor', {
  	name : "Distinguished Coucillor" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his votes, cast an additional 5 votes" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          imperium_self.game.state.votes_cast[action_card_player-1] += 5;
	  imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " casts an additional 5 votes with Distinguished Councillor");

	  return 1;

	}
    });


    this.importActionCard('bribery', {
  	name : "Bribery" ,
  	type : "post_agenda" ,
  	text : "After the speaker has cast his vote, spend any number of trade goods to purchase the same number of additional voutes" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {

	    let html  = '<div class="sf-readable">Spend any number of trade goods to purchase additional votes: </div><ul>';
	    if (imperium_self.game.players_info[action_card_player-1].goods > 0) {
	      html   += '<li class="textchoice" id="0">0 votes</li>';
	      for (let i = 1; i <= imperium_self.game.players_info[action_card_player-1].goods+1; i++) {
	        if (i == 1) { html   += '<li class="textchoice" id="1">'+i+' vote</li>'; }
	        else { html   += '<li class="textchoice" id="'+i+'">'+i+' votes</li>'; }
	      }
	    } else {
	      html   += '<li class="textchoice" id="0">0 votes</li>';
            }
	    html += '</ul>';

	    imperium_self.updateStatus(html);

	    $('.textchoice').off();
	    $('.textchoice').on('click', function() {

	      let action = $(this).attr("id");

	      imperium_self.addMove("bribery\t"+action_card_player+"\t"+action);
	      imperium_self.endTurn();
	    });

	  }

	  return 0;

	},
	handleGameLoop : function(imperium_self, qe, mv) {

	  if (mv[0] == "bribery") {

	    let bribing_player = parseInt(mv[1]);
	    let goods_spent = parseInt(mv[2]);
	    imperium_self.game.queue.splice(qe, 1);

	    imperium_self.game.state.votes_cast[bribing_player-1].votes += goods_spent;
	    imperium_self.game.players_info[bribing_player-1].goods -= goods_spent;
	    if (goods_spent == 1) {
	      imperium_self.updateLog(imperium_self.returnFaction(bribing_player) + " bribes the Council for " + goods_spent + " additional vote");
	    } else {
	      imperium_self.updateLog(imperium_self.returnFaction(bribing_player) + " bribes the Council for " + goods_spent + " additional votes");
	    }

	    return 1;
	  }

	  return 1;

	}
    });






    //
    // invisible and unwinnable rider attached to prevent voting
    //
    this.importActionCard('assassinate-representative', {
  	name : "Assassinate Representative" ,
  	type : "pre_agenda" ,
  	text : "Choose a player. That player cannot vote on the Agenda" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectPlayerWithFilter(
              "Select a player who will not be able to vote on this Agenda: " ,
              function(player) {
                if (player != imperium_self.game.player) { return 1; } return 0;
              },
              function(player) {
                imperium_self.addMove("rider\t"+player+"\tassassinate-representative\t-1");
                //imperium_self.addMove("assassinate_representative\t"+imperium_self.game.player+"\t"+player);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " assassinates the voting representative of " + imperium_self.returnFaction(player));
                imperium_self.endTurn();
                return 0;
              },
              null,
            );
	  }
	  return 0;
        },
    });




    this.importActionCard('ancient-burial-sites', {
  	name : "Ancient Burial Sites" ,
  	type : "pre_agenda" ,
  	text : "Chose a player. That player loses a maximum of four votes on this agenda" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectPlayerWithFilter(
              "Select a player to lose 4 votes: " ,
              function(player) {
                if (player != imperium_self.game.player) { return 1; } return 0;
              },
              function(player) {
                imperium_self.addMove("ancient_burial\t"+imperium_self.game.player+"\t"+player);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " finds soe dirt on the voting representative of " + imperium_self.returnFaction(player));
                imperium_self.endTurn();
                return 0;
              },
              null,
            );
	  }
	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "ancient_burial") {

            let player = parseInt(mv[1]);
            let target = parseInt(mv[2]);
            imperium_self.game.queue.splice(qe, 1);

            imperium_self.game.state.votes_available[target-1] -= 4;
            if (imperium_self.game.state.votes_available[target-1] < 0) { 
              imperium_self.game.state.votes_available[target-1] = 0;
            }

            return 1;
          }

	  return 1;
        }

    });







    this.importActionCard('leadership-rider', {
  	name : "Leadership Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to gain two strategy tokens and 1 command token" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
            let msg  = 'On which choice do you wish to place your Leadership rider?';
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"diplomacy-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium.self.game.player)+" has placed a Leadership Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
          imperium_self.game.players_info[action_card_player-1].strategy_tokens += 2;
          imperium_self.game.players_info[action_card_player-1].command_tokens += 1;
	  imperium_self.updateLog(imperium_self.returnFaction(action_card_player) + " gains 2 strategy tokens and 1 command token");
	  return 1;
	}
    });






    this.importActionCard('diplomacy-rider', {
  	name : "Diplomacy Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to have others activate system with planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg  = 'On which choice do you wish to place your Diplomacy rider?';
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"diplomacy-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Diplomacy Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {

	  //
	  // rider is executed
	  //
	  if (action_card_player == imperium_self.game.player) {

            imperium_self.playerSelectSectorWithFilter(
              "Select a sector with a planet you control to mire in diplomatic conflict: ",
              function(sector) {
		for (let i = 0; i < imperium_self.game.sectors[sector].planets.length; i++) {
  		  if (imperium_self.game.planets[imperium_self.game.sectors[sector].planets[i]].owner == imperium_self.game.player) { return 1; } return 0;
                }
              },
              function(sector) {
                for (let b = 0; b < imperium_self.game.players_info.length; b++) {
                  imperium_self.addMove("activate\t"+(b+1)+"\t"+sector);
                }
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFactionNickname(imperium_self.game.player) + " uses Diplomacy Rider to protect " + sector);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	  }
	  return 0;
	}
    });





    this.importActionCard('politics-rider', {
  	name : "Politics Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to gain three action cards and the speaker token" ,
        playActionCard : function(imperium_self, player, action_card_player, card) {
          if (imperium_self.game.player == action_card_player) {
            let active_agenda = imperium_self.returnActiveAgenda();
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;
            let msg  = 'On which choice do you wish to place your Politics rider?';
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"politics-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Politics Rider on "+choices[choice]);
              imperium_self.endTurn();
            });
          }
          return 0;
        },
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	
	  if (imperium_self.game.player == action_card_player) {

	    // three action cards
            imperium_self.addMove("gain\t"+imperium_self.game.player+"\taction_cards\t3");
            imperium_self.addMove("DEAL\t2\t"+imperium_self.game.player+"\t3");
            imperium_self.addMove("NOTIFY\tdealing two action cards to player "+player);

	    // and change speaker
	    let html = 'Make which player the speaker? <ul>';
            for (let i = 0; i < imperium_self.game.players_info.length; i++) {
              html += '<li class="textchoice" id="'+i+'">' + factions[imperium_self.game.players_info[i].faction].name + '</li>';
            }
            html += '</ul>';
            imperium_self.updateStatus(html);

            let chancellor = imperium_self.game.player;

            $('.textchoice').off();
            $('.textchoice').on('click', function() {
              let chancellor = (parseInt($(this).attr("id")) + 1);
	      imperium_self.addMove("change_speaker\t"+chancellor);
	      imperium_self.endTurn();
	    });
	  } 

 	  return 0;
	}
    });




    this.importActionCard('construction-rider', {
  	name : "Construction Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to place a space dock on a planet you control" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  if (action_card_player == imperium_self.game.player) {

            let active_agenda = imperium_self.returnActiveAgenda();
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg = 'On which choice do you wish to place the Construction rider?';
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"construction-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Construction Rider on "+choices[choice]);
              imperium_self.endTurn();
            });

	  }
	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	  if (action_card_player == imperium_self.game.player) {
            imperium_self.playerSelectPlanetWithFilter(
              "Select a planet you control without a Space Dock: ",
              function(planet) {
  		if (imperium_self.game.planets[planet].owner == imperium_self.game.player && imperium_self.doesPlanetHaveSpaceDock(planet) == 0) { return 1; } return 0;
              },
              function(planet) {
                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t"+imperium_self.game.planets[planet].idx+"\t"+"spacedock"+"\t"+imperium_self.game.planets[planet].sector);
                imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " builds a Space Dock in " + imperium_self.game.sectors[imperium_self.game.planets[planet].sector].name);
                imperium_self.endTurn();
                return 0;
              },
              null
            );
	  }
	  return 0;
	}
    });



    this.importActionCard('trade-rider', {
  	name : "Trade Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to receive 5 trade goods" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();

            let html  = 'On which choice do you wish to place your Trade rider?';
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
	    imperium_self.playerSelectChoice(html, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"trade-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Trade Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
 
 	  return 0;
	},
	playActionCardEvent(imperium_self, player, action_card_player, card) {
	  imperium_self.game.queue.push("purchase\t"+action_card_player+"\t"+"goods"+"\t"+5);
	  imperium_self.game.queue.push("NOTIFY\t"+imperium_self.returnFaction(imperium_self.game.player) + " gains 5 Trade Goods through their Trade Rider");
	  return 1;
	}
    });




    this.importActionCard('warfare-rider', {
  	name : "Warfare Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to place a dreadnaught in a system with one of your ships: " ,
        playActionCard : function(imperium_self, player, action_card_player, card) {

          if (imperium_self.game.player == action_card_player) {

            let active_agenda = imperium_self.returnActiveAgenda();

            let msg  = 'On which choice do you wish to place your Warfare Rider?';
            let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
            let elect = imperium_self.agenda_cards[active_agenda].elect;
            imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
              imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"warfare-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Warfare Rider on "+choices[choice]);
              imperium_self.endTurn();
            });
          }

          return 0;
        },
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            imperium_self.playerSelectSectorWithFilter(
              "Select a sector which contains at least one of your ships: ",
              function(sector) {
                return imperium_self.doesSectorContainPlayerShips(action_card_player, sector);
              },
              function(sector) {

                imperium_self.addMove("produce\t"+imperium_self.game.player+"\t1\t-1\tdreadnaught\t"+sector);
                imperium_self.addMove("NOTIFY\tAdding dreadnaught to board");
                imperium_self.endTurn();
                return 0;

              },
              null
            );
          }
	  return 0;
	}
    });


    this.importActionCard('technology-rider', {
  	name : "Technology Rider" ,
  	type : "rider" ,
  	text : "Bet on agenda outcome to research a technology for free" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();

            let msg  = 'On which choice do you wish to place your Technology rider?';
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"technology-rider"+"\t"+choices[choice]);
              imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed a Technology Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });
	  }
 
 	  return 0;
	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
	  if (imperium_self.game.player == action_card_player) {
	    imperium_self.playerResearchTechnology(function(tech) {
	      imperium_self.endTurn();
	    });
	  } 
 	  return 0;
	}
    });


    this.importActionCard('imperial-rider', {
  	name : "Imperial Rider" ,
  	type : "rider" ,
  	text : "Player gains 1 VP" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

	    let active_agenda = imperium_self.returnActiveAgenda();
	    let choices = imperium_self.agenda_cards[active_agenda].returnAgendaOptions(imperium_self);
	    let elect = imperium_self.agenda_cards[active_agenda].elect;

            let msg = 'On which choice do you wish to place the Imperial rider?';	
	    imperium_self.playerSelectChoice(msg, choices, elect, function(choice) {
	      imperium_self.addMove("rider\t"+imperium_self.game.player+"\t"+"imperial-rider"+"\t"+choices[choice]);
	      imperium_self.addMove("NOTIFY\t"+imperium_self.returnFactionNickname(imperium_self.game.player)+" has placed an Imperial Rider on "+choices[choice]);
	      imperium_self.endTurn();
	    });

	  }

	},
	playActionCardEvent : function(imperium_self, player, action_card_player, card) {
          imperium_self.game.players_info[action_card_player-1].vp += 1;
          imperium_self.game.players_info[action_card_player-1].objectives_scored.push("imperial-rider");
	  return 1;
	}
    });







    this.importActionCard('intercept', {
  	name : "Intercept" ,
  	type : "retreat" ,
  	text : "After your opponent declares a retreat in space combat, they cannot retreat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  imperium_self.game.players[action_card_player-1].temporary_opponent_cannot_retreat = 1;
	  return 1;

        }
    });





    this.importActionCard('courageous-to-the-end', {
  	name : "Courageous to the End" ,
  	type : "space_combat_after" ,
  	text : "For one ship lost in last round of space combat, fire twice. With each hit your opponent must destroy a ship of their chosing" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round.length > 0) {

	    let lowest_combat_roll_ship = 10;
	    for (let i = 0; i < imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round[i]; i++) {
	      let unittype = imperium_self.game.players_info[action_card_player-1].my_units_destroyed_last_combat_round[i];
	      let unit = imperium_self.returnUnit(unittype, player);
	      if (unit.combat < lowest_combat_roll_ship) { lowest_combat_roll_ship = unit.combat; }
	    }

	    let roll1 = imperium_self.rollDice(10);
	    let roll2 = imperium_self.rollDice(10);

	    let counterparty = imperium_self.game.state.space_combat_attacker;
	    if (counterparty == player) { counterparty = imperium_self.game.state.space_combat_defender; }

	    let total_ships_to_destroy = 0;

	    if (roll1 >= lowest_combat_roll_ship) {
	      total_ships_to_destroy++;
	    }
	    if (roll2 >= lowest_combat_roll_ship) {
	      total_ships_to_destroy++;
	    }

	    if (imperium_self.game.player == action_card_player) {
	      imperium_self.addMove("player_destroy_unit"+"\t"+player+"\t"+counterparty+"\t"+total_ships_to_destroy+"\t"+"space"+"\t"+imperium_self.game.state.space_combat_sector+"\t"+0);
	      imperium_self.endTurn();
	    }

	    return 0;

	  }

	  return 1;
        }
    });




    this.importActionCard('salvage', {
  	name : "Salvage" ,
  	type : "space_combat_victory" ,
  	text : "If you win a space combat, opponent gives you all their commodities" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (player == action_card_player) {

  	    let a = imperium_self.game.players_info[imperium_self.game.state.space_combat_attacker];
	    let d = imperium_self.game.players_info[imperium_self.game.state.space_combat_defender];


	    if (d.commodities > 0) {
	      a.goods += d.commodities;
	      imperium_self.updateLog(imperium_self.returnFaction(imperium_self.game.state.space_combat_attacker) + " takes " + d.commodities + " in trade goods from commodities lost in combat");
	      d.commodities = 0;
	    }
	  
	    return 1;
	  }
        }
    });



    this.importActionCard('shields-holding1', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding2', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding3', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });
    this.importActionCard('shields-holding4', {
  	name : "Shields Holding" ,
  	type : "assign_hits" ,
  	text : "Cancel 2 hits in Space Combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel+=2;
	  return 1;
	}
    });


    this.importActionCard('maneuvering-jets1', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets2', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets3', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });
    this.importActionCard('maneuvering-jets4', {
  	name : "Maneuvering Jets" ,
  	type : "post_pds" ,
  	text : "Cancel 1 hit from a PDS firing upon your ships" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {
	  imperium_self.game.state.assign_hits_to_cancel++;
	  return 1;
	}
    });



    this.importActionCard('emergency-repairs', {
  	name : "Emergency Repairs" ,
  	type : "assign_hits" ,
  	text : "Repair all damaged ships not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  //
	  // repairs all non-full-strength units for the action_card_player
	  //
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let i = 0; i < sys.s.units[action_card_player-1].length; i++) {
	    if (sys.s.units[action_card_player-1][i].strength < sys.s.units[action_card_player-1][i].max_strength) {
	      sys.s.units[action_card_player-1][i].strength = sys.s.units[action_card_player-1][i].max_strength;
	    }
	  }

	  return 1;

	}

    });

    this.importActionCard('experimental-fighter-prototype', {
  	name : "Experimental Fighter Prototype" ,
  	type : "space_combat" ,
  	text : "Your fighters get +2 on their combat rolls for a single round of space combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units[action_card_player-1].length; p++) {
            let unit = sys.s.units[action_card_player-1][p];
	    if (unit.type == "fighter") {
	      unit.temporary_combat_modifier += 2;
	    }
	  }

	  return 1;

	}

    });

    this.importActionCard('moral-boost', {
  	name : "Moral Boost" ,
  	type : "combat" ,
  	text : "Apply +1 to each of your units' combat rolls during this round of combat" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.state.space_combat_sector) {
            let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	    for (let i = 0; i < sys.s.units[action_card_player-1].length; i++) {
              let unit = sys.s.units[action_card_player-1][i];
	      unit.temporary_combat_modifier += 1;
	    }
	  }

	  if (imperium_self.game.state.ground_combat_sector) {
	    if (imperium_self.game.state.ground_combat_planet_idx) {
              let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	      for (let p = 0; i < sys.p.length; p++) {
	        for (let i = 0; i < sys.p[p].units[action_card_player-1].length; i++) {
                  let unit = sys.p[p].units[action_card_player-1][i];
	          unit.temporary_combat_modifier += 1;
	        }
	      }
	    }
	  }
	  return 1;
        }
    });



    this.importActionCard('experimental-battlestation', {
  	name : "Experimental Battlestation" ,
  	type : "pre_pds" ,
  	text : "After a player moves ships into a sector, a space dock in that or an adjacent sector can fire 3 PDS shots" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  imperium_self.updateLog("Experimental Battlestation");

	  let sector = imperium_self.game.state.activated_sector;
	  let adjacent_sectors = imperium_self.returnAdjacentSectors(sector);
	  adjacent_sectors.push(sector);

	  let has_experimental_battlestation = 0;

	  for (let n = 0; n < adjacent_sectors.length; n++) {
	    let sys = imperium_self.returnSectorAndPlanets(adjacent_sectors[n]);
	    for (let p = 0; p < sys.p.length; p++) {
	      if (sys.p[p].owner == imperium_self.game.player) {
  	        if (imperium_self.doesPlayerHaveSpaceDock(sys.p[p])) {
		  imperium_self.game.players_info[action_card_player-1].experimental_battlestation = sector;
		  return 1;
		}
	      }
	    }
	  }

	  return 1;
        }
    });










    this.importActionCard('direct-hit1', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit2', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit3', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });

    this.importActionCard('direct-hit4', {
  	name : "Direct Hit" ,
  	type : "space_combat_after" ,
  	text : "Destroy a ship that is damaged or not at full strength" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  let z = imperium_self.returnEventObjects();
          let sys = imperium_self.returnSectorAndPlanets(imperium_self.game.state.space_combat_sector);
	  for (let p = 0; p < sys.s.units.length; p++) {
	    if (p != (action_card_player-1)) {

	      for (let i = 0; i < sys.s.units[p].length; i++) {

	        if (sys.s.units[p][i].strength < sys.s.units[action_card_player-1][i].max_strength) {

	          sys.s.units[p][i].strength = 0;
	          sys.s.units[p][i].strength = 0;

                  for (let z_index in z) {
                    z[z_index].unitDestroyed(imperium_self, attacker, sys.p.units[p][i]);
                  }

	          imperium_self.eliminateDestroyedUnitsInSector((p+1), sector);
        	  imperium_self.saveSystemAndPlanets(sys);
        	  imperium_self.updateSectorGraphics(sector);

		  i = sys.s.units[p].length+2;
	        }
	      }

	    }
	  }

	  return 1;

	}
    });






    this.importActionCard('skilled-retreat1', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        },
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "skilled_retreat") {

            let player = parseInt(mv[1]);
            let destination = mv[2];
	    let source = mv[3];
            imperium_self.game.queue.splice(qe, 1);

	    let dsys = imperium_self.returnSectorAndPlanets(destination);
	    let ssys = imperium_self.returnSectorAndPlanets(source);

	    //
	    // move the units over
	    //
	    for (let i = 0; i < ssys.s.units[player-1].length; i++) {
	      dsys.s.units[player-1].push(ssys.s.units[player-1][i]);
	    }
	    ssys.s.units[player-1] = [];

	    imperium_self.saveSystemAndPlanets(dsys);
	    imperium_self.saveSystemAndPlanets(ssys);

	    //
	    // eliminate all commands down to "continue"
	    //
	    for (let i = imperium_self.game.queue.length-1; i >= 0; i--) {
	      let tmpk = imperium_self.game.queue[i].split("\t");
	      if (tmpk[0] !== "continue") {
		imperium_self.game.queue.splice(i, 1);
	      } else {
		i = -1;
	      }
	    }


	    //
	    // update sector graphics
	    //
	    imperium_self.updateSectorGraphics(ssys.s.sector);
	    imperium_self.updateSectorGraphics(dsys.s.sector);

	    //
	    // handle fleet supply
	    //
	    return imperium_self.handleFleetSupply(player, destination);

          }

          return 1;
        }

    });
    this.importActionCard('skilled-retreat2', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });
    this.importActionCard('skilled-retreat3', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });
    this.importActionCard('skilled-retreat4', {
  	name : "Skilled Retreat" ,
  	type : "space_combat" ,
  	text : "Retreat into an adjacent system without enemy ships. Space Battle ends tied" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  if (imperium_self.game.player == action_card_player) {

            let sector = imperium_self.game.state.space_combat_sector;
	    let adjacents = imperium_self.returnAdjacentSectors(sector);

            imperium_self.playerSelectSectorWithFilter(
              "Select an adjacent sector without opponent ships into which to retreat: " ,
              function(s) {
	        if (imperium_self.areSectorsAdjacent(sector, s) && s != sector) {
	          if (!imperium_self.doesSectorContainNonPlayerShips(s)) { return 1; }
	        }
	        return 0; 
              },
              function(s) {
		// from active sector into... s
	        imperium_self.addMove("skilled_retreat\t"+action_card_player+"\t"+s+"\t"+imperium_self.game.state.space_combat_sector);
	        imperium_self.addMove("NOTIFY\t"+imperium_self.returnFaction(action_card_player) + " makes skilled retreat into " + imperium_self.game.sectors[s].name);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+s);
	        imperium_self.addMove("activate\t"+action_card_player+"\t"+imperium_self.game.state.space_combat_sector);
		imperium_self.endTurn();
              },
	      function() {
		imperium_self.addMove("NOTIFY\tno suitable sectors available for skilled retreat");
		imperium_self.endTurn();
	      }
            );
          }
	  return 0;
        }
    });





    this.importActionCard('public-disgrace', {
  	name : "Public Disgrace" ,
  	type : "activate" ,
  	text : "Force a player who has already picked a strategy card to select another. They select before you do" ,
	playActionCard : function(imperium_self, player, action_card_player, card) {

	  // pick the player

	  // pick the strategy card

	  // insert the card into the strategy_cards list
	  return 0;

	},
        handleGameLoop : function(imperium_self, qe, mv) {

          if (mv[0] == "public_disgrace") {

            let player = parseInt(mv[1]);
            let target = parseInt(mv[2]);
            let card   = mv[3];
            imperium_self.game.queue.splice(qe, 1);

	    for (let i = 0; i < imperium_self.game.players_info[target-1].strategy.length; i++) {
	      if (imperium_self.game.players_info[target-1].strategy[i] == card) {
		imperium_self.game.players_info[target-1].strategy.splice(i, 1);
	      }
	    }

	    imperium_self.game.queue.push("pickstrategy\t"+player);
	    imperium_self.game.queue.push("reinsert_strategy_card\t"+card);
	    imperium_self.game.queue.push("pickstrategy\t"+target);

	    return 1;

          }

	  if (mv[0] == "reinsert_strategy_card") {

	    let card = mv[1];

            imperium_self.game.state.strategy_cards.push(card);
            imperium_self.game.state.strategy_cards_bonus.push(0);

	    return 1;

	  }
    

          return 1;
        }

    });




returnPlayers(num = 0) {

  var players = [];

  let factions = JSON.parse(JSON.stringify(this.returnFactions()));

  for (let i = 0; i < num; i++) {

    if (i == 0) { col = "color1"; }
    if (i == 1) { col = "color2"; }
    if (i == 2) { col = "color3"; }
    if (i == 3) { col = "color4"; }
    if (i == 4) { col = "color5"; }
    if (i == 5) { col = "color6"; }

    var keys = Object.keys(factions);
    let rf = keys[this.rollDice(keys.length) - 1];

    if (i == 0) {
      if (this.game.options.player1 != undefined) {
        if (this.game.options.player1 != "random") {
          rf = this.game.options.player1;
        }
      }
    }
    if (i == 1) {
      if (this.game.options.player2 != undefined) {
        if (this.game.options.player2 != "random") {
          rf = this.game.options.player2;
        }
      }
    }
    if (i == 2) {
      if (this.game.options.player3 != undefined) {
        if (this.game.options.player3 != "random") {
          rf = this.game.options.player3;
        }
      }
    }
    if (i == 3) {
      if (this.game.options.player4 != undefined) {
        if (this.game.options.player4 != "random") {
          rf = this.game.options.player4;
        }
      }
    }
    if (i == 4) {
      if (this.game.options.player5 != undefined) {
        if (this.game.options.player5 != "random") {
          rf = this.game.options.player5;
        }
      }
    }
    if (i == 5) {
      if (this.game.options.player6 != undefined) {
        if (this.game.options.player6 != "random") {
          rf = this.game.options.player6;
        }
      }
    }

    delete factions[rf];


    players[i] = {};
    players[i].can_intervene_in_action_card = 0;
    players[i].secret_objectives_in_hand = 0;
    players[i].action_cards_in_hand = 0;
    players[i].action_cards_per_round = 1;
    players[i].action_card_limit = 7;
    players[i].action_cards_played = [];
    players[i].new_tokens_per_round = 2;
    players[i].command_tokens = 3;
    players[i].strategy_tokens = 2;
    players[i].fleet_supply = 3;
    players[i].fleet_supply_limit = 16;
    players[i].faction = rf;
    players[i].homeworld = "";
    players[i].color = col;
    players[i].goods = 0;
    players[i].commodities = 0;
    players[i].commodity_limit = 3;
    players[i].vp = 0;
    players[i].passed = 0;
    players[i].strategy_cards_played = [];
    players[i].strategy_cards_retained = [];
    players[i].cost_of_technology_primary = 6;
    players[i].cost_of_technology_secondary = 4;
    players[i].promissary_notes = [];

    //
    // unit limits
    //
    players[i].infantry_limit = 30;
    players[i].fighter_limit = 30;
    players[i].carrier_limit = 4;
    players[i].destroyer_limit = 8;
    players[i].cruiser_limit = 8;
    players[i].dreadnaught_limit = 5;
    players[i].flagship_limit = 1;
    players[i].warsun_limit = 2;
    players[i].pds_limit = 4;
    players[i].spacedock_limit = 3;


    players[i].traded_this_turn = 0;


    //
    // gameplay modifiers (action cards + tech)
    //
    players[i].new_token_bonus_when_issued = 0;
    players[i].action_cards_bonus_when_issued = 0;
    players[i].new_tokens_bonus_when_issued = 0;
    players[i].fleet_move_bonus = 0;
    players[i].temporary_fleet_move_bonus = 0;
    players[i].ship_move_bonus = 0;
    players[i].temporary_ship_move_bonus = 0;
    players[i].fly_through_asteroids = 0;
    players[i].fly_through_nebulas = 0;
    players[i].fly_through_supernovas = 0;
    players[i].move_into_supernovas = 0;
    players[i].reinforce_infantry_after_successful_ground_combat = 0;
    players[i].bacterial_weapon = 0;
    players[i].evasive_bonus_on_pds_shots = 0;
    players[i].perform_two_actions = 0;
    players[i].move_through_sectors_with_opponent_ships = 0;
    players[i].temporary_move_through_sectors_with_opponent_ships = 0;
    players[i].assign_pds_hits_to_non_fighters = 0;
    players[i].reallocate_four_infantry_per_round = 0;
    players[i].may_produce_after_gaining_planet = 0;
    players[i].extra_roll_on_bombardment_or_pds = 0;
    players[i].stasis_on_opponent_combat_first_round = 0;
    players[i].may_repair_damaged_ships_after_space_combat = 0;
    players[i].may_assign_first_round_combat_shot = 0;
    players[i].production_bonus = 0;
    players[i].may_player_produce_without_spacedock = 0;
    players[i].may_player_produce_without_spacedock_production_limit = 0;
    players[i].may_player_produce_without_spacedock_cost_limit = 0;
    players[i].may_produce_warsuns = 0;

    //
    // must target certain units when assigning hits, if possible
    //
    players[i].target_units = [];
    players[i].planets_conquered_this_turn = [];
    players[i].objectives_scored_this_round = [];
    players[i].must_exhaust_at_round_start = [];


    //
    // faction-inspired gameplay modifiers 
    //
    players[i].deep_space_conduits = 0; // treat all systems adjacent to activated system
    players[i].resupply_stations = 0; // gain trade goods on system activation if contains ships 
    players[i].turn_nullification = 0; // after player activates system with ships, can end turn ...

    //
    // roll modifiers
    //
    players[i].space_combat_roll_modifier = 0;
    players[i].ground_combat_roll_modifier = 0;
    players[i].pds_combat_roll_modifier = 0;
    players[i].bombardment_combat_roll_modifier = 0;
    players[i].space_combat_roll_bonus_shots = 0;
    players[i].ground_combat_roll_bonus_shots = 0;
    players[i].pds_combat_roll_bonus_shots = 0;
    players[i].bombardment_combat_roll_bonus_shots = 0;

    players[i].ground_combat_dice_reroll = 0;
    players[i].space_combat_dice_reroll = 0;
    players[i].pds_combat_dice_reroll = 0;
    players[i].bombardment_combat_dice_reroll = 0;
    players[i].combat_dice_reroll = 0;

    players[i].temporary_immune_to_pds_fire = 0;
    players[i].temporary_immune_to_planetary_defense = 0;

    players[i].temporary_space_combat_roll_modifier = 0;
    players[i].temporary_ground_combat_roll_modifier = 0;
    players[i].temporary_pds_combat_roll_modifier = 0;
    players[i].temporary_bombardment_combat_roll_modifier = 0;

    players[i].units_i_destroyed_this_combat_round = [];
    players[i].units_i_destroyed_last_combat_round = [];
    players[i].my_units_destroyed_this_combat_round = [];
    players[i].my_units_destroyed_last_combat_round = [];

    //
    // tech upgrades
    //
    players[i].temporary_green_tech_prerequisite = 0;
    players[i].temporary_yellow_tech_prerequisite = 0;
    players[i].temporary_red_tech_prerequisite = 0;
    players[i].temporary_blue_tech_prerequisite = 0;
    players[i].permanent_green_tech_prerequisite = 0;
    players[i].permanent_yellow_tech_prerequisite = 0;
    players[i].permanent_red_tech_prerequisite = 0;
    players[i].permanent_blue_tech_prerequisite = 0;
    players[i].temporary_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 0;
    players[i].permanent_ignore_number_of_tech_prerequisites_on_nonunit_upgrade = 0;
    players[i].temporary_infiltrate_infrastructure_on_invasion = 0;
    players[i].permanent_infiltrate_infrastructure_on_invasion = 0;
    players[i].temporary_opponent_cannot_retreat = 0;
    players[i].permanent_opponent_cannot_retreat = 0;
    players[i].permanent_research_technology_card_must_not_spend_resources = 0;

    if (i == 1) { players[i].color = "yellow"; }
    if (i == 2) { players[i].color = "green"; }
    if (i == 3) { players[i].color = "blue"; }
    if (i == 4) { players[i].color = "purple"; }
    if (i == 5) { players[i].color = "black"; }

    players[i].planets = [];
    players[i].tech = [];
    players[i].tech_exhausted_this_turn = [];
    players[i].upgrades = [];
    players[i].strategy = [];        // strategy cards  

    // scored objectives
    players[i].objectives_scored = [];


    // random
    players[i].lost_planet_this_round = -1; // is player to whom lost

  }

  return players;

}








playerTurn(stage = "main") {

  let html = '';
  let imperium_self = this;
  let technologies = this.returnTechnology();
  let relevant_action_cards = ["action", "main", "instant"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  this.updateLeaderboard();
  this.updateTokenDisplay();

  if (stage == "main") {

    let playercol = "player_color_" + this.game.player;

    let html = '';
    html += '<div class="terminal_header2 sf-readable"><div class="player_color_box ' + playercol + '"></div>' + this.returnFaction(this.game.player) + ":</div><p><ul class='terminal_header3'>";

    if (this.canPlayerPass(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 1) {
        //
        // if we have already moved, we end turn rather than pass
        //
        html += '<li class="option" id="endturn">end turn</li>';
      } else {
        //
        // otherwise we pass
        //
        html += '<li class="option" id="pass">pass</li>';
      }
    } else {
      if (this.game.state.active_player_moved == 1) {
        //
        // if we have already moved, we end turn rather than pass
        //
        html += '<li class="option" id="endturn">end turn</li>';
      }
    }

    if (this.game.state.round == 1 && this.game.state.active_player_moved == 0) {
      if (this.tutorial_move_clicked == 0) {
        html += '<li class="option" id="tutorial_move_ships">move ships</li>';
      }
      if (this.tutorial_produce_clicked == 0) {
        html += '<li class="option" id="tutorial_produce_units">produce units</li>';
      }
    }

    if (this.game.players_info[this.game.player - 1].command_tokens > 0) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="activate">activate sector</li>';
      }
    }
    if (this.canPlayerPlayStrategyCard(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="select_strategy_card">play strategy card</li>';
      }
    }
    if (ac.length > 0 && this.game.tracker.action_card == 0 && this.canPlayerPlayActionCard(this.game.player) == 1) {
      if (this.game.state.active_player_moved == 0) {
        html += '<li class="option" id="action">play action card</li>';
      }
    }
    if (this.game.tracker.trade == 0 && this.canPlayerTrade(this.game.player) == 1) {
      html += '<li class="option" id="trade">trade</li>';
    }

    //
    // add tech and factional abilities
    //
    let tech_attach_menu_events = 0;
    let tech_attach_menu_triggers = [];
    let tech_attach_menu_index = [];
    let z = this.returnEventObjects();

    if (this.game.state.active_player_moved == 0) {
      for (let i = 0; i < z.length; i++) {
        if (z[i].menuOptionTriggers(this, "main", this.game.player) == 1) {
          let x = z[i].menuOption(this, "main", this.game.player);
          html += x.html;
          tech_attach_menu_index.push(i);
          tech_attach_menu_triggers.push(x.event);
          tech_attach_menu_events = 1;
        }
      }
    }



    html += '</ul></p>';

    this.updateStatus(html);

    $('.option').on('click', function () {

      let action2 = $(this).attr("id");

      //
      // respond to tech and factional abilities
      //
      if (tech_attach_menu_events == 1) {
        for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
          if (action2 == tech_attach_menu_triggers[i]) {
            $(this).remove();
            imperium_self.game.state.active_player_moved = 1;
            z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "main", imperium_self.game.player);
            return;
          }
        }
      }

      if (action2 == "activate") {
        imperium_self.playerActivateSystem();
      }

      if (action2 == "tutorial_move_ships") {
        imperium_self.tutorial_move_clicked = 1;
        imperium_self.playerAcknowledgeNotice("To move ships select \"activate sector\". Be careful as most ships can only move 1-hexagon and you cannot move ships from sectors that are already activated. You will be able to choose the ships to move, and load infantry and fighters into units that can carry them.", function () {
          imperium_self.playerTurn();
        });
        return;
      }
      if (action2 == "tutorial_produce_units") {
        imperium_self.tutorial_produce_clicked = 1;
        imperium_self.playerAcknowledgeNotice("To produce units, select \"activate sector\" and activate a sector with a space dock (like your home system). You can only have as many non-fighter ships in any sector as your fleet supply, so move your ships out before producing more!", function () {
          imperium_self.playerTurn();
        });
        return;
      }

      if (action2 == "select_strategy_card") {
        imperium_self.playerSelectStrategyCard(function (success) {
          imperium_self.game.state.active_player_moved = 1;
          imperium_self.addMove("strategy_card_after\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.addMove("strategy\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.addMove("strategy_card_before\t" + success + "\t" + imperium_self.game.player + "\t1");
          imperium_self.endTurn();
        });
      }
      if (action2 == "action") {
        imperium_self.playerSelectActionCard(function (card) {
          if (imperium_self.action_cards[card].type == "action") { imperium_self.game.state.active_player_moved = 1; }
          imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
          imperium_self.endTurn();
        }, function () { imperium_self.playerTurn(); },
          relevant_action_cards);
      }
      if (action2 == "trade") {
        imperium_self.playerTrade();
        return 0;
      }
      if (action2 == "pass") {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
        imperium_self.addMove("pass\t" + imperium_self.game.player);
        imperium_self.endTurn();
      }
      if (action2 == "endturn") {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
        imperium_self.addMove("player_end_turn\t" + imperium_self.game.player);
        imperium_self.endTurn();
      }
    });
  }
}




playerPlayActionCardMenu(action_card_player, card, action_cards_played = []) {

  let imperium_self = this;
  let relevant_action_cards = ["counter"];

  for (let i = 0; i < this.game.deck[1].hand.length; i++) {
    if (this.game.deck[1].hand[i].indexOf("sabotage") > -1) {
      this.game.players_info[this.game.player - 1].can_intervene_in_action_card = 1;
    }
  }

  if (this.game.players_info[this.game.player - 1].can_intervene_in_action_card) {

    let html = '<div class="action_card_instructions_hud">' + this.returnFaction(action_card_player) + ' has played an action card:</div>';
    html += '<div class="action_card_name_hud">' + imperium_self.action_cards[card].name + '</div>';
    html += '<div class="action_card_text_hud">';
    html += this.action_cards[card].text;
    html += '</div>';
    html += '<ul>';

    let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);
    if (ac.length > 0) {
      html += '<li class="option" id="cont">continue</li>';
      html += '<li class="option" id="action">play action card</li>';
    } else {
      html += '<li class="option" id="cont">continue</li>';
    }

    let tech_attach_menu_events = 0;
    let tech_attach_menu_triggers = [];
    let tech_attach_menu_index = [];

    let z = this.returnEventObjects();
    for (let i = 0; i < z.length; i++) {
      if (z[i].menuOptionTriggers(this, "action_card", this.game.player) == 1) {
        let x = z[i].menuOption(this, "action_card", this.game.player);
        html += x.html;
        tech_attach_menu_index.push(i);
        tech_attach_menu_triggers.push(x.event);
        tech_attach_menu_events = 1;
      }
    }
    html += '</ul>';

    this.updateStatus(html);

    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");

      //
      // respond to tech and factional abilities
      //
      if (tech_attach_menu_events == 1) {
        for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
          if (action2 == tech_attach_menu_triggers[i]) {
            $(this).remove();
            z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "action_card", imperium_self.game.player);
          }
        }
      }

      if (action2 == "action") {
        imperium_self.playerSelectActionCard(function (card) {
          imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(card);
          imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
          imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
          imperium_self.playerPlayActionCardMenu(action_card_player, card);
        }, function () {
          imperium_self.playerPlayActionCardMenu(action_card_player, card);
        }, relevant_action_cards);
      }

      if (action2 == "cont") {
        imperium_self.endTurn();
      }
      return 0;
    });

  } else {

    let notice = '<div class="action_card_instructions_hud">' + this.returnFaction(action_card_player) + ' has played an action card:</div>';
    notice += '<div class="action_card_name_hud">' + imperium_self.action_cards[card].name + '</div>';
    notice += '<div class="action_card_text_hud">';
    notice += this.action_cards[card].text;
    notice += '</div>';

    this.playerAcknowledgeNotice(notice, function () { imperium_self.endTurn(); });
    return 0;
  }

}





playerPlayBombardment(attacker, sector, planet_idx) {

  let imperium_self = this;

  this.game.state.bombardment_sector = sector;
  this.game.state.bombardment_planet_idx = planet_idx;

  let sys = imperium_self.returnSectorAndPlanets(sector);


  //
  // some laws prohibit bombardment against
  //
  if (this.game.state.bombardment_against_cultural_planets == 0 && sys.p[planet_idx].type == "cultural") {
    this.updateLog("Bombardment not possible against cultural planets. Skipping.");
    this.endTurn();
  }
  if (this.game.state.bombardment_against_industrial_planets == 0 && sys.p[planet_idx].type == "industrial") {
    this.updateLog("Bombardment not possible against industrial planets. Skipping.");
    this.endTurn();
  }
  if (this.game.state.bombardment_against_hazardous_planets == 0 && sys.p[planet_idx].type == "hazardous") {
    this.updateLog("Bombardment not possible against hazardous planets. Skipping.");
    this.endTurn();
  }
  //
  // no bombardment of my own planets (i.e. if parlay ends invasion)
  //
  if (sys.p[planet_idx].owner == imperium_self.game.player) {
    imperium_self.endTurn();
    return 0;
  }
  //
  // no bombardment of PDS-defended territories
  //
  if (this.doesPlanetHavePDS(sys.p[planet_idx])) {
    this.updateLog("Bombardment not possible against PDS-defended planets. Skipping.");
    imperium_self.endTurn();
    return 0;
  }

  html = '<div class="sf-readable">Do you wish to bombard ' + sys.p[planet_idx].name + '? </div><ul>';

  let ac = this.returnPlayerActionCards(this.game.player, ["pre_bombardment"]);
  if (ac.length > 0) {
    html += '<li class="option" id="bombard">bombard planet</li>';
    html += '<li class="option" id="action">play action card</li>';
    html += '<li class="option" id="skip">skip bombardment</li>';
  } else {
    html += '<li class="option" id="bombard">bombard planet</li>';
    html += '<li class="option" id="skip">skip bombardment</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pre_bombardment", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pre_bombardment", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pre_bombardment", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.game.players_info[this.game.player - 1].action_cards_played.push(card);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, function () {
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, ["pre_bombardment"]);
    }

    if (action2 == "bombard") {
      imperium_self.addMove("bombard\t" + imperium_self.game.player + "\t" + sector + "\t" + planet_idx);
      imperium_self.endTurn();
    }
    if (action2 == "skip") {
      imperium_self.endTurn();
    }
    return 0;
  });


}


playerAcknowledgeNotice(msg, mycallback) {

  let html = '<div class="sf-readable">' + msg + "</div><ul>";
  html += '<li class="textchoice" id="confirmit">I understand...</li>';
  html += '</ul></p>';

  this.updateStatus(html);

  try {
  $('.textchoice').off();
  $('.textchoice').on('click', function () { mycallback(); });
  } catch (err) {}

  return 0;

}

//
// assign hits to capital ships without triggering events or special abilities
//  -- this is used by special abilities that assign damage outside combat, where they
//  -- cannot be removed by normal factional abilities, etc.
//
 playerAssignHitsCapitalShips(player, sector, total_hits) {

  let imperium_self = this;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let total_targetted_units = 0;

  let targetted_units = ["destroyer","cruiser","carrier","dreadnaught","warsun","flagship"];

  html = '<div class="sf-readable">You must assign ' + total_hits + ' to your capital ships (if possible):</div><ul>';
  html += '<li class="option" id="assign">continue</li>';
  html += '</ul>';
  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "assign") {

      let sys = imperium_self.returnSectorAndPlanets(sector);

      let html = '';
      html += '<div class="sf-readable">Assign <div style="display:inline" id="total_hits_to_assign">' + total_hits + '</div> hits:</div>';
      html += '<ul>';

      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].destroyed == 0 && sys.s.units[imperium_self.game.player - 1][i].strength > 0) {

          let unit = sys.s.units[imperium_self.game.player - 1][i];
          maximum_assignable_hits++;
          if (targetted_units.includes(unit.type)) { total_targetted_units++; }
          html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name;
          if (unit.capacity >= 1) {
	    let fleet = '';
            let fighters = 0;
            let infantry = 0;
            for (let ii = 0; ii < sys.s.units[imperium_self.game.player-1][i].storage.length; ii++) {
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "infantry") {
                infantry++;
              }
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
                fighters++;
              }
            }
            if (infantry > 0 || fighters > 0) {
              fleet += ' ';
              if (infantry > 0) { fleet += infantry + "i"; }
              if (fighters > 0) {
                if (infantry > 0) { fleet += ", "; }
                fleet += fighters + "f";
              }
              fleet += ' ';
            }
	    html += fleet;
	  }
          if (unit.strength > 1) {
            maximum_assignable_hits += (unit.strength - 1);
            html += ' <div style="display:inline" id="player_ship_' + i + '_hits">(';
            for (let bb = 1; bb < unit.strength; bb++) { html += '*'; }
            html += ')';
	    html += '</div>'
          }
          html += '</li>';
        }

      }
      html += '</ul>';

      if (maximum_assignable_hits == 0) {
        imperium_self.endTurn();
        return 0;
      }

      imperium_self.updateStatus(html);

      $('.textchoice').off();
      $('.textchoice').on('click', function () {

        let ship_idx = $(this).attr("id");
        let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

        if (total_targetted_units > 0) {
          if (!targetted_units.includes(selected_unit.type)) {
            salert("You must first assign hits to the required unit types");
            return;
          } else {
            total_targetted_units--;
          }
        }

        imperium_self.addMove("assign_hit\t" + player + "\t" + player + "\t" + imperium_self.game.player + "\tship\t" + sector + "\t" + ship_idx + "\t0"); // last argument --> player should not assign again 


        total_hits--;
        hits_assigned++;

        $('#total_hits_to_assign').innerHTML = total_hits;

        if (selected_unit.strength > 1) {
          selected_unit.strength--;
          let ship_to_reduce = "#player_ship_" + ship_idx + '_hits';
          let rhtml = '';
          if (selected_unit.strength > 1) {
            html += '(';
            for (let bb = 1; bb < selected_unit.strength; bb++) {
              rhtml += '*';
            }
            rhtml += ')';
          }
          $(ship_to_reduce).html(rhtml);
        } else {
          selected_unit.strength = 0;
          selected_unit.destroyed = 0;
          $(this).remove();
        }

        //
        // we have assigned damage, so make sure sys is updated
        //
        imperium_self.saveSystemAndPlanets(sys);

        if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
          imperium_self.updateStatus("Notifying players of hits assignment...");
          imperium_self.endTurn();
          imperium_self.updateStatus("Hits taken...");
        }

      });
    }

  });

}



//
// assign hits to my forces
//
 playerAssignHits(attacker, defender, type, sector, details, total_hits, source = "") {

  let imperium_self = this;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let relevant_action_cards = ["assign_hits"];
  if (details == "pds") { relevant_action_cards = ["post_pds"]; }

  html = '<div class="sf-readable">You must assign ' + total_hits + ' to your fleet:</div><ul>';

  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);
  if (ac.length > 0) {
    html += '<li class="option" id="assign">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="assign">continue</li>';
  }

  let menu_type = "";
  if (details == "pds") { menu_type = "assign_hits_pds"; }
  if (menu_type == "" && type == "space") { menu_type = "assign_hits_space"; }
  if (type == "ground") { menu_type = "assign_hits_ground"; }
  if (type == "anti_fighter_barrage") { menu_type = "assign_hits_anti_fighter_barrage"; }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, menu_type, this.game.player) == 1) {
      let x = z[i].menuOption(this, menu_type, this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          let mytech = this.tech[imperium_self.game.players_info[imperium_self.game.player - 1].tech[tech_attach_menu_index]];
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, menu_type, imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove(imperium_self.game.state.assign_hits_queue_instruction);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
        imperium_self.updateStatus("playing action card before hits assignment");
      }, function () {
        imperium_self.playerAssignHits(attacker, defender, type, sector, details, total_hits, source);
      }, relevant_action_cards);
    }

    if (action2 == "assign") {

      if (imperium_self.game.state.assign_hits_to_cancel > 0) {
        total_hits -= imperium_self.game.state.assign_hits_to_cancel;
        if (total_hits < 0) { total_hits = 0; }
        if (total_hits == 0) {
          imperium_self.updateLog("NOTIFY\t" + imperium_self.returnFactionNickname(imperium_self.game.player) + " does not take any hits");
          imperium_self.endTurn();
          return 0;
        }
      }

      let sys = imperium_self.returnSectorAndPlanets(sector);

      let html = '';
      html += '<div class="sf-readable">Assign <div style="display:inline" id="total_hits_to_assign">' + total_hits + '</div> hits:</div>';
      html += '<ul>';

      let total_targetted_units = 0;
      let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;
      if (type == "anti_fighter_barrage") {
	//
	// overwrite
	//
	targetted_units = [	"fighter", "fighter", "fighter" , "fighter" , "fighter" , 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter", 
				"fighter" , "fighter" , "fighter" , "fighter" , "fighter" ];
      }

      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].destroyed == 0 && sys.s.units[imperium_self.game.player - 1][i].strength > 0) {

          let unit = sys.s.units[imperium_self.game.player - 1][i];
          maximum_assignable_hits++;
          if (targetted_units.includes(unit.type)) { total_targetted_units++; }
          html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name;
          if (unit.capacity >= 1) {
	    let fleet = '';
            let fighters = 0;
            let infantry = 0;
            for (let ii = 0; ii < sys.s.units[imperium_self.game.player-1][i].storage.length; ii++) {
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "infantry") {
                infantry++;
              }
              if (sys.s.units[imperium_self.game.player-1][i].storage[ii].type == "fighter") {
                fighters++;
              }
            }
            if (infantry > 0 || fighters > 0) {
              fleet += ' ';
              if (infantry > 0) { fleet += infantry + "i"; }
              if (fighters > 0) {
                if (infantry > 0) { fleet += ", "; }
                fleet += fighters + "f";
              }
              fleet += ' ';
            }
	    html += fleet;
	  }
          if (unit.strength > 1) {
            maximum_assignable_hits += (unit.strength - 1);
            html += ' <div style="display:inline" id="player_ship_' + i + '_hits">(';
            for (let bb = 1; bb < unit.strength; bb++) { html += '*'; }
            html += ')';
	    html += '</div>'
          }
          html += '</li>';
        }

      }
      html += '</ul>';

      if (maximum_assignable_hits == 0) {
        console.log("ERROR: you had no hits left to assign, bug?");
        console.log("SHIPS: " + JSON.stringify(sys.s.units[imperium_self.game.player - 1]));
//        imperium_self.eliminateDestroyedUnitsInSector(imperium_self.game.player, sector);
//        imperium_self.saveSystemAndPlanets(sys);
//        imperium_self.updateSectorGraphics(sector);
        imperium_self.endTurn();
        return 0;
      }

      imperium_self.updateStatus(html);

      $('.textchoice').off();
      $('.textchoice').on('click', function () {

        let ship_idx = $(this).attr("id");
        let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

        if (total_targetted_units > 0) {
          if (!targetted_units.includes(selected_unit.type)) {
            salert("You must first assign hits to the required unit types");
            return;
          } else {
            total_targetted_units--;
          }
        }

        imperium_self.addMove("assign_hit\t" + attacker + "\t" + defender + "\t" + imperium_self.game.player + "\tship\t" + sector + "\t" + ship_idx + "\t0"); // last argument --> player should not assign again 

        total_hits--;
        hits_assigned++;

        $('#total_hits_to_assign').innerHTML = total_hits;

        if (selected_unit.strength > 1) {
          selected_unit.strength--;
          let ship_to_reduce = "#player_ship_" + ship_idx + '_hits';
          let rhtml = '';
          if (selected_unit.strength > 1) {
            html += '(';
            for (let bb = 1; bb < selected_unit.strength; bb++) {
              rhtml += '*';
            }
            rhtml += ')';
          }
          $(ship_to_reduce).html(rhtml);
        } else {
          selected_unit.strength = 0;
          selected_unit.destroyed = 0;
          $(this).remove();
        }

        //
        // we have assigned damage, so make sure sys is updated
        //
        imperium_self.saveSystemAndPlanets(sys);

        if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
          imperium_self.updateStatus("Notifying players of hits assignment...");
          imperium_self.endTurn();
          imperium_self.updateStatus("Hits taken...");
        }

      });
    }

  });
}





//
// destroy units
//
playerDestroyUnits(player, total, sector, capital = 0) {

  let imperium_self = this;
  let total_hits = total;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  html = '<div class="sf-readable">You must destroy ' + total + ' units in sector: ' + imperium_self.game.sectors[sector].name + ':</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
    let unit = sys.s.units[imperium_self.game.player - 1][i];
    maximum_assignable_hits++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  for (let p = 0; i < sys.p.length; p++) {
    for (let i = 0; i < sys.p[p].units[imperium_self.game.player - 1].length; i++) {
      let unit = sys.p[p].units[imperium_self.game.player - 1][i];
      maximum_assignable_hits++;
      if (targetted_units.includes(unit.type)) { total_targetted_units++; }
      html += '<li class="textchoice player_unit_' + p + '_' + i + '" id="ground_unit_' + p + '_' + i + '">' + unit.name + '</li>';
    }
  }
  html += '</ul>';

  if (maximum_assignable_hits == 0) {
    this.addMove("NOTIFY\t" + this.returnFaction(player) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }


  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {


    let ship_idx = $(this).attr("id");
    let planet_idx = 0;
    let unit_idx = 0;
    let unit_type = "ship";

    if (ship_idx.indexOf("_unit_") > 0) {
      unit_type = "ground";
      let tmpk = ship_idx.split("_");
      planet_idx = tmpk[1];
      unit_idx = tmpk[2];

    }

    let selected_unit = null;
    if (unit_type == "ship") {
      selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];
    } else {
      selected_unit = sys.p[planet_idx].units[imperium_self.game.player - 1][unit_idx];
    }

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    if (unit_type == "ship") {
      imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");
    } else {
      imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "ground\t" + sector + "\t" + planet_idx + "\t" + unit_idx + "\t1");
    }

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total_hits--;
    hits_assigned++;

    if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
      imperium_self.updateStatus("Notifying players of units destroyed...");
      imperium_self.endTurn();
    }

  });
}





//
// destroy ships
//
playerDestroyShips(player, total, sector, capital = 0) {

  let imperium_self = this;
  let total_hits = total;
  let hits_assigned = 0;
  let maximum_assignable_hits = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  html = '<div class="sf-readable">You must destroy ' + total + ' ships in your fleet:</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
    let unit = sys.s.units[imperium_self.game.player - 1][i];
    maximum_assignable_hits++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  html += '</ul>';

  if (maximum_assignable_hits == 0) {
    this.addMove("NOTIFY\t" + this.returnFaction(player) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }


  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let ship_idx = $(this).attr("id");
    let selected_unit = sys.s.units[imperium_self.game.player - 1][ship_idx];

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    imperium_self.addMove("destroy_unit\t" + player + "\t" + player + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total_hits--;
    hits_assigned++;

    if (total_hits == 0 || hits_assigned >= maximum_assignable_hits) {
      imperium_self.updateStatus("Notifying players of hits assignment...");
      imperium_self.endTurn();
    }

  });
}


//
// destroy opponent ships (not assigning hits)
//
playerDestroyOpponentShips(player, total, sector, capital = 0) {

  let imperium_self = this;
  let ships_destroyed = 0;
  let maximum_destroyable_ships = 0;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  let opponent = imperium_self.returnOpponentInSector(player, sector);

  if (opponent == -1) {
    this.addMove("NOTIFY\t" + this.returnFactionNickname(opponent) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }

  html = '<div class="sf-readable">You may destroy ' + total + ' ships in opponent fleet:</div><ul>';

  let total_targetted_units = 0;
  let targetted_units = imperium_self.game.players_info[imperium_self.game.player - 1].target_units;

  if (capital == 1) {
    targetted_units = [];
    targetted_units.push("destroyer");
    targetted_units.push("carrier");
    targetted_units.push("destroyer");
    targetted_units.push("cruiser");
    targetted_units.push("dreadnaught");
    targetted_units.push("warsun");
    targetted_units.push("flagship");
  }

  for (let i = 0; i < sys.s.units[opponent-1].length; i++) {
    let unit = sys.s.units[opponent-1][i];
    maximum_destroyable_ships++;
    if (targetted_units.includes(unit.type)) { total_targetted_units++; }
    html += '<li class="textchoice player_ship_' + i + '" id="' + i + '">' + unit.name + '</li>';
  }
  html += '</ul>';

  if (maximum_destroyable_ships == 0) {
    this.addMove("NOTIFY\t" + this.returnFactionNickname(opponent) + " has no ships to destroy");
    this.endTurn();
    return 0;
  }

  imperium_self.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

   let ship_idx = $(this).attr("id");
    let selected_unit = sys.s.units[opponent - 1][ship_idx];

    if (total_targetted_units > 0) {
      if (!targetted_units.includes(selected_unit.type)) {
        salert("You must first destroy the required unit types");
        return;
      } else {
        total_targetted_units--;
      }
    }

    imperium_self.addMove("destroy_unit\t" + player + "\t" + opponent + "\t" + "space\t" + sector + "\t" + "0" + "\t" + ship_idx + "\t1");

    selected_unit.strength = 0;;
    selected_unit.destroyed = 0;
    $(this).remove();

    total--;
    ships_destroyed++;

    if (total == 0 || ships_destroyed >= maximum_destroyable_ships) {
      imperium_self.updateStatus("Notifying players of destroyed ships...");
      imperium_self.endTurn();
    }

  });
}








//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlaySpaceCombat(attacker, defender, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let html = '';
  let relevant_action_cards = ["space_combat"];
  if (this.game.state.space_combat_round > 1) {
    relevant_action_cards.push("space_combat_post");
  }

  let opponent = attacker;
  if (imperium_self.game.player == attacker) { opponent = defender; }

  this.game.state.space_combat_sector = sector;

  html = '<div class="sf-readable"><b>Space Combat: round ' + this.game.state.space_combat_round + ':</b><div class="combat_attacker">' + this.returnFaction(attacker) + '</div><div class="combat_attacker_fleet">' + this.returnPlayerFleetInSector(attacker, sector) + '</div><div class="combat_defender">' + this.returnFaction(defender) + '</div><div class="combat_defender_fleet">' + this.returnPlayerFleetInSector(defender, sector) + '</div><ul>';

  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards)
  if (ac.length > 0) {
    html += '<li class="option" id="attack">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="attack">continue</li>';
  }

  //
  // can I retreat
  //
  if (this.canPlayerRetreat(imperium_self.game.player, attacker, defender, sector)) {
    html += '<li class="option" id="retreat">announce retreat</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "space_combat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "space_combat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }, function () {
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }, relevant_action_cards);
    }

    if (action2 == "attack") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.prependMove("ships_fire\t" + attacker + "\t" + defender + "\t" + sector);
      imperium_self.endTurn();
    }

    if (action2 == "retreat") {
      if (imperium_self.canPlayerRetreat(imperium_self.game.player, attacker, defender, sector)) {
        let retreat_options = imperium_self.returnSectorsWherePlayerCanRetreat(imperium_self.game.player, sector);

        let html = '<div clss="sf-readable">Retreat into which Sector? </div><ul>';
        for (let i = 0; i < retreat_options.length; i++) {
	  let sys = imperium_self.returnSectorAndPlanets(retreat_options[i]);
          html += '<li class="option" id="' + i + '">' + sys.s.name + '</li>';
        }
        html += '</ul>';

        imperium_self.updateStatus(html);

        $('.option').off();
        $('.option').on('click', function () {

          let opt = $(this).attr("id");
          let retreat_to_sector = retreat_options[opt];

          imperium_self.addMove("announce_retreat\t" + imperium_self.game.player + "\t" + opponent + "\t" + sector + "\t" + retreat_to_sector);
          imperium_self.endTurn();
          return 0;
        });


      } else {
        imperium_self.playerPlaySpaceCombat(attacker, defender, sector);
      }
    }

  });
}




playerRespondToRetreat(player, opponent, from, to) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(to);
  let relevant_action_cards = ["retreat"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);

  let html = '<div class="sf-readable">Your opponent has announced a retreat into ' + sys.s.name + ' at the end of this round of combat: </div><p></p><ul>';
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  html += '<li class="option" id="permit">permit retreat</li>';
  html += '</ul>';

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "retreat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "retreat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';


  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerRespondToRetreat(player, opponent, from, to);
      }, function () {
        imperium_self.playerRespondToRetreat(player, opponent, from, to);
      }.relevant_action_cards);
    }


    if (action2 == "permit") {
      imperium_self.endTurn();
    }
  });
}






//
// ground combat is over -- provide options for scoring cards, action cards
//
playerPlayGroundCombatOver(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let relevant_action_cards = ["ground_combat_victory", "ground_combat_over", "ground_combat_loss"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);

  let html = '';
  let win = 0;

  if (player == sys.p[planet_idx].owner) {
    html = '<div class="sf-readable">Ground Combat is Over (you win): </div><ul>';
    win = 1;
  } else {
    html = '<div class="sf-readable">Space Combat is Over (you lose): </div><ul>';
  }

  if (ac.length > 0) {
    html += '<li class="option" id="ok">acknowledge</li>';
    html += '<li class="option" id="action">action card</li>';
  } else {
    html += '<li class="option" id="ok">acknowledge</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "ground_combat_over", this.game.player) == 1) {
      let x = z[i].menuOption(this, "ground_combat_over", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 === "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayGroundCombatOver(player, sector, planet_idx);
      }, function () {
        imperium_self.playerPlayGroundCombatOver(player, sector, planet_idx);
      });
    }

    if (action2 === "ok") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.endTurn();
    }

  });
}




//
// space combat is over -- provide options for scoring cards, action cards
//
playerPlaySpaceCombatOver(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let relevant_action_cards = ["space_combat_victory", "space_combat_over", "space_combat_loss"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);
  let html = '';
  let win = 0;

  if (this.doesPlayerHaveShipsInSector(player, sector)) {
    html = '<div class="sf-readable">Space Combat is Over (you win): </div><ul>';
    win = 1;
  } else {
    html = '<div class="sf-readable">Space Combat is Over (you lose): </div><ul>';
  }

  if (ac.length > 0) {
    html += '<li class="option" id="ok">acknowledge</li>';
    html += '<li class="option" id="action">action card</li>';
  } else {
    html += '<li class="option" id="ok">acknowledge</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "space_combat_over", this.game.player) == 1) {
      let x = z[i].menuOption(this, "space_combat_over", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "space_combat_over", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlaySpaceCombatOver(player, sector, planet_idx);
      }, function () {
        imperium_self.playerPlaySpaceCombatOver(player, sector, planet_idx);
      });
    }

    if (action2 === "ok") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.endTurn();
    }

  });
}







//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayGroundCombat(attacker, defender, sector, planet_idx) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);
  let html = '';

  this.game.state.ground_combat_sector = sector;
  this.game.state.ground_combat_planet_idx = planet_idx;

  let attacker_forces = this.returnNumberOfGroundForcesOnPlanet(attacker, sector, planet_idx);
  let defender_forces = this.returnNumberOfGroundForcesOnPlanet(defender, sector, planet_idx);

  if (sys.p[planet_idx].owner != attacker) {
    html = '<div class="sf-readable">'+this.returnFactionNickname(attacker)+' are invading ' + sys.p[planet_idx].name + ' with ' + attacker_forces + ' infantry. ' + this.returnFactionNickname(defender) + ' is defending with ' + defender_forces + ' infantry. This is round ' + this.game.state.ground_combat_round + ' of ground combat. </div><ul>';
  } else {
    html = '<div class="sf-readable">' + this.returnFactionNickname(defender) + ' are invading ' + sys.p[planet_idx].name + ' with ' + defender_forces + ' infantry. You have ' + attacker_forces + ' infantry remaining. This is round ' + this.game.state.ground_combat_round + ' of ground combat. </div><ul>';
  }

  let ac = this.returnPlayerActionCards(this.game.player, ["combat", "ground_combat"])
  if (ac.length > 0) {
    html += '<li class="option" id="attack">continue</li>';
    html += '<li class="option" id="action">play action card</li>';
  } else {
    html += '<li class="option" id="attack">continue</li>';
  }


  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "ground_combat", this.game.player) == 1) {
      let x = z[i].menuOption(this, "ground_combat", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "ground_combat", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayGroundCombat(attacker, defender, sector, planet_idx);
      }, function () {
        imperium_self.playerPlayGroundCombat(attacker, defender, sector, planet_idx);
      });
    }

    if (action2 == "attack") {
      // prepend so it happens after the modifiers
      //
      // ships_fire needs to make sure it permits any opponents to fire...
      //
      imperium_self.prependMove("infantry_fire\t" + attacker + "\t" + defender + "\t" + sector + "\t" + planet_idx);
      imperium_self.endTurn();
    }

  });
}







//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPDSAttack(player, attacker, sector) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_pds"];
  let can_target_with_pds_fire = 1;

  let defender = -1;
  let sys = imperium_self.returnSectorAndPlanets(sector);

  for (let i = 0; i < sys.s.units.length; i++) {
    if ((i + 1) != attacker) {
      if (sys.s.units[i].length > 0) {
        defender = (i + 1);
      }
    }
  }

  html = '<div class="sf-readable">Do you wish to fire your PDS before moving into the sector?</div><ul>';

  //
  // skip if attacker is immune
  //
  if (defender != -1) {
    if (imperium_self.game.players_info[defender - 1].temporary_immune_to_pds_fire) {
      html = '<div class="sf-readable">' + imperium_self.returnFaction(defender) + ' cannot be targeted by PDS fire during this invasion:</div><ul>';
      can_target_with_pds_fire = 0;
    }
  } else {
    html = '<div class="sf-readable">You cannot target any ships with PDS fire and must skip firing:</div><ul>';
    can_target_with_pds_fire = 0;
  }


  let ac = this.returnPlayerActionCards(player, relevant_action_cards);
  if (1 == 1) {
    html += '<li class="option" id="skip">skip PDS</li>';
  }
  if (can_target_with_pds_fire == 1) {
    html += '<li class="option" id="fire">fire PDS</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pds", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pds", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pds", imperium_self.game.player);
        }
      }
    }


    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPDSAttack(player, attacker, sector);
      }, function () {
        imperium_self.playerPlayPDSAttack(player, attacker, sector);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

    if (action2 == "fire") {
      // prepend so it happens after the modifiers -- defender instead of attacker here
      imperium_self.prependMove("pds_fire\t" + imperium_self.game.player + "\t" + defender + "\t" + sector);
      imperium_self.endTurn();
    };

  });

}


//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPDSDefense(player, attacker, sector) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_pds"];
  let can_target_with_pds_fire = 1;

  html = '<div class="sf-readable">Do you wish to fire your PDS?</div><ul>';

  //
  // skip if attacker is immune
  //
  if (imperium_self.game.players_info[attacker - 1].temporary_immune_to_pds_fire) {
    html = '<div class="sf-readable">Your attacker cannot be targeted by PDS fire during this invasion:</div><ul>';
    can_target_with_pds_fire = 0;
  }


  let ac = this.returnPlayerActionCards(player, relevant_action_cards);
  if (1 == 1) {
    html += '<li class="option" id="skip">skip PDS</li>';
  }
  if (can_target_with_pds_fire == 1) {
    html += '<li class="option" id="fire">fire PDS</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pds", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pds", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "pds", imperium_self.game.player);
        }
      }
    }


    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPDSDefense(player, attacker, sector);
      }, function () {
        imperium_self.playerPlayPDSDefense(player, attacker, sector);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

    if (action2 == "fire") {
      // prepend so it happens after the modifiers
      imperium_self.prependMove("pds_fire\t" + imperium_self.game.player + "\t" + attacker + "\t" + sector);
      imperium_self.endTurn();
    };

  });

}


//
// reaching this implies that the player can choose to fire / not-fire
//
playerResolveDeadlockedAgenda(agenda, choices) {

  let imperium_self = this;
  let html = '';

  html = '<div class="sf-readable">The agenda has become deadlocked in the Senate. You - the Speaker - must resolve it: </div><ul>';
  for (let i = 0; i < choices.length; i++) {
    html += '<li class="option" id="' + i + '">' + this.returnNameFromIndex(choices[i]) + '</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    imperium_self.addMove("resolve_agenda\t" + agenda + "\tspeaker\t" + choices[action2]);
    imperium_self.endTurn();
    return 0;

  });
}




//
// reaching this implies that the player can choose to fire / not-fire
//
playerPlayPreAgendaStage(player, agenda, agenda_idx) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["pre_agenda", "rider"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  if (this.doesPlayerHaveRider(imperium_self.game.player)) {
    html = '<div class="sf-readable">With your riders depending on how the other factions vote, your emissaries track the mood in the Senate closely...:</div><ul>';
  } else {
    html = '<div class="sf-readable">As the Senators gather to vote on ' + this.agenda_cards[agenda].name + ', your emissaries nervously tally the votes in their head:</div><ul>';
  }

  if (1 == 1) {
    html += '<li class="option" id="skip">proceed into Senate</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "pre_agenda", this.game.player) == 1) {
      let x = z[i].menuOption(this, "pre_agenda", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "agenda", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPreAgendaStage(player, agenda, agenda_idx);
      }, function () {
        imperium_self.playerPlayPreAgendaStage(player, agenda, agenda_idx);
      }, ["pre_agenda", "rider"]);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

  });

}
playerPlayPostAgendaStage(player, agenda, array_of_winning_options) {

  let imperium_self = this;
  let html = '';
  let relevant_action_cards = ["post_agenda"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);

  if (array_of_winning_options.length > 0) {
    html = '<div class="sf-readable">The Senate has apparently voted for "' + this.returnNameFromIndex(array_of_winning_options[0]) + '". As the Speaker confirms the final tally, you get the feeling the issue may not be fully settled:</div><ul>';
  } else {
    html = '<div class="sf-readable">No-one in the Senate bothered to show-up and vote, leaving the matter to be decided by the Speaker:</div><ul>';
  }
  if (array_of_winning_options.length > 1) {
    html = '<div class="sf-readable">The voting has concluded in deadlock. The Speaker must resolve the agenda:</div><ul>';
  }

  if (1 == 1) {
    html += '<li class="option" id="skip">await results</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">action card</li>';
  }

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "post_agenda", this.game.player) == 1) {
      let x = z[i].menuOption(this, "post_agenda", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "post_agenda", imperium_self.game.player);
        }
      }
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.playerPlayPostAgendaStage(player, agenda, array_of_winning_options);
      }, function () {
        imperium_self.playerPlayPostAgendaStage(player, agenda, array_of_winning_options);
      }, relevant_action_cards);
    }

    if (action2 == "skip") {
      imperium_self.endTurn();
    }

  });

}



playerContinueTurn(player, sector) {

  let imperium_self = this;
  let options_available = 0;

  if (this.game.tracker.invasion == undefined) { this.game.tracker = this.returnPlayerTurnTracker(); this.game.tracker.activate_system = 1; }

  //
  // check to see if any ships survived....
  //
  let playercol = "player_color_" + this.game.player;
  let html = "<div class='sf-readable'><div class='player_color_box " + playercol + "'></div>" + this.returnFaction(player) + ": </div><ul>";

  if (this.canPlayerScoreActionStageVictoryPoints(player) != "") {
    html += '<li class="option" id="score">score secret objective</li>';
    options_available++;
  }
  if (this.canPlayerProduceInSector(player, sector) && this.game.tracker.production == 0) {
    html += '<li class="option" id="produce">produce units</li>';
    options_available++;
  }

  if (this.canPlayerInvadePlanet(player, sector) && this.game.tracker.invasion == 0) {
    if (sector == "new-byzantium" || sector == "4_4") {
      if ((imperium_self.game.planets['new-byzantium'].owner != -1) || (imperium_self.returnAvailableInfluence(imperium_self.game.player) + imperium_self.game.players_info[imperium_self.game.player - 1].goods) >= 6) {
        html += '<li class="option" id="invade">invade planet</li>';
        options_available++;
      }
    } else {
      html += '<li class="option" id="invade">invade planet</li>';
      options_available++;
    }
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">reassign infantry</li>';
    options_available++;
  }
  if (this.game.tracker.trade == 0 && this.canPlayerTrade(this.game.player) == 1) {
    html += '<li class="option" id="trade">trade</li>';
  }

  //if (this.canPlayerPlayActionCard(player) && this.game.tracker.action_card == 0) {
  //  html += '<li class="option" id="action">action card</li>';
  //  options_available++;
  //}

  let tech_attach_menu_events = 0;
  let tech_attach_menu_triggers = [];
  let tech_attach_menu_index = [];

  let z = this.returnEventObjects();
  for (let i = 0; i < z.length; i++) {
    if (z[i].menuOptionTriggers(this, "continue", this.game.player) == 1) {
      let x = z[i].menuOption(this, "continue", this.game.player);
      html += x.html;
      tech_attach_menu_index.push(i);
      tech_attach_menu_triggers.push(x.event);
      tech_attach_menu_events = 1;
    }
  }

  html += '<li class="option" id="endturn">end turn</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    //
    // respond to tech and factional abilities
    //
    if (tech_attach_menu_events == 1) {
      for (let i = 0; i < tech_attach_menu_triggers.length; i++) {
        if (action2 == tech_attach_menu_triggers[i]) {
          $(this).remove();
          z[tech_attach_menu_index[i]].menuOptionActivated(imperium_self, "continue", imperium_self.game.player);
        }
      }
    }

    if (action2 == "endturn") {
      imperium_self.addMove("resolve\tplay");
      imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
      imperium_self.endTurn();
      return 0;
    }

    if (action2 == "trade") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerTurn();
      return 0;
    }

    if (action2 == "land") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerSelectInfantryToLand(sector);
      return 0;
    }

    if (action2 == "produce") {

      //
      // check the fleet supply and NOTIFY users if they are about to surpass it
      //
      let fleet_supply_in_sector = imperium_self.returnSpareFleetSupplyInSector(imperium_self.game.player, sector);
      if (fleet_supply_in_sector <= 1) {
        let notice = "You have no spare fleet supply in this sector. Do you still wish to produce more ships?";
        if (fleet_supply_in_sector == 1) {
          notice = "You have fleet supply for 1 additional capital ship in this sector. Do you still wish to produce more ships?";
        }
        let c = sconfirm(notice);
        if (c) {
          imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
          imperium_self.playerProduceUnits(sector);
        }
        return;
      }
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerProduceUnits(sector);
    }

    if (action2 == "invade") {

      //
      // New Byzantium requires 6 influence to conquer
      //
      if (sector === "new-byzantium" || sector == "4_4") {
        if (imperium_self.game.planets['new-byzantium'].owner == -1) {
          if (imperium_self.returnAvailableInfluence(imperium_self.game.player) >= 6) {
            imperium_self.playerSelectInfluence(6, function (success) {
              imperium_self.game.tracker.invasion = 1;
              imperium_self.playerInvadePlanet(player, sector);
            });
          } else {
            salert("The first conquest of New Byzantium requires spending 6 influence, which you lack.");
            return;
          }
          return;
        }
      }

      imperium_self.game.tracker.invasion = 1;
      imperium_self.playerInvadePlanet(player, sector);
    }

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.game.tracker.action_card = 1;
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
      }, function () {
        imperium_self.playerContinueTurn(player, sector);
        return;
      });
    }

    if (action2 == "score") {
      imperium_self.playerScoreActionStageVictoryPoints(imperium_self, function (imperium_self, vp, objective) {
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
        if (vp > 0) { imperium_self.addMove("score\t" + imperium_self.game.player + "\t" + vp + "\t" + objective); }
        imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.push(objective);
        imperium_self.endTurn();
        return;
      });
    }
  });
}





////////////////
// Production //
////////////////
playerBuyTokens(stage = 0, resolve = 1) {

  let imperium_self = this;

  if (this.returnAvailableInfluence(this.game.player) <= 2) {
    this.updateLog("You skip the initiative secondary, as you lack adequate influence...");
    this.updateStatus("Skipping purchase of tokens as insufficient influence...");
    if (resolve == 1) {
      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
    }
    this.endTurn();
    return 0;
  }

  let html = '<div class="sf-readable">Do you wish to purchase any command or strategy tokens, or increase your fleet supply?</div><ul>';

  if (stage == 2) {
    html = '<div class="sf-readable">Leadership has been played. Do you wish to purchase any additional command or strategy tokens, or increase your fleet supply?</div><ul>';
    if (imperium_self.game.state.round == 1)  {
      html = `The Leadership strategy card has been played. This lets you spend 3 influence to purchase additional command tokens, strategy tokens or fleet supply. Do you wish to purchase any additional tokens: </p><ul>`;
    }
  }

  html += '<li class="buildchoice textchoice" id="skip">Do Not Purchase</li>';
  html += '<li class="buildchoice textchoice" id="command">Command Tokens  +<span class="command_total">0</span></li>';
  html += '<li class="buildchoice textchoice" id="strategy">Strategy Tokens +<span class="strategy_total">0</span></li>';
  html += '<li class="buildchoice textchoice" id="fleet">Fleet Supply  +<span class="fleet_total">0</span></li>';
  html += '</ul></p>';
  html += '';
  html += '<div id="buildcost" class="buildcost"><span class="buildcost_total">0</span> influence</div>';
  html += '<div id="confirm" class="buildchoice">click here to finish</div>';

  this.updateStatus(html);


  let command_tokens = 0;
  let strategy_tokens = 0;
  let fleet_supply = 0;
  let total_cost = 0;

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let id = $(this).attr("id");

    if (id == "skip") {
      if (resolve == 1) {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      }
      imperium_self.endTurn();
      return;
    }

    if (id == "confirm") {

      total_cost = 3 * (fleet_supply + command_tokens + strategy_tokens);

      if (resolve == 1) {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
        imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      }

      imperium_self.playerSelectInfluence(total_cost, function (success) {

        if (success == 1) {
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tcommand\t" + command_tokens);
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tcommand\t" + strategy_tokens);
          imperium_self.addMove("purchase\t" + imperium_self.game.player + "\tfleetsupply\t" + fleet_supply);
          imperium_self.endTurn();
          return;
        } else {
          imperium_self.endTurn();
        }
      });
    };

    //
    //  figure out if we need to load infantry / fighters
    //
    if (id == "command") { command_tokens++; }
    if (id == "strategy") { strategy_tokens++; }
    if (id == "fleet") { fleet_supply++; }

    let divtotal = "." + id + "_total";
    let x = parseInt($(divtotal).html());
    x++;
    $(divtotal).html(x);

    total_cost = 3 * (command_tokens + strategy_tokens + fleet_supply);
    $('.buildcost_total').html(total_cost);


    let return_to_zero = 0;
    if (total_cost > imperium_self.returnAvailableInfluence(imperium_self.game.player)) {
      salert("You cannot buy more tokens than you have influence available to pay");
      return_to_zero = 1;
    }
    if (return_to_zero == 1) {
      total_cost = 0;
      command_tokens = 0;
      strategy_tokens = 0;
      fleet_supply = 0;
      $('.command_total').html(0);
      $('.strategy_total').html(0);
      $('.fleet_total').html(0);
      return;
    }

  });
}





 playerBuyActionCards(stage = 0, resolve = 1) {

  let imperium_self = this;

  let html = '<div class="sf-readable">Do you wish to spend 1 strategy token to purchase 2 action cards?</div><ul>';
  if (stage == 2) {
    html = '<div class="sf-readable">Politics has been played: do you wish to spend 1 strategy token to purchase 2 action cards?</div><ul>';
    if (imperium_self.game.state.round == 1) {
      html = `${imperium_self.returnFaction(imperium_self.game.player)} has played the Politics strategy card. This lets you to spend 1 strategy token to purchase 2 action cards, which provide special one-time abilities. You have ${imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens} strategy tokens. Purchase action cards: </p><ul>`;
    }
  }
  html += '<li class="buildchoice textchoice" id="yes">Purchase Action Cards</li>';
  html += '<li class="buildchoice textchoice" id="no">Do Not Purchase Action Cards</li>';
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let id = $(this).attr("id");

    if (id == "yes") {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.addMove("NOTIFY\t" + imperium_self.returnFaction(imperium_self.game.player) + " gets action cards");
      imperium_self.addMove("gain\t" + imperium_self.game.player + "\taction_cards\t2");
      imperium_self.addMove("DEAL\t2\t" + imperium_self.game.player + "\t2");
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    } else {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    }
  });

 }




 playerBuySecretObjective(stage = 0, resolve = 1) {

  let imperium_self = this;

  let html = '<div class="sf-readable">Do you wish to spend 1 strategy token to purchase a Secret Objective?</div><ul>';
  if (stage == 2) {
    html = '<div class="sf-readable">The Imperial Strategy card has been played: do you wish to spend 1 strategy token to purchase a Secret Objective?</div><ul>';
    if (imperium_self.game.state.round == 1) {
      html = `${imperium_self.returnFaction(imperium_self.game.player)} has played the Imperial strategy card. This lets you to spend 1 strategy token to purchase an additional secret bjective. You have ${imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens} strategy tokens. Purchase secret objective: </p><ul>`;
    }
  }
  html += '<li class="buildchoice textchoice" id="yes">Purchase Secret Objective</li>';
  html += '<li class="buildchoice textchoice" id="no">Do Not Purchase</li>';
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let id = $(this).attr("id");

    if (id == "yes") {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.addMove("gain\t" + imperium_self.game.player + "\tsecret_objective\t1");
      imperium_self.addMove("DEAL\t6\t" + imperium_self.game.player + "\t1");
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    } else {

      imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
      imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
      imperium_self.endTurn();
      imperium_self.updateStatus("submitted...");
      return;

    }
  });

}





playerResearchTechnology(mycallback) {

  let imperium_self = this;
  let html = '<div class="sf-readable">You are eligible to upgrade to the following technologies: </div><ul>';

  for (var i in this.tech) {
    if (this.canPlayerResearchTechnology(i)) {
      html += '<li class="option" id="' + i + '">' + this.tech[i].name + '</li>';
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showTechCard(s); });
  $('.option').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideTechCard(s); });
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let i = $(this).attr("id");
    imperium_self.hideTechCard(i);

    //
    // handle prerequisites
    //
    imperium_self.exhaustPlayerResearchTechnologyPrerequisites(i);
    mycallback($(this).attr("id"));

  });

}


//
// return string if YES, empty string if NO
//
canPlayerScoreActionStageVictoryPoints(player) {

  let imperium_self = this;
  let html = "";

  //
  // Secret Objectives - Action Phase
  //
  for (let i = 0; i < imperium_self.game.deck[5].hand.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (imperium_self.secret_objectives[imperium_self.game.deck[5].hand[i]].phase === "action") {
          html += '<li class="option secret3" id="' + imperium_self.game.deck[5].hand[i] + '">' + imperium_self.secret_objectives[imperium_self.game.deck[5].hand[i]].name + '</li>';
        }
      }
    }
  }

  return html;

}




playerScoreActionStageVictoryPoints(imperium_self, mycallback, stage = 0) {

  let html = '';
  let player = imperium_self.game.player;

  html += '<div class="sf-readable">Do you wish to score a secret objective? </div><ul>';

  html += this.canPlayerScoreActionStageVictoryPoints(player);
  html += '<li class="option cancel" id="cancel">cancel</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);
  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    let objective_type = 3;

    if ($(this).hasClass("stage1")) { objective_type = 1; }
    if ($(this).hasClass("stage2")) { objective_type = 2; }
    if ($(this).hasClass("secret3")) { objective_type = 3; }

    if (action === "no") {
      mycallback(imperium_self, 0, "");

    } else {

      let objective = action;
      let vp = 1;
      if (imperium_self.secret_objectives[objective]) {
        if (imperium_self.secret_objectives[objective].vp > 1) { vp = imperium_self.stage_ii_objectives[objective].vp; }
      }

      mycallback(imperium_self, vp, objective);

    }
  });
}



canPlayerScoreVictoryPoints(player, card = "", deck = 1) {

  if (card == "") { return 0; }

  let imperium_self = this;

  // deck 1 = primary
  // deck 2 = secondary
  // deck 3 = secret

  if (deck == 1) {
    let objectives = this.returnStageIPublicObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  if (deck == 2) {
    let objectives = this.returnStageIIPublicObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  if (deck == 3) {
    let objectives = this.returnSecretObjectives();
    if (objectives[card] != "") {
      if (objectives[card].canPlayerScoreVictoryPoints(imperium_self, player) == 1) { return 1; }
    }
  }

  return 0;

}




playerScoreSecretObjective(imperium_self, mycallback, stage = 0) {

  let html = '';
  let can_score = 0;

  html += '<div class="sf-readable">Do you wish to score any Secret Objectives? </div><ul>';

  // Secret Objectives
  for (let i = 0; i < imperium_self.game.deck[5].hand.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.deck[5].hand[i])) {
          can_score = 1;
          html += '1 VP Secret Objective: <li class="option secret3" id="' + imperium_self.game.deck[5].hand[i] + '">' + imperium_self.game.deck[5].cards[imperium_self.game.deck[5].hand[i]].name + '</li>';
        }
      }
    }
  }

  html += '<li class="option" id="no">I choose not to score...</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);

  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    if (action == "no") {
      mycallback(imperium_self, 0, "");
    } else {
      let objective = action;
      let vp = 1;
      if (imperium_self.secret_objectives[objective]) {
        if (imperium_self.secret_objectives[objective].vp > 1) { vp = imperium_self.secret_objectives[objective].vp; }
      }
      mycallback(imperium_self, vp, objective);
    }
  });
}


playerScoreVictoryPoints(imperium_self, mycallback, stage = 0) {

  let html = '';
  html += '<div class="sf-readable">Do you wish to score any public objectives? </div><ul>';

  // Stage I Public Objectives
  for (let i = 0; i < imperium_self.game.state.stage_i_objectives.length; i++) {

    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.state.stage_i_objectives[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.state.stage_i_objectives[i], 1)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.state.stage_i_objectives[i])) {
          html += '1 VP Public Objective: <li class="option stage1" id="' + imperium_self.game.state.stage_i_objectives[i] + '">' + imperium_self.game.deck[3].cards[imperium_self.game.state.stage_i_objectives[i]].name + '</li>';
        }
      }
    }
  }

  // Stage II Public Objectives
  for (let i = 0; i < imperium_self.game.state.stage_ii_objectives.length; i++) {
    if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored.includes(imperium_self.game.state.stage_ii_objectives[i])) {
      if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.state.stage_ii_objectives[i], 2)) {
        if (!imperium_self.game.players_info[imperium_self.game.player - 1].objectives_scored_this_round.includes(imperium_self.game.state.stage_ii_objectives[i])) {
          html += '2 VP Public Objective: <li class="option stage2" id="' + imperium_self.game.state.stage_ii_objectives[i] + '">' + imperium_self.game.deck[4].cards[imperium_self.game.state.stage_ii_objectives[i]].name + '</li>';
        }
      }
    }
  }

  /***
      // Secret Objectives
      for (let i = 0 ; i < imperium_self.game.deck[5].hand.length; i++) {
        if (!imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored.includes(imperium_self.game.deck[5].hand[i])) {
          if (imperium_self.canPlayerScoreVictoryPoints(imperium_self.game.player, imperium_self.game.deck[5].hand[i], 3)) {
        if (!imperium_self.game.players_info[imperium_self.game.player-1].objectives_scored_this_round.includes(imperium_self.game.deck[5].hand[i])) {
              html += '1 VP Secret Objective: <li class="option secret3" id="'+imperium_self.game.deck[5].hand[i]+'">'+imperium_self.game.deck[5].cards[imperium_self.game.deck[5].hand[i]].name+'</li>';
            }
          }
        }
      }
  ***/

  html += '<li class="option" id="no">I choose not to score...</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);
  imperium_self.lockInterface();

  $('.option').off();
  $('.option').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    let objective_type = 3;

    if ($(this).hasClass("stage1")) { objective_type = 1; }
    if ($(this).hasClass("stage2")) { objective_type = 2; }
    if ($(this).hasClass("secret3")) { objective_type = 3; }

    if (action === "no") {
      mycallback(imperium_self, 0, "");
    } else {
      let objective = action;
      let vp = 1;
      if (imperium_self.stage_ii_objectives[objective]) {
        if (imperium_self.stage_ii_objectives[objective].vp > 1) { vp = imperium_self.stage_ii_objectives[objective].vp; }
      }
      mycallback(imperium_self, vp, objective);

    }
  });
}




 playerBuildInfrastructure(mycallback, stage = 1) {

  let imperium_self = this;

  let html = '';

  if (stage == 1) { html += "<div class='sf-readable'>Which would you like to build: </div><ul>"; }
  else { html += "<div class='sf_readable'>You may also build an additional PDS: </div><ul>"; }

  html += '<li class="buildchoice" id="pds">Planetary Defense System</li>';
  if (stage == 1) {
    html += '<li class="buildchoice" id="spacedock">Space Dock</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  let stuff_to_build = [];

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showUnit(s); });
  $('.buildchoice').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideUnit(s); });
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();
    $('.buildchoice').off();

    let id = $(this).attr("id");

    imperium_self.playerSelectPlanetWithFilter(
      "Select a planet on which to build: ",
      function (planet) {
        let existing_units = 0;
        if (imperium_self.game.planets[planet].owner == imperium_self.game.player) {
          for (let i = 0; i < imperium_self.game.planets[planet].units[imperium_self.game.player - 1].length; i++) {
            if (imperium_self.game.planets[planet].units[imperium_self.game.player - 1][i].type == id) {
              existing_units++;
            }
          }
          if (id === "pds") {
            if (existing_units >= imperium_self.game.state_pds_limit_per_planet) { return 0; }
          }
          if (id === "spacedock") {
            if (existing_units >= 1) { return 0; }
          }
          return 1;
        }
        return 0;
      },
      function (planet) {
        if (id == "pds") {
          imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + imperium_self.game.planets[planet].idx + "\tpds\t" + imperium_self.game.planets[planet].sector);
          mycallback(imperium_self.game.planets[planet].sector);
        }
        if (id == "spacedock") {
          imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + imperium_self.game.planets[planet].idx + "\tspacedock\t" + imperium_self.game.planets[planet].sector);
          mycallback(imperium_self.game.planets[planet].sector);
        }
      },
      function() {
        imperium_self.unlockInterface();
        imperium_self.playerBuildInfrastructure(mycallback, stage);
      },
    );
  });

}


 playerProduceUnits(sector, production_limit = 0, cost_limit = 0, stage = 0, warfare = 0) {

  let imperium_self = this;

  let player_fleet = this.returnPlayerFleet(imperium_self.game.player);
  let player_build = {};
  player_build.infantry = 0;
  player_build.fighters = 0;
  player_build.carriers = 0;
  player_build.cruisers = 0;
  player_build.dreadnaughts = 0;
  player_build.destroyers = 0;
  player_build.flagships = 0;
  player_build.warsuns = 0;

  //
  // determine production_limit from sector
  //
  let sys = this.returnSectorAndPlanets(sector);
  let available_resources = imperium_self.returnAvailableResources(imperium_self.game.player);
  available_resources += imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;

  let calculated_production_limit = 0;
  for (let i = 0; i < sys.s.units[this.game.player - 1].length; i++) {
    calculated_production_limit += sys.s.units[this.game.player - 1][i].production;
  }
  for (let p = 0; p < sys.p.length; p++) {
    for (let i = 0; i < sys.p[p].units[this.game.player - 1].length; i++) {
      calculated_production_limit += sys.p[p].units[this.game.player - 1][i].production;
      if (sys.p[p].units[this.game.player - 1][i].type === "spacedock") {
        calculated_production_limit += sys.p[p].resources;
      }
    }
  }

  if (this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock == 1) {
    if (production_limit == 0 && this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_production_limit >= 0) { production_limit = this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_production_limit; }
    if (cost_limit == 0 && this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_cost_limit >= 0) { cost_limit = this.game.players_info[this.game.player - 1].may_player_produce_without_spacedock_cost_limit; }
  };

  if (calculated_production_limit > production_limit) { production_limit = calculated_production_limit; }


  let html = '<div class="sf-readable">Produce Units in this Sector: ';
  if (production_limit != 0) { html += '(' + production_limit + ' units max)'; }
  if (cost_limit != 0) { html += '(' + cost_limit + ' cost max)'; }
  html += '</div><ul>';
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="infantry">Infantry - <span class="infantry_total">0</span></li>';
  }
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="fighter">Fighter - <span class="fighter_total">0</span></li>';
  }
  if (available_resources >= 1) {
    html += '<li class="buildchoice" id="destroyer">Destroyer - <span class="destroyer_total">0</span></li>';
  }
  if (available_resources >= 3) {
    html += '<li class="buildchoice" id="carrier">Carrier - <span class="carrier_total">0</span></li>';
  }
  if (available_resources >= 2) {
    html += '<li class="buildchoice" id="cruiser">Cruiser - <span class="cruiser_total">0</span></li>';
  }
  if (available_resources >= 4) {
    html += '<li class="buildchoice" id="dreadnaught">Dreadnaught - <span class="dreadnaught_total">0</span></li>';
  }
  if (available_resources >= 8 && this.canPlayerProduceFlagship(imperium_self.game.player)) {
    html += '<li class="buildchoice" id="flagship">Flagship - <span class="flagship_total">0</span></li>';
  }
  if (imperium_self.game.players_info[imperium_self.game.player - 1].may_produce_warsuns == 1) {
    if (available_resources >= 12) {
      html += '<li class="buildchoice" id="warsun">War Sun - <span class="warsun_total">0</span></li>';
    }
  }
  html += '</ul>';
  html += '</p>';
  html += '<div id="buildcost" class="buildcost"><span class="buildcost_total">0 resources</span></div>';
  html += '<div id="confirm" class="buildchoice">click here to build</div>';

  this.updateStatus(html);

  let stuff_to_build = [];

  imperium_self.lockInterface();

  $('.buildchoice').off();
  $('.buildchoice').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showUnit(s); });
  $('.buildchoice').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hideUnit(s); });
  $('.buildchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let id = $(this).attr("id");

    //
    // submit when done
    //
    if (id == "confirm") {

      $('.buildchoice').off();

      let total_cost = 0;
      for (let i = 0; i < stuff_to_build.length; i++) {
        total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
      }

      if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
        total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
      }

      if (warfare == 0) {
        imperium_self.addMove("resolve\tplay");
        imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      } else {
        imperium_self.addMove("resolve\tstrategy\t1\t" + imperium_self.app.wallet.returnPublicKey());
        imperium_self.addPublickeyConfirm(imperium_self.app.wallet.returnPublicKey(), 1);
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      }

      imperium_self.playerSelectResources(total_cost, function (success) {

        if (success == 1) {
          imperium_self.addMove("post_production\t" + imperium_self.game.player + "\t" + sector + "\t" + JSON.stringify(stuff_to_build));
          for (let y = 0; y < stuff_to_build.length; y++) {
            let planet_idx = imperium_self.returnPlayersLeastDefendedPlanetInSector(imperium_self.game.player, sector);
            if (stuff_to_build[y] != "infantry") { planet_idx = -1; }
            imperium_self.addMove("produce\t" + imperium_self.game.player + "\t" + 1 + "\t" + planet_idx + "\t" + stuff_to_build[y] + "\t" + sector);
            imperium_self.addMove("setvar"+"\t"+"state"+"\t"+"0"+"\t"+"active_player_has_produced"+"\t"+1)
            imperium_self.game.tracker.production = 1;
          }
          imperium_self.endTurn();
          return;
        } else {
          salert("failure to find appropriate influence");
        }
      });

      return;
    };


    let calculated_total_cost = 0;
    for (let i = 0; i < stuff_to_build.length; i++) {
      calculated_total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
    }
    calculated_total_cost += imperium_self.returnUnitCost(id, imperium_self.game.player);

    //
    // reduce production costs if needed
    //
    if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
      calculated_total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
    }




    //
    // respect production / cost limits
    //
    let return_to_zero = 0;
    if (id == "fighter" && (player_build.fighters + player_fleet.fighters) > imperium_self.game.players_info[imperium_self.game.player - 1].fighter_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].fighter_limit + " fighters on the board");
      return_to_zero = 1;
    }
    if (id == "infantry" && (player_build.infantry + player_fleet.infantry) > imperium_self.game.players_info[imperium_self.game.player - 1].infantry_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].infantry_limit + " infantry on the board");
      return_to_zero = 1;
    }
    if (id == "destroyer" && (player_build.destroyers + player_fleet.destroyers) > imperium_self.game.players_info[imperium_self.game.player - 1].destroyer_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].destroyer_limit + " destroyers on the board");
      return_to_zero = 1;
    }
    if (id == "carrier" && (player_build.carriers + player_fleet.carriers) > imperium_self.game.players_info[imperium_self.game.player - 1].carrier_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].carrier_limit + " carriers on the board");
      return_to_zero = 1;
    }
    if (id == "cruiser" && (player_build.cruisers + player_fleet.cruisers) > imperium_self.game.players_info[imperium_self.game.player - 1].cruiser_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].cruiser_limit + " cruisers on the board");
      return_to_zero = 1;
    }
    if (id == "dreadnaught" && (player_build.dreadnaughts + player_fleet.dreadnaughts) > imperium_self.game.players_info[imperium_self.game.player - 1].dreadnaught_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].dreadnaught_limit + " dreadnaughts on the board");
      return_to_zero = 1;
    }
    if (id == "flagship" && (player_build.flagships + player_fleet.flagships) > imperium_self.game.players_info[imperium_self.game.player - 1].flagships_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].flagship_limit + " flagships on the board");
      return_to_zero = 1;
    }
    if (id == "warsun" && (player_build.warsuns + player_fleet.warsuns) > imperium_self.game.players_info[imperium_self.game.player - 1].warsun_limit) {
      salert("You can only have " + imperium_self.game.players_info[imperium_self.game.player - 1].warsun_limit + " warsuns on the board");
      return_to_zero = 1;
    }
    if (calculated_total_cost > imperium_self.returnAvailableResources(imperium_self.game.player)) {
      salert("You cannot build more than you have available to pay for it.");
      return_to_zero = 1;
    }
    if (production_limit < stuff_to_build.length && production_limit > 0) {
      salert("You cannot build more units than your production limit");
      return_to_zero = 1;
    }
    if (cost_limit < calculated_total_cost && cost_limit > 0) {
      salert("You cannot build units that cost more than your cost limit");
      return_to_zero = 1;
    }
    if ((stuff_to_build.length + 1) > calculated_production_limit) {
      salert("You cannot build more units than your production limit");
      return_to_zero = 1;
    }
    if (return_to_zero == 1) {
      stuff_to_build = [];
      $('.infantry_total').html(0);
      $('.fighter_total').html(0);
      $('.destroyer_total').html(0);
      $('.carrier_total').html(0);
      $('.cruiser_total').html(0);
      $('.dreadnaught_total').html(0);
      $('.flagship_total').html(0);
      $('.warsun_total').html(0);
      player_build = {};
      player_build.infantry = 0;
      player_build.fighters = 0;
      player_build.carriers = 0;
      player_build.cruisers = 0;
      player_build.dreadnaughts = 0;
      player_build.destroyers = 0;
      player_build.flagships = 0;
      player_build.warsuns = 0;
      return;
    }

    //
    //  figure out if we need to load infantry / fighters
    //
    stuff_to_build.push(id);

    let total_cost = 0;
    for (let i = 0; i < stuff_to_build.length; i++) {
      total_cost += imperium_self.returnUnitCost(stuff_to_build[i], imperium_self.game.player);
    }

    let divtotal = "." + id + "_total";
    let x = parseInt($(divtotal).html());
    x++;
    $(divtotal).html(x);

    //
    // reduce production costs if needed
    //
    if (imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus > 0) {
      total_cost -= imperium_self.game.players_info[imperium_self.game.player - 1].production_bonus;
      imperium_self.updateLog("Production Costs reduced by 1");
    }

    let resourcetxt = " resources";
    if (total_cost == 1) { resourcetxt = " resource"; }
    $('.buildcost_total').html(total_cost + resourcetxt);

  });

}


playerHandleTradeOffer(faction_offering, their_offer, my_offer, offer_log) {

  let imperium_self = this;

  let goods_offered = 0;
  let goods_received = 0;
  let promissaries_offered = "";
  let promissaries_received = "";

  if (their_offer.promissaries) {
    if (their_offer.promissaries.length > 0) {
      for (let i = 0; i < their_offer.promissaries.length; i++) {
        let pm = their_offer.promissaries[i].promissary;
	let tmpar = pm.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
        if (i > 0) { promissaries_received += ', '; }
        promissaries_received += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }
    }
  }

  if (my_offer.promissaries) {
    if (my_offer.promissaries.length > 0) {
      for (let i = 0; i < my_offer.promissaries.length; i++) {
        let pm = my_offer.promissaries[i].promissary;
	let tmpar = pm.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
        if (i > 0) { promissaries_offered += ', '; }
        promissaries_offered += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }
    }
  }

  let html = '<div class="sf-readable">You have received a trade offer from ' + imperium_self.returnFaction(faction_offering) + '. ';
  html += offer_log;
  html += ': </div><ul>';
  html += `  <li class="option" id="yes">accept trade</li>`;
  html += `  <li class="option" id="no">refuse trade</li>`;
  html += '</ul>';

  imperium_self.updateStatus(html);


  $('.option').off();
  $('.option').on('click', function () {

    let action = $(this).attr("id");

    if (action == "no") {
      imperium_self.addMove("refuse_offer\t" + imperium_self.game.player + "\t" + faction_offering);
      imperium_self.endTurn();
      return 0;
    }

    if (action == "yes") {
      imperium_self.addMove("trade\t" + faction_offering + "\t" + imperium_self.game.player + "\t" + JSON.stringify(their_offer) + "\t" + JSON.stringify(my_offer));
      imperium_self.endTurn();
      return 0;
    }

  });


}


  playerTrade() {

    let imperium_self = this;
    let factions = this.returnFactions();

    let offer_selected = 0;
    let receive_selected = 0;
    let offer_promissaries = [];
    let receive_promissaries = [];
    let max_offer = 0;
    let max_receipt = 0;


    let goodsTradeInterface = function (imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      let receive_promissary_text = 'no promissaries';
      for (let i = 0; i < receive_promissaries.length; i++) {
        if (i == 0) { receive_promissary_text = ''; }
        let pm = receive_promissaries[i];
	let tmpar = pm.promissary.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	if (i > 0) { receive_promissary_text += ', '; }
        receive_promissary_text += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }

      let offer_promissary_text = 'no promissaries';
      for (let i = 0; i < offer_promissaries.length; i++) {
        if (i == 0) { offer_promissary_text = ''; }
        let pm = offer_promissaries[i];
	let tmpar = pm.promissary.split("-");
        let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	if (i > 0) { offer_promissary_text += ', '; }
        offer_promissary_text += `${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}`;	
      }

      let html = "<div class='sf-readable'>Make an Offer: </div><ul>";
      html += '<li id="to_offer" class="option">you give <span class="offer_total">'+offer_selected+'</span> trade goods</li>';
      html += '<li id="to_receive" class="option">you receive <span class="receive_total">'+receive_selected+'</span> trade goods</li>';
      html += '<li id="promissary_offer" class="option">you give <span class="give_promissary">'+offer_promissary_text+'</span></li>';
      html += '<li id="promissary_receive" class="option">you receive <span class="receive_promissary">'+receive_promissary_text+'</span></li>';
      html += '<li id="confirm" class="option">submit offer</li>';
      html += '<li id="cancel" class="option">cancel</li>';
      html += '</ul>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let selected = $(this).attr("id");

        if (selected == "to_offer") { offer_selected++; if (offer_selected > max_offer) { offer_selected = 0; } }
        if (selected == "to_receive") { receive_selected++; if (receive_selected > max_receipt) { receive_selected = 0; } }

	if (selected == "cancel") {
	  imperium_self.playerTurn();
	  return;
	}
	if (selected == "promissary_offer") {
	  promissaryTradeInterface(imperium_self, player, 1, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;
	}
	if (selected == "promissary_receive") {
	  promissaryTradeInterface(imperium_self, player, 2, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;
	}

        if (selected == "confirm") {

          let my_offer = {};
          my_offer.goods = $('.offer_total').html();
	  my_offer.promissaries = offer_promissaries;
          let my_receive = {};
          my_receive.goods = $('.receive_total').html();
	  my_receive.promissaries = receive_promissaries;

          imperium_self.addMove("offer\t" + imperium_self.game.player + "\t" + player + "\t" + JSON.stringify(my_offer) + "\t" + JSON.stringify(my_receive));
          imperium_self.updateStatus("trade offer submitted");
          imperium_self.endTurn();

        }

        $('.offer_total').html(offer_selected);
        $('.receive_total').html(receive_selected);

      });
    }
    //
    // mode = 1 // offer
	      2 // receive
    //
    let promissaryTradeInterface = function (imperium_self, player, mode, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      // offer mine to them
      if (mode == 1) {

        let html = '<div class="sf-readable">Add Promissary to YOUR Offer: </div><ul>';
        for (let i = 0; i < imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes.length; i++) {

	  let pm = imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes[i];
	  let tmpar = pm.split("-");
          let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	  let already_offered = 0;
	  for (let b = 0; b < offer_promissaries.length; b++) {
	    if (offer_promissaries[b].promissary === pm) {
	      already_offered = 1;
	    }
	  }
	  if (already_offered == 0) {
            html += `  <li class="option" id="${i}">${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
        }
        html += `  <li class="option" id="cancel">cancel</li>`;

	imperium_self.updateStatus(html);
        $('.option').off();
        $('.option').on('click', function () {

          let prom = $(this).attr("id");

          if (prom == "cancel") {
            goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
            return 0;
          }
	  
	  let promobj = { player : imperium_self.game.player , promissary : imperium_self.game.players_info[imperium_self.game.player-1].promissary_notes[prom] }
	  offer_promissaries.push(promobj);
          goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;

	});
      }



      // request theirs
      if (mode == 2) {

        let html = '<div class="sf-readable">Request Promissary FROM them: </div><ul>';
        for (let i = 0; i < imperium_self.game.players_info[player-1].promissary_notes.length; i++) {
	  let pm = imperium_self.game.players_info[player-1].promissary_notes[i];
	  let tmpar = pm.split("-");
          let faction_promissary_owner = imperium_self.factions[tmpar[0]].name;
	  let already_offered = 0;
	  for (let b = 0; b < receive_promissaries.length; b++) {
	    if (receive_promissaries[b].promissary === pm) {
	      already_offered = 1;
	    }
	  }
	  if (already_offered == 0) {
            html += `  <li class="option" id="${i}">${faction_promissary_owner} - ${imperium_self.promissary_notes[tmpar[1]].name}</li>`;
          }
        }
        html += `  <li class="option" id="cancel">cancel</li>`;

	imperium_self.updateStatus(html);
        $('.option').off();
        $('.option').on('click', function () {

          let prom = $(this).attr("id");

          if (prom == "cancel") {
            goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
            return 0;
          }
	  
	  let promobj = { player : player , promissary : imperium_self.game.players_info[player-1].promissary_notes[prom] }
	  receive_promissaries.push(promobj);
          goodsTradeInterface(imperium_self, player, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);
	  return;

	});


      }

    }
    let mainTradeInterface = function (imperium_self, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface) {

      let html = '<div class="sf-readable">Make Trade Offer to Faction: </div><ul>';
      for (let i = 0; i < imperium_self.game.players_info.length; i++) {
        if (imperium_self.game.players_info[i].traded_this_turn == 0 && (i + 1) != imperium_self.game.player) {
          if (imperium_self.arePlayersAdjacent(imperium_self.game.player, (i + 1))) {
            html += `  <li class="option" id="${i}">${factions[imperium_self.game.players_info[i].faction].name}</li>`;
          }
        }
      }
      html += `  <li class="option" id="cancel">cancel</li>`;
      html += '</ul>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let faction = $(this).attr("id");

        if (faction == "cancel") {
          imperium_self.playerTurn();
          return 0;
        }

        max_offer = imperium_self.game.players_info[imperium_self.game.player - 1].commodities + imperium_self.game.players_info[imperium_self.game.player - 1].goods;
        max_receipt = imperium_self.game.players_info[parseInt(faction)].commodities + imperium_self.game.players_info[parseInt(faction)].goods;

	goodsTradeInterface(imperium_self, (parseInt(faction)+1), mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);

      });
    }

    //
    // start with the main interface
    //
    mainTradeInterface(imperium_self, mainTradeInterface, goodsTradeInterface, promissaryTradeInterface);

  }




playerSelectSector(mycallback, mode = 0) {

  //
  // mode
  //
  // 0 = any sector
  // 1 = activated actor
  //
  let imperium_self = this;

  $('.sector').off();
  $('.sector').on('click', function () {
    $('.sector').off();
    let pid = $(this).attr("id");
    mycallback(pid);
  });

}




playerSelectPlanet(mycallback, mode = 0) {

  //
  // mode
  //
  // 0 = in any sector
  // 1 = in unactivated actor
  // 2 = controlled by me
  //

  let imperium_self = this;

  let html = "Select a system in which to select a planet: ";
  this.updateStatus(html);

  $('.sector').on('click', function () {

    let sector = $(this).attr("id");
    let sys = imperium_self.returnSectorAndPlanets(sector);

    //
    // exit if no planets are controlled
    //
    if (mode == 2) {
      let exist_controlled_planets = 0;
      for (let i = 0; i < sys.p.length; i++) {
        if (sys.p[i].owner == imperium_self.game.player) {
          exist_controlled_planets = 1;
        }
      }
      if (exist_controlled_planets == 0) {
        salert("Invalid Choice: you do not control planets in that sector");
        return;
      }
    }


    html = '<div class="sf-readable">Select a planet in this system: </div><ul>';
    for (let i = 0; i < sys.p.length; i++) {
      if (mode == 0) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
      }
      if (mode == 1) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
      }
      if (mode == 2 && sys.p[i].owner == imperium_self.game.player) {
        html += '<li class="option" id="' + i + '">' + sys.p[i].name + '</li>';
      }
    }
    html += '</ul>';


    imperium_self.updateStatus(html);

    $('.option').off();
    $('.option').on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.showPlanetCard(sector, s); imperium_self.showSectorHighlight(sector); });
    $('.option').on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.hidePlanetCard(sector, s); imperium_self.hideSectorHighlight(sector); });
    $('.option').on('click', function () {
      let pid = $(this).attr("id");
      imperium_self.hidePlanetCard(sector, pid);
      mycallback(sector, pid);
    });

  });

}



playerSelectInfluence(cost, mycallback) {

  if (cost == 0) { mycallback(1); return; }

  let imperium_self = this;
  let array_of_cards = this.returnPlayerUnexhaustedPlanetCards(this.game.player); // unexhausted
  let array_of_cards_to_exhaust = [];
  let selected_cost = 0;
  let total_trade_goods = imperium_self.game.players_info[imperium_self.game.player - 1].goods;


  let html = "<div class='sf-readable'>Select " + cost + " in influence: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    html += '<li class="cardchoice cardchoice-card" id="cardchoice_' + array_of_cards[z] + '">' + this.returnPlanetCard(array_of_cards[z]) + '</li>';
  }
  if (1 == imperium_self.game.players_info[imperium_self.game.player - 1].goods) {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade good</li>';
  } else {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade goods</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.cardchoice , .textchoice').on('click', function () {

    let action2 = $(this).attr("id");
    let tmpx = action2.split("_");

    let divid = "#" + action2;
    let y = tmpx[1];
    let idx = 0;
    for (let i = 0; i < array_of_cards.length; i++) {
      if (array_of_cards[i] === y) {
        idx = i;
      }
    }



    //
    // handle spending trade goods
    //
    if (action2 == "trade_goods") {
      if (total_trade_goods > 0) {
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tgoods\t1");
        total_trade_goods--;
        selected_cost += 1;

        if (1 == total_trade_goods) {
          $('#trade_goods').html(('' + total_trade_goods + ' trade good'));
        } else {
          $('#trade_goods').html(('' + total_trade_goods + ' trade goods'));
        }
      }
    } else {
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tplanet\t" + array_of_cards[idx]);
      array_of_cards_to_exhaust.push(array_of_cards[idx]);
      $(divid).off();
      $(divid).css('opacity', '0.2');
      selected_cost += imperium_self.game.planets[array_of_cards[idx]].influence;
    }

    if (cost <= selected_cost) {

      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.cardchoice , .textchoice').off();

      mycallback(1);
    }

  });
}






playerSelectStrategyAndCommandTokens(cost, mycallback) {

  if (cost == 0) { mycallback(1); }

  let imperium_self = this;
  let selected_cost = 0;

  let html = "<div class='sf-readable'>Select " + cost + " in Strategy and Command Tokens: </div><ul>";
  html += '<li class="textchoice" id="strategy">strategy tokens - <span class="available_strategy_tokens">'+imperium_self.game.players_info[imperium_self.game.player-1].strategy_tokens+'</span></li>';
  html += '<li class="textchoice" id="command">command tokens - <span class="available_command_tokens">'+imperium_self.game.players_info[imperium_self.game.player-1].command_tokens+'</span></li>';
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();

  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "strategy") {
      let x = parseInt($('.available_strategy_tokens').html());
      if (x > 0) {
        selected_cost++;
        $('.available_strategy_tokens').html((x-1));
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tstrategy\t1");
      }
    }
    if (action2 == "command") {
      let x = parseInt($('.available_command_tokens').html());
      if (x > 0) {
        selected_cost++;
        $('.available_command_tokens').html((x-1));
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tcommand\t1");
      }
    }

    if (cost <= selected_cost) { 
      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.textchoice').off();
      mycallback(1); 
    }

  });

}



playerSelectResources(cost, mycallback) {

  if (cost == 0) { mycallback(1); return; }

  let imperium_self = this;
  let array_of_cards = this.returnPlayerUnexhaustedPlanetCards(this.game.player); // unexhausted
  let array_of_cards_to_exhaust = [];
  let selected_cost = 0;
  let total_trade_goods = imperium_self.game.players_info[imperium_self.game.player - 1].goods;

  let html = "<div class='sf-readable'>Select " + cost + " in resources: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    html += '<li class="cardchoice cardchoice-card" id="cardchoice_' + array_of_cards[z] + '">' + this.returnPlanetCard(array_of_cards[z]) + '</li>';
  }
  if (1 == imperium_self.game.players_info[imperium_self.game.player - 1].goods) {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade good</li>';
  } else {
    html += '<li class="textchoice" id="trade_goods" style="clear:both">' + imperium_self.game.players_info[imperium_self.game.player - 1].goods + ' trade goods</li>';
  }
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();

  $('.cardchoice , .textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    let tmpx = action2.split("_");

    let divid = "#" + action2;
    let y = tmpx[1];
    let idx = 0;
    for (let i = 0; i < array_of_cards.length; i++) {
      if (array_of_cards[i] === y) {
        idx = i;
      }
    }

    //
    // handle spending trade goods
    //
    if (action2 == "trade_goods") {
      if (total_trade_goods > 0) {
        imperium_self.addMove("expend\t" + imperium_self.game.player + "\tgoods\t1");
        total_trade_goods--;
        selected_cost += 1;

        if (1 == total_trade_goods) {
          $('#trade_goods').html(('' + total_trade_goods + ' trade good'));
        } else {
          $('#trade_goods').html(('' + total_trade_goods + ' trade goods'));
        }
      }
    } else {
      imperium_self.addMove("expend\t" + imperium_self.game.player + "\tplanet\t" + array_of_cards[idx]);
      array_of_cards_to_exhaust.push(array_of_cards[idx]);
      $(divid).off();
      $(divid).css('opacity', '0.2');
      selected_cost += parseInt(imperium_self.game.planets[array_of_cards[idx]].resources);
    }

    if (cost <= selected_cost) { 

      if (!imperium_self.mayUnlockInterface()) {
        salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
        return;
      }
      imperium_self.unlockInterface();
      $('.cardchoice , .textchoice').off();

      mycallback(1); 

    }

  });

}








playerSelectActionCard(mycallback, cancel_callback, types = []) {

  let imperium_self = this;
  let array_of_cards = this.returnPlayerActionCards(this.game.player, types);
  if (array_of_cards.length == 0) {
    this.playerAcknowledgeNotice("You do not have any action cards that can be played now", function () {
      if (cancel_callback != null) { cancel_callback(); return 0; }
      imperium_self.playerTurn();
      return 0;
    });
    return 0;
  }

  let html = '';

  html += "<div class='sf-readable'>Select an action card: </div><ul>";
  for (let z = 0; z < array_of_cards.length; z++) {
    if (!this.game.players_info[this.game.player - 1].action_cards_played.includes(array_of_cards[z])) {
      let thiscard = imperium_self.action_cards[array_of_cards[z]];
      html += '<li class="textchoice pointer" id="' + array_of_cards[z] + '">' + thiscard.name + '</li>';
    }
  }
  html += '<li class="textchoice pointer" id="cancel">cancel</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showActionCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideActionCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 != "cancel") { imperium_self.hideActionCard(action2); }
    if (action2 === "cancel") { cancel_callback(); return 0; }

    if (imperium_self.game.tracker) { imperium_self.game.tracker.action_card = 1; }
    if (imperium_self.action_cards[action2].type == "action") { imperium_self.game.state.active_player_moved = 1; }

    imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(action2);

    mycallback(action2);

  });

}


//
// this is when players are choosing to play the cards that they have 
// already chosen.
//
playerSelectStrategyCard(mycallback, mode = 0) {

  let array_of_cards = this.game.players_info[this.game.player - 1].strategy;
  let strategy_cards = this.returnStrategyCards();
  let imperium_self = this;

  let html = "";

  html += "<div class='sf-readable'>Select a strategy card: </div><ul>";
  for (let z in array_of_cards) {
    if (!this.game.players_info[this.game.player - 1].strategy_cards_played.includes(array_of_cards[z])) {
      html += '<li class="textchoice" id="' + array_of_cards[z] + '">' + strategy_cards[array_of_cards[z]].name + '</li>';
    }
  }
  html += '<li class="textchoice pointer" id="cancel">cancel</li>';
  html += '</ul>';

  this.updateStatus(html);
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showStrategyCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideStrategyCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 != "cancel") { imperium_self.hideStrategyCard(action2); }

    if (action2 === "cancel") {
      imperium_self.playerTurn();
      return;
    }

    mycallback(action2);

  });
}




//
// this is when players select at the begining of the round, not when they 
// are chosing to play the cards that they have already selected
//
playerSelectStrategyCards(mycallback) {

  let imperium_self = this;
  let cards = this.returnStrategyCards();
  let playercol = "player_color_" + this.game.player;
  let relevant_action_cards = ["strategy"];
  let ac = this.returnPlayerActionCards(this.game.player, relevant_action_cards);


  let html = "<div class='terminal_header'><div class='player_color_box " + playercol + "'></div>" + this.returnFaction(this.game.player) + ": select your strategy card:</div><ul>";
  if (this.game.state.round > 1) {
    html = "<div class='terminal_header'>" + this.returnFaction(this.game.player) + ": select your strategy card:</div><ul>";
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  let scards = [];

  for (let z in this.strategy_cards) {
    scards.push("");
  }

  for (let z = 0; z < this.game.state.strategy_cards.length; z++) {
    let rank = parseInt(this.strategy_cards[this.game.state.strategy_cards[z]].rank);
    while (scards[rank - 1] != "") { rank++; }
    scards[rank - 1] = '<li class="textchoice" id="' + this.game.state.strategy_cards[z] + '">' + cards[this.game.state.strategy_cards[z]].name + '</li>';
  }

  for (let z = 0; z < scards.length; z++) {
    if (scards[z] != "") {
      html += scards[z];
    }
  }

  html += '</ul></p>';
  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showStrategyCard(s); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideStrategyCard(s); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("pickstrategy\t" + imperium_self.game.player);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
        imperium_self.endTurn();
        return 0;
      }, function () {
        imperium_self.playerSelectActionCards(action_card_player, card);
      }, ["action"]);
      return 0;
    }

    imperium_self.hideStrategyCard(action2);
    mycallback(action2);
  });

}



playerRemoveInfantryFromPlanets(player, total = 1, mycallback) {

  let imperium_self = this;

  let html = '';
  html += '<div class="sf-readable">Remove ' + total + ' infantry from planets you control:</div>';
  html += '<ul>';

  let infantry_to_remove = [];

  for (let s in this.game.planets) {
    let planet = this.game.planets[s];
    if (planet.owner == player) {
      let infantry_available_here = 0;
      for (let ss = 0; ss < planet.units[player - 1].length; ss++) {
        if (planet.units[player - 1][ss].type == "infantry") { infantry_available_here++; }
      }
      if (infantry_available_here > 0) {
        html += '<li class="option textchoice" id="' + s + '">' + planet.name + ' - <div style="display:inline" id="' + s + '_infantry">' + infantry_available_here + '</div></li>';
      }
    }
  }
  html += '<li class="option textchoice" id="end"></li>';
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "end") {

      for (let i = 0; i < infantry_to_remove.length; i++) {

        let planet_in_question = imperium_self.game.planets[infantry_to_remove[i].planet];

        let total_units_on_planet = planet_in_question.units[player - 1].length;
        for (let ii = 0; ii < total_units_on_planet; ii++) {
          let thisunit = planet_in_question.units[player - 1][ii];
          if (thisunit.type == "infantry") {
            planet_in_question.units[player - 1].splice(ii, 1);
            ii = total_units_on_planet + 2; // 0 as player_moves below because we have removed above
            imperium_self.addMove("remove_infantry_from_planet\t" + player + "\t" + infantry_to_remove[i].planet + "\t" + "0");
            imperium_self.addMove("NOTIFY\tREMOVING INFANTRY FROM PLANET: " + infantry_to_remove[i].planet);
          }
        }
      }
      mycallback(infantry_to_remove.length);
      return;
    }

    infantry_to_remove.push({ infantry: 1, planet: action2 });
    let divname = "#" + action2 + "_infantry";
    let existing_infantry = $(divname).html();
    let updated_infantry = parseInt(existing_infantry) - 1;
    if (updated_infantry < 0) { updated_infantry = 0; }

    $(divname).html(updated_infantry);

    if (updated_infantry == 0) {
      $(this).remove();
    }

    if (infantry_to_remove.length >= total) {
      $('#end').click();
    }

  });

}

playerAddInfantryToPlanets(player, total = 1, mycallback) {

  let imperium_self = this;

  let html = '';
  html += '<div class="sf-readable">Add ' + total + ' infantry to planets you control:</div>';
  html += '<ul>';

  let infantry_to_add = [];

  for (let s in this.game.planets) {
    let planet = this.game.planets[s];
    if (planet.owner == player) {
      let infantry_available_here = 0;
      for (let ss = 0; ss < planet.units[player - 1].length; ss++) {
        if (planet.units[player - 1][ss].type == "infantry") { infantry_available_here++; }
      }
      html += '<li class="option textchoice" id="' + s + '">' + planet.name + ' - <div style="display:inline" id="' + s + '_infantry">' + infantry_available_here + '</div></li>';
    }
  }
  html += '<li class="option textchoice" id="end"></li>';
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "end") {
      for (let i = 0; i < infantry_to_add.length; i++) {
        imperium_self.addMove("add_infantry_to_planet\t" + player + "\t" + infantry_to_add[i].planet + "\t" + "1");
      }
      mycallback(infantry_to_add.length);
      return;
    }

    infantry_to_add.push({ infantry: 1, planet: action2 });
    let divname = "#" + action2 + "_infantry";
    let existing_infantry = $(divname).html();
    let updated_infantry = parseInt(existing_infantry) + 1;

    $(divname).html(updated_infantry);

    if (infantry_to_add.length >= total) {
      $('#end').click();
    }

  });

}


//////////////////////////
// Select Units to Move //
//////////////////////////
playerSelectUnitsToMove(destination) {

  let imperium_self = this;
  let html = '';
  let hops = 3;
  let sectors = [];
  let distance = [];
  let hazards = [];
  let hoppable = [];
  let fighters_loaded = 0;
  let infantry_loaded = 0;

  let obj = {};
  obj.max_hops = 2;
  obj.ship_move_bonus = this.game.players_info[this.game.player - 1].ship_move_bonus + this.game.players_info[this.game.player - 1].temporary_ship_move_bonus;
  obj.fleet_move_bonus = this.game.players_info[this.game.player - 1].fleet_move_bonus + this.game.players_info[this.game.player - 1].temporary_fleet_move_bonus;
  obj.ships_and_sectors = [];
  obj.stuff_to_move = [];
  obj.stuff_to_load = [];
  obj.distance_adjustment = 0;

  obj.max_hops += obj.ship_move_bonus;
  obj.max_hops += obj.fleet_move_bonus;

  let x = imperium_self.returnSectorsWithinHopDistance(destination, obj.max_hops, imperium_self.game.player);
  sectors = x.sectors;
  distance = x.distance;
  hazards = x.hazards;
  hoppable = x.hoppable;

  for (let i = 0; i < distance.length; i++) {
    if (obj.ship_move_bonus > 0) {
      distance[i]--;
    }
    if (obj.fleet_move_bonus > 0) {
      distance[i]--;
    }
  }

  if (obj.ship_move_bonus > 0) {
    obj.distance_adjustment += obj.ship_move_bonus;
  }
  if (obj.fleet_move_bonus > 0) {
    obj.distance_adjustment += obj.fleet_move_bonus;
  }

  obj.ships_and_sectors = imperium_self.returnShipsMovableToDestinationFromSectors(destination, sectors, distance, hazards, hoppable);

  let updateInterface = function (imperium_self, obj, updateInterface) {

    let subjective_distance_adjustment = 0;
    if (obj.ship_move_bonus > 0) {
      subjective_distance_adjustment += obj.ship_move_bonus;
    }
    if (obj.fleet_move_bonus > 0) {
      subjective_distance_adjustment += obj.fleet_move_bonus;
    }
    let spent_distance_boost = (obj.distance_adjustment - subjective_distance_adjustment);

    let playercol = "player_color_" + imperium_self.game.player;
    let html = "<div class='player_color_box " + playercol + "'></div> " + imperium_self.returnFaction(imperium_self.game.player) + ': select ships to move<ul>';

    //
    // select ships
    //
    for (let i = 0; i < obj.ships_and_sectors.length; i++) {

      let sys = imperium_self.returnSectorAndPlanets(obj.ships_and_sectors[i].sector);
      html += '<b class="sector_name" id="' + obj.ships_and_sectors[i].sector + '" style="margin-top:10px">' + sys.s.name + '</b>';
      html += '<ul class="ship_selector">';
      for (let ii = 0; ii < obj.ships_and_sectors[i].ships.length; ii++) {

        //
        // figure out if we can still move this ship
        //
        let already_moved = 0;
        for (let z = 0; z < obj.stuff_to_move.length; z++) {
          if (obj.stuff_to_move[z].already_moved == 1) {
            already_moved = 1;
          }
          if (obj.stuff_to_move[z].sector == obj.ships_and_sectors[i].sector) {
            if (obj.stuff_to_move[z].i == i) {
              if (obj.stuff_to_move[z].ii == ii) {
                already_moved = 1;
              }
            }
          }
        }

	let rift_passage = 0;
	if (obj.ships_and_sectors[i].hazards[ii] === "rift") { rift_passage = 1; }

        if (already_moved == 1) {
          if (rift_passage == 0) {
            html += `<li id="sector_${i}_${ii}" class=""><b>${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</b></li>`;
	  } else {
            html += `<li id="sector_${i}_${ii}" class=""><b>${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</b> - rift</li>`;
	  }
        } else {
          if (obj.ships_and_sectors[i].ships[ii].move - (obj.ships_and_sectors[i].adjusted_distance[ii] + spent_distance_boost) >= 0) {
            if (rift_passage == 0) {
	      html += `<li id="sector_${i}_${ii}" class="option">${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])}</li>`;
            } else {
	      html += `<li id="sector_${i}_${ii}" class="option">${imperium_self.returnShipInformation(obj.ships_and_sectors[i].ships[ii])} - rift</li>`;
	    }
          }
        }
      }

      html += '</ul>';
    }
    html += '<hr />';
    html += '<div id="confirm" class="option">click here to move</div>';
//    html += '<hr />';
//    html += '<div id="clear" class="option">clear selected</div>';
    html += '<hr />';
    imperium_self.updateStatus(html);

    //
    // add hover / mouseover to sector names
    //
    let adddiv = ".sector_name";
    $(adddiv).on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.addSectorHighlight(s); });
    $(adddiv).on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.removeSectorHighlight(s); });


    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");

      //
      // submit when done
      //
      if (id == "confirm") {

        imperium_self.addMove("resolve\tplay");
        // source should be OK as moving out does not add units
        imperium_self.addMove("space_invasion\t" + imperium_self.game.player + "\t" + destination);
        imperium_self.addMove("check_fleet_supply\t" + imperium_self.game.player + "\t" + destination);
        for (let y = 0; y < obj.stuff_to_move.length; y++) {

	  let this_ship_i = obj.stuff_to_move[y].i;
	  let this_ship_ii = obj.stuff_to_move[y].ii;
	  let this_ship_hazard = obj.ships_and_sectors[this_ship_i].hazards[this_ship_ii];

          imperium_self.addMove("move\t" + imperium_self.game.player + "\t" + 1 + "\t" + obj.ships_and_sectors[obj.stuff_to_move[y].i].sector + "\t" + destination + "\t" + JSON.stringify(obj.ships_and_sectors[obj.stuff_to_move[y].i].ships[obj.stuff_to_move[y].ii]) + "\t" + this_ship_hazard);
        }
        for (let y = obj.stuff_to_load.length - 1; y >= 0; y--) {
          imperium_self.addMove("load\t" + imperium_self.game.player + "\t" + 0 + "\t" + obj.stuff_to_load[y].sector + "\t" + obj.stuff_to_load[y].source + "\t" + obj.stuff_to_load[y].source_idx + "\t" + obj.stuff_to_load[y].unitjson + "\t" + obj.stuff_to_load[y].shipjson);
        }

        imperium_self.endTurn();
        return;
      };

      //
      // clear the list to start again
      //
      if (id == "clear") {
        salert("To change movement options, please reload!");
	window.location.reload(true);
        return;
      }


      //
      // highlight ship on menu
      //
      $(this).css("font-weight", "bold");
      this.classList.add("ship_selected");

      //
      //  figure out if we need to load infantry / fighters
      //
      let tmpx = id.split("_");
      let i = tmpx[1];
      let ii = tmpx[2];
      let calcdist = obj.ships_and_sectors[i].distance;
      let sector = obj.ships_and_sectors[i].sector;
      let sys = imperium_self.returnSectorAndPlanets(sector);
      let ship = obj.ships_and_sectors[i].ships[ii];
      let total_ship_capacity = imperium_self.returnRemainingCapacity(ship);
      let x = { i: i, ii: ii, sector: sector };


      //
      // calculate actual distance
      //
      let real_distance = calcdist + obj.distance_adjustment;
      let free_distance = ship.move + obj.fleet_move_bonus;

      if (real_distance > free_distance) {
        //
        // 
        //
        obj.ship_move_bonus--;
      }


      //
      // if this is a fighter, remove it from the underlying
      // list of units we can move, so that it is not double-added
      //
      if (ship.type == "fighter") {
        obj.ships_and_sectors[i].ships[ii].already_moved = 1;
      }




      obj.stuff_to_move.push(x);
      updateInterface(imperium_self, obj, updateInterface);


      //
      // is there stuff left to move?
      //
      let stuff_available_to_move = 0;
      for (let i = 0; i < sys.p.length; i++) {
        let planetary_units = sys.p[i].units[imperium_self.game.player - 1];
        for (let k = 0; k < planetary_units.length; k++) {
          if (planetary_units[k].type == "infantry") {
            stuff_available_to_move++;
          }
        }
      }
      for (let i = 0; i < sys.s.units[imperium_self.game.player - 1].length; i++) {
        if (sys.s.units[imperium_self.game.player - 1][i].type == "fighter") {
          stuff_available_to_move++;
        }
      }


      //
      // remove already-moved fighters from stuff-available-to-move
      // 
      let fighters_available_to_move = 0;
      for (let iii = 0; iii < sys.s.units[imperium_self.game.player - 1].length; iii++) {
        if (sys.s.units[imperium_self.game.player - 1][iii].type == "fighter") {
          let fighter_already_moved = 0;
          for (let z = 0; z < obj.stuff_to_move.length; z++) {
            if (obj.stuff_to_move[z].sector == sector) {
              if (obj.stuff_to_move[z].ii == iii) {
                fighter_already_moved = 1;
              }
            }
          }
          if (fighter_already_moved == 1) {
            stuff_available_to_move--;
          }
        }
      }


      if (total_ship_capacity > 0 && stuff_available_to_move > 0) {
        let remove_what_capacity = 0;
        for (let z = 0; z < obj.stuff_to_load.length; z++) {
          let x = obj.stuff_to_load[z];
          if (x.i == i && x.ii == ii) {
            let thisunit = JSON.parse(obj.stuff_to_load[z].unitjson);
            remove_what_capacity += thisunit.capacity_required;
          }
        }


        let user_message = `<div class="sf-readable">This ship has <span class="capacity_remaining">${total_ship_capacity}</span> capacity. Infantry can capture planets and fighters can protect your fleet. Do you wish to add them? </div><ul>`;

        for (let i = 0; i < sys.p.length; i++) {
          let planetary_units = sys.p[i].units[imperium_self.game.player - 1];
          let infantry_available_to_move = 0;
          for (let k = 0; k < planetary_units.length; k++) {
            if (planetary_units[k].type == "infantry") {
              infantry_available_to_move++;
            }
          }
          if (infantry_available_to_move > 0) {
            user_message += '<li class="option textchoice" id="addinfantry_p_' + i + '">add infantry from ' + sys.p[i].name + ' - <span class="add_infantry_remaining_' + i + '">' + infantry_available_to_move + '</span></li>';
          }
        }

        let fighters_available_to_move = 0;
        for (let iii = 0; iii < sys.s.units[imperium_self.game.player - 1].length; iii++) {
          if (sys.s.units[imperium_self.game.player - 1][iii].type == "fighter") {
            let fighter_already_moved = 0;
            for (let z = 0; z < obj.stuff_to_move.length; z++) {
              if (obj.stuff_to_move[z].sector == sector) {
                if (obj.stuff_to_move[z].ii == iii) {
                  fighter_already_moved = 1;
                }
              }
            }
            if (fighter_already_moved == 0) {
              fighters_available_to_move++;
            }
          }
        }
        user_message += '<li class="option textchoice" id="addfighter_s_s">add fighter - <span class="add_fighters_remaining">' + fighters_available_to_move + '</span></li>';
        user_message += '<li class="option textchoice" id="skip">finish</li>';
        user_message += '</ul></div>';


        //
        // choice
        //
        $('.status-overlay').html(user_message);
        $('.status-overlay').show();
        $('.status').hide();
        $('.textchoice').off();

        //
        // add hover / mouseover to message
        //
        for (let i = 0; i < sys.p.length; i++) {
          adddiv = "#addinfantry_p_" + i;
          $(adddiv).on('mouseenter', function () { imperium_self.addPlanetHighlight(sector, i); });
          $(adddiv).on('mouseleave', function () { imperium_self.removePlanetHighlight(sector, i); });
        }
        adddiv = "#addfighter_s_s";
        $(adddiv).on('mouseenter', function () { imperium_self.addSectorHighlight(sector); });
        $(adddiv).on('mouseleave', function () { imperium_self.removeSectorHighlight(sector); });


        // leave action enabled on other panels
        $('.textchoice').on('click', function () {

          let id = $(this).attr("id");
          let tmpx = id.split("_");
          let action2 = tmpx[0];

          if (total_ship_capacity > 0) {

            if (action2 === "addinfantry") {

              let planet_idx = tmpx[2];
              let irdiv = '.add_infantry_remaining_' + planet_idx;
              let ir = parseInt($(irdiv).html());
              let ic = parseInt($('.capacity_remaining').html());

              //
              // we have to load prematurely. so JSON will be accurate when we move the ship, so player_move is 0 for load
              //
              let unitjson = imperium_self.unloadUnitFromPlanet(imperium_self.game.player, sector, planet_idx, "infantry");
              let shipjson_preload = JSON.stringify(sys.s.units[imperium_self.game.player - 1][obj.ships_and_sectors[i].ship_idxs[ii]]);
              imperium_self.loadUnitByJSONOntoShip(imperium_self.game.player, sector, obj.ships_and_sectors[i].ship_idxs[ii], unitjson);

              $(irdiv).html((ir - 1));
              $('.capacity_remaining').html((ic - 1));

              let loading = {};
              loading.sector = sector;
              loading.source = "planet";
              loading.source_idx = planet_idx;
              loading.unitjson = unitjson;
              loading.ship_idx = obj.ships_and_sectors[i].ship_idxs[ii];
              loading.shipjson = shipjson_preload;
              loading.i = i;
              loading.ii = ii;

              total_ship_capacity--;

              obj.stuff_to_load.push(loading);

              if (ic === 1 && total_ship_capacity == 0) {
                $('.status').show();
                $('.status-overlay').hide();
              }

            }


            if (action2 === "addfighter") {

              if (fighters_available_to_move <= 0) { return; }

              let ir = parseInt($('.add_fighters_remaining').html());
              let ic = parseInt($('.capacity_remaining').html());
              $('.add_fighters_remaining').html((ir - 1));
              fighters_available_to_move--;
              $('.capacity_remaining').html((ic - 1));

              //
              // remove this fighter ...
              //
              let secs_to_check = obj.ships_and_sectors.length;
              for (let sec = 0; sec < obj.ships_and_sectors.length; sec++) {
                if (obj.ships_and_sectors[sec].sector === sector) {
                  let ships_to_check = obj.ships_and_sectors[sec].ships.length;
                  for (let f = 0; f < ships_to_check; f++) {
                    if (obj.ships_and_sectors[sec].ships[f].already_moved == 1) { } else {
                      if (obj.ships_and_sectors[sec].ships[f].type == "fighter") {

                        // remove fighter from status menu
                        let status_div = '#sector_' + sec + '_' + f;
                        $(status_div).remove();

                        // remove from arrays (as loaded)
                        // removed fri june 12
                        //obj.ships_and_sectors[sec].ships.splice(f, 1);
                        //obj.ships_and_sectors[sec].adjusted_distance.splice(f, 1);
                        obj.ships_and_sectors[sec].ships[f] = {};
                        obj.ships_and_sectors[sec].adjusted_distance[f] = 0;
                        f = ships_to_check + 2;
                        sec = secs_to_check + 2;

                      }
                    }
                  }
                }
              }

              let unitjson = imperium_self.removeSpaceUnit(imperium_self.game.player, sector, "fighter");
              let shipjson_preload = JSON.stringify(sys.s.units[imperium_self.game.player - 1][obj.ships_and_sectors[i].ship_idxs[ii]]);

              imperium_self.loadUnitByJSONOntoShip(imperium_self.game.player, sector, obj.ships_and_sectors[i].ship_idxs[ii], unitjson);

              let loading = {};
              obj.stuff_to_load.push(loading);

              loading.sector = sector;
              loading.source = "ship";
              loading.source_idx = "";
              loading.unitjson = unitjson;
              loading.ship_idx = obj.ships_and_sectors[i].ship_idxs[ii];
              loading.shipjson = shipjson_preload;
              loading.i = i;
              loading.ii = ii;

              total_ship_capacity--;

              if (ic == 1 && total_ship_capacity == 0) {
                $('.status').show();
                $('.status-overlay').hide();
              }
            }
          } // total ship capacity

          if (action2 === "skip") {
            $('.status-overlay').hide();
            $('.status').show();
          }

        });
      }
    });
  };

  updateInterface(imperium_self, obj, updateInterface);

  return;

}

//////////////////////////
// Select Units to Move //
//////////////////////////
playerSelectInfantryToLand(sector) {

  let imperium_self = this;
  let html = '<div id="status-message" class="imperial-status-message">Unload Infantry (source): <ul>';
  let sys = imperium_self.returnSectorAndPlanets(sector);

  let space_infantry = [];
  let ground_infantry = [];

  for (let i = 0; i < sys.s.units[this.game.player-1].length; i++) {
    let unit = sys.s.units[this.game.player-1][i];
    if (imperium_self.returnInfantryInUnit(unit) > 0) { 
      html += `<li class="option textchoice" id="addinfantry_s_${i}">remove infantry from ${unit.name} - <span class="add_infantry_remaining_s_${i}">${imperium_self.returnInfantryInUnit(unit)}</span></li>`;
    }
  }

  for (let p = 0; p < sys.p.length; p++) {
    let planet = sys.p[p];
    if (imperium_self.returnInfantryOnPlanet(planet) > 0) { 
      html += `<li class="option textchoice" id="addinfantry_p_${p}">remove infantry from ${planet.name} - <span class="add_infantry_remaining_p_${p}">${imperium_self.returnInfantryOnPlanet(planet)}</span></li>`;
    }
  }

  html += '</ul>';
  html += '</div>';

  html += '<div id="confirm" class="option">click here to move</div>';
//  html += '<hr />';
//  html += '<div id="clear" class="option">clear selected</div>';
  imperium_self.updateStatus(html);

  $('.option').off();
  $('.option').on('click', function () {

    let id = $(this).attr("id");
    let assigned_planets = [];
    let infantry_available_for_reassignment = 0;
    for (let i = 0; i < sys.p.length; i++) {
      assigned_planets.push(0);
    }

    //
    // submit when done
    //
    if (id == "confirm") {

      for (let i = 0; i < space_infantry.length; i++) {
	imperium_self.addMove("unload_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"ship"+"\t"+space_infantry[i].ship_idx);
        infantry_available_for_reassignment++;
      }
      for (let i = 0; i < ground_infantry.length; i++) {
	imperium_self.addMove("unload_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"planet"+"\t"+ground_infantry[i].planet_idx);
        infantry_available_for_reassignment++;
      }

      let html = '<div class="sf-readable" id="status-message">Reassign Infantry to Planets: <ul>';
          for (let i = 0; i < sys.p.length; i++) {
	    let infantry_remaining_on_planet = imperium_self.returnInfantryOnPlanet(sys.p[i]);
	    for (let ii = 0; ii < ground_infantry.length; ii++) {
	      if (ground_infantry[ii].planet_idx == i) { infantry_remaining_on_planet--; }
	    }
  	    html += `<li class="option textchoice" id="${i}">${sys.p[i].name} - <span class="infantry_on_${i}">${infantry_remaining_on_planet}</span></li>`;
          }
          html += '<div id="confirm" class="option">click here to move</div>';
          html += '</ul'; 
          html += '</div>';

      imperium_self.updateStatus(html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "confirm") {
	  imperium_self.endTurn();
        }

        if (infantry_available_for_reassignment > 0)  {
          infantry_available_for_reassignment--;
          let divname = ".infantry_on_"+id;
          let v = parseInt($(divname).html());
          v++;
	  $(divname).html((v));
	  imperium_self.addMove("load_infantry\t"+imperium_self.game.player+"\t"+1+"\t"+sector+"\t"+"planet"+"\t"+id);
	}

      });
    };

    //
    // clear the list to start again
    //
    if (id == "clear") {
      salert("To change movement options, just reload!");
      window.location.reload(true);
    }


    //
    // otherwise we selected
    //
    let user_selected = id.split("_");
    if (user_selected[1] === "p") {
      let divname = ".add_infantry_remaining_p_"+user_selected[2];
      let v = parseInt($(divname).html());
      if (v > 0) {
        ground_infantry.push({ planet_idx : user_selected[2] });
	$(divname).html((v-1));
      }
    }
    if (user_selected[1] === "s") {
      let divname = ".add_infantry_remaining_s_"+user_selected[2];
      let v = parseInt($(divname).html());
      if (v > 0) {
        space_infantry.push({ ship_idx : user_selected[2] });
	$(divname).html((v-1));
      }
    }

  });

  return;

}



playerInvadePlanet(player, sector) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);

  let total_available_infantry = 0;
  let space_transport_available = 0;
  let space_transport_used = 0;

  let landing_forces = [];
  let landing_on_planet_idx = [];
  let planets_invaded = [];

  html = '<div class="sf-readable">Which planet(s) do you invade: </div><ul>';
  for (let i = 0; i < sys.p.length; i++) {
    if (sys.p[i].owner != player) {
      html += '<li class="option sector_name" id="' + i + '">' + sys.p[i].name + ' - <span class="invadeplanet_' + i + '">0</span></li>';
    }
  }
  html += '<li class="option" id="confirm">launch invasion(s)</li>';
  html += '</ul>';
  this.updateStatus(html);

  let populated_planet_forces = 0;
  let populated_ship_forces = 0;
  let forces_on_planets = [];
  let forces_on_ships = [];

  $('.option').off();
  let adiv = ".sector_name";
  $(adiv).on('mouseenter', function () { let s = $(this).attr("id"); imperium_self.addPlanetHighlight(sector, s); });
  $(adiv).on('mouseleave', function () { let s = $(this).attr("id"); imperium_self.removePlanetHighlight(sector, s); });
  $('.option').on('click', function () {

    let planet_idx = $(this).attr('id');

    if (planet_idx === "confirm") {

/***
      if (landing_forces.length == 0) {
	let sanity_check = confirm("Invade without landing forces? Are you sure -- the invasion will fail.");
	if (!sanity_check) { return; }
      }
***/

      for (let i = 0; i < planets_invaded.length; i++) {

	if (landing_on_planet_idx.includes(planets_invaded[i])) {

            let owner = sys.p[planets_invaded[i]].owner;

            imperium_self.prependMove("bombardment\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("bombardment_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("bombardment_post\t" + owner + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("planetary_defense\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("planetary_defense_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_start\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_post\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);
            imperium_self.prependMove("ground_combat_end\t" + imperium_self.game.player + "\t" + sector + "\t" + planets_invaded[i]);

        }

      }

      imperium_self.prependMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.endTurn();
      return;
    }

    //
    // looks like we have selected a planet for invasion
    //
    if (!planets_invaded.includes(planet_idx)) {
      planets_invaded.push(planet_idx);
    }

    //
    // figure out available infantry and ships capacity
    //
    for (let i = 0; i < sys.s.units[player - 1].length; i++) {
      let unit = sys.s.units[player - 1][i];
      for (let k = 0; k < unit.storage.length; k++) {
        if (unit.storage[k].type == "infantry") {
          if (populated_ship_forces == 0) {
            total_available_infantry += 1;
          }
        }
      }
      if (sys.s.units[player - 1][i].capacity > 0) {
        if (populated_ship_forces == 0) {
          space_transport_available += sys.s.units[player - 1][i].capacity;
        }
      }
    }

    html = '<div class="sf-readable">Select Ground Forces for Invasion of ' + sys.p[planet_idx].name + ': </div><ul>';

    //
    // other planets in system
    //
    for (let i = 0; i < sys.p.length; i++) {
      forces_on_planets.push(0);
      if (space_transport_available > 0 && sys.p[i].units[player - 1].length > 0) {
        for (let j = 0; j < sys.p[i].units[player - 1].length; j++) {
          if (sys.p[i].units[player - 1][j].type == "infantry") {
            if (populated_planet_forces == 0) {
              forces_on_planets[i]++;;
            }
          }
        }
        html += '<li class="invadechoice textchoice option" id="invasion_planet_' + i + '">' + sys.p[i].name + ' - <span class="planet_' + i + '_infantry">' + forces_on_planets[i] + '</span></li>';
      }
    }
    populated_planet_forces = 1;



    //
    // ships in system
    //
    for (let i = 0; i < sys.s.units[player - 1].length; i++) {
      let ship = sys.s.units[player - 1][i];
      forces_on_ships.push(0);
      for (let j = 0; j < ship.storage.length; j++) {
        if (ship.storage[j].type === "infantry") {
          if (populated_ship_forces == 0) {
            forces_on_ships[i]++;
          }
        }
      }
      if (forces_on_ships[i] > 0) {
        html += '<li class="invadechoice textchoice" id="invasion_ship_' + i + '">' + ship.name + ' - <span class="ship_' + i + '_infantry">' + forces_on_ships[i] + '</span></li>';
      }
    }
    populated_ship_forces = 1;
    html += '<li class="invadechoice textchoice" id="finished_0_0">finish selecting</li>';
    html += '</ul></p>';


    //
    // choice
    //
    $('.status-overlay').html(html);
    $('.status').hide();
    $('.status-overlay').show();


    $('.invadechoice').off();
    $('.invadechoice').on('click', function () {

      let id = $(this).attr("id");
      let tmpx = id.split("_");

      let action2 = tmpx[0];
      let source = tmpx[1];
      let source_idx = tmpx[2];
      let counter_div = "." + source + "_" + source_idx + "_infantry";
      let counter = parseInt($(counter_div).html());

      if (action2 == "invasion") {

        if (source == "planet") {
          if (space_transport_available <= 0) { salert("Invalid Choice! No space transport available!"); return; }
          forces_on_planets[source_idx]--;
        } else {
          forces_on_ships[source_idx]--;
        }
        if (counter == 0) {
          salert("You cannot attack with forces you do not have available."); return;
        }

        let unitjson = JSON.stringify(imperium_self.returnUnit("infantry", imperium_self.game.player));

        let landing = {};
        landing.sector = sector;
        landing.source = source;
        landing.source_idx = source_idx;
        landing.planet_idx = planet_idx;
        landing.unitjson = unitjson;

        landing_forces.push(landing);

        let planet_counter = ".invadeplanet_" + planet_idx;
        let planet_forces = parseInt($(planet_counter).html());

        planet_forces++;
        $(planet_counter).html(planet_forces);

        counter--;
        $(counter_div).html(counter);

      }

      if (action2 === "finished") {

        for (let y = 0; y < landing_forces.length; y++) {
          imperium_self.addMove("land\t" + imperium_self.game.player + "\t" + 1 + "\t" + landing_forces[y].sector + "\t" + landing_forces[y].source + "\t" + landing_forces[y].source_idx + "\t" + landing_forces[y].planet_idx + "\t" + landing_forces[y].unitjson);
	  if (!landing_on_planet_idx.includes(landing_forces[y].planet_idx)) { landing_on_planet_idx.push(landing_forces[y].planet_idx); }
        };
        landing_forces = [];
	

        $('.status').show();
        $('.status-overlay').hide();

        return;
      }
    });
  });
}



playerActivateSystem() {

  let imperium_self = this;
  let html = "Select a sector to activate: ";
  let activated_once = 0;
  let xpos = 0;
  let ypos = 0;

  imperium_self.updateStatus(html);

  $('.sector').off();
  $('.sector').on('mousedown', function (e) {
    xpos = e.clientX;
    ypos = e.clientY;
  });
  $('.sector').on('mouseup', function (e) {

    if (Math.abs(xpos-e.clientX) > 4) { return; }
    if (Math.abs(ypos-e.clientY) > 4) { return; }

    //
    // only allowed 1 at a time
    //
    if (activated_once == 1) { return; }

    let pid = $(this).attr("id");

    if (imperium_self.canPlayerActivateSystem(pid) == 0) {
      salert("You cannot activate that system.");
    } else {

      let sys = imperium_self.returnSectorAndPlanets(pid);

      //
      // sanity check on whether we want to do this
      //
      let do_we_permit_this_activation = 1;
      if (!imperium_self.canPlayerMoveShipsIntoSector(imperium_self.game.player, pid)) {
	let c = confirm("You cannot move ships into this sector. Are you sure you wish to activate it?");
	if (c) {
        } else {
	  return;
	}
      }
 
      //
      // if this is our homeworld, it is round 1 and we haven't moved ships out, we may not 
      // understand 
      //
      if (imperium_self.returnPlayerHomeworldSector() == sys.s.sector && imperium_self.game.state.round == 1) {
	let confirm_choice = confirm("If you activate your homeworld you will not be able to move ships out of it until Round 2. Are you sure you want to do this?");
	if (!confirm_choice) { return; }
      }


      activated_once = 1;
      let divpid = '#' + pid;

      $(divpid).find('.hex_activated').css('background-color', 'var(--p' + imperium_self.game.player + ')');
      $(divpid).find('.hex_activated').css('opacity', '0.3');


      let chtml = "<div class='sf-readable'>Activate this system?</div><ul>";
          chtml += '<li class="option" id="yes">yes, do it</li>';
          chtml += '<li class="option" id="no">choose again</li>';
          chtml += '</ul>';

      imperium_self.updateStatus(chtml);
      
      $('.option').off();
      $('.option').on('click', function() {

        let action2 = $(this).attr("id");

        if (action2 === "yes") {
          sys.s.activated[imperium_self.game.player - 1] = 1;
          imperium_self.addMove("activate_system_post\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("pds_space_attack_post\t"+imperium_self.game.player+"\t"+pid);
          imperium_self.addMove("pds_space_attack\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("activate_system\t" + imperium_self.game.player + "\t" + pid);
          imperium_self.addMove("expend\t" + imperium_self.game.player + "\t" + "command" + "\t" + 1);
          imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "1");
          imperium_self.endTurn();

        } else {

          activated_once = 0;
          $(divpid).find('.hex_activated').css('background-color', 'transparent');
          $(divpid).find('.hex_activated').css('opacity', '1');

	  imperium_self.playerActivateSystem();

        }
      });
    }

  });
}


//
// if we have arrived here, we are ready to continue with our options post
// systems activation, which are move / pds combat / space combat / bombardment
// planetary invasion / ground combat
//
playerPostActivateSystem(sector) {

  let imperium_self = this;
  let relevant_action_cards = ["post_activate_system"];
  let ac = this.returnPlayerActionCards(imperium_self.game.player, relevant_action_cards);
  let player = imperium_self.game.player;

  let html = "<div class='sf-readable'>" + this.returnFaction(this.game.player) + ": </div><ul>";

  if (imperium_self.canPlayerMoveShipsIntoSector(player, sector)) {
    html += '<li class="option" id="move">move into sector</li>';
  }


  if (this.canPlayerInvadePlanet(player, sector) && this.game.tracker.invasion == 0) {
    if (sector == "new-byzantium" || sector == "4_4") {
      if ((imperium_self.game.planets['new-byzantium'].owner != -1) || (imperium_self.returnAvailableInfluence(imperium_self.game.player) + imperium_self.game.players_info[imperium_self.game.player - 1].goods) >= 6) {
        html += '<li class="option" id="invade">invade planet</li>';
      }
    } else {
      html += '<li class="option" id="invade">invade planet</li>';
    }
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">reassign infantry</li>';
  }

  if (this.canPlayerProduceInSector(this.game.player, sector)) {
    html += '<li class="option" id="produce">produce units</li>';
  }
  if (this.canPlayerLandInfantry(player, sector) && this.game.tracker.invasion == 0) {
    html += '<li class="option" id="land">relocate infantry</li>';
  }
  if (ac.length > 0) {
    html += '<li class="option" id="action">play action card</li>';
  }
  html += '<li class="option" id="finish">finish turn</li>';
  html += '</ul>';

  imperium_self.updateStatus(html);

  $('.option').on('click', function () {

    let action2 = $(this).attr("id");

    if (action2 == "action") {
      imperium_self.playerSelectActionCard(function (card) {
        imperium_self.addMove("activate_system_post\t" + imperium_self.game.player + "\t" + sector);
        imperium_self.game.players_info[this.game.player - 1].action_cards_played.push(card);
        imperium_self.addMove("action_card_post\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("action_card\t" + imperium_self.game.player + "\t" + card);
        imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");
      }, function () {
        imperium_self.playerPlayActionCardMenu(action_card_player, card);
      }, ["action"]);
    }


    if (action2 == "invade") {

      //
      // New Byzantium requires 6 influence to conquer
      //
      if (sector === "new-byzantium" || sector == "4_4") {
        if (imperium_self.game.planets['new-byzantium'].owner == -1) {
          if (imperium_self.returnAvailableInfluence(imperium_self.game.player) >= 6) {
            imperium_self.playerSelectInfluence(6, function (success) {
              imperium_self.game.tracker.invasion = 1;
              imperium_self.playerInvadePlanet(player, sector);
            });
          } else {
            salert("The first conquest of New Byzantium requires spending 6 influence, which you lack.");
            return;
          }
          return;
        }
      }

      imperium_self.game.tracker.invasion = 1;
      imperium_self.playerInvadePlanet(player, sector);
    }



    if (action2 == "land") {
      imperium_self.addMove("continue\t" + imperium_self.game.player + "\t" + sector);
      imperium_self.playerSelectInfantryToLand(sector);
      return 0;
    }

    if (action2 == "move") {
      imperium_self.playerSelectUnitsToMove(sector);
    }
    if (action2 == "produce") {
      //
      // check the fleet supply and NOTIFY users if they are about to surpass it
      //
      let fleet_supply_in_sector = imperium_self.returnSpareFleetSupplyInSector(player, sector);
      if (fleet_supply_in_sector <= 1) {
        let notice = "You have no spare fleet supply in this sector. Do you still wish to produce more ships?";
        if (fleet_supply_in_sector == 1) {
          notice = "You have fleet supply for 1 additional capital ship in this sector. Do you still wish to produce more ships?";
        }
        let c = confirm(notice);
        if (c) {
          imperium_self.playerProduceUnits(sector);
        }
        return;
      }
      imperium_self.playerProduceUnits(sector);
    }
    if (action2 == "finish") {
      if (!imperium_self.moves.includes("resolve\tplay")) { imperium_self.addMove("resolve\tplay"); }
      imperium_self.addMove("setvar\tstate\t0\tactive_player_moved\t" + "int" + "\t" + "0");
      imperium_self.endTurn();
    }
  });
}






playerAllocateNewTokens(player, tokens, resolve_needed = 1, stage = 0, leadership_primary = 0) {

  let imperium_self = this;

  if (this.game.player == player) {

    let obj = {};
    obj.current_command = this.game.players_info[player - 1].command_tokens;
    obj.current_strategy = this.game.players_info[player - 1].strategy_tokens;
    obj.current_fleet = this.game.players_info[player - 1].fleet_supply;
    obj.new_command = 0;
    obj.new_strategy = 0;
    obj.new_fleet = 0;
    obj.new_tokens = tokens;


    let updateInterface = function (imperium_self, obj, updateInterface) {

      let html = '<div class="sf-readable">You have ' + obj.new_tokens + ' tokens to allocate. How do you want to allocate them? </div><ul>';

      if (stage == 1) {
        html = '<div class="sf-readable">The Leadership card gives you ' + obj.new_tokens + ' tokens to allocate. How do you wish to allocate them? </div><ul>';
      }
      if (stage == 2) {
        html = '<div class="sf-readable">Leadership has been played and you have purchased ' + obj.new_tokens + ' additional tokens. How do you wish to allocate them? </div><ul>';
      }
      if (stage == 3) {
        html = '<div class="sf-readable">You have ' + obj.new_tokens + ' new tokens to allocate: </div><ul>';
      }

      html += '<li class="option" id="command">Command Token - ' + (parseInt(obj.current_command) + parseInt(obj.new_command)) + '</li>';
      html += '<li class="option" id="strategy">Strategy Token - ' + (parseInt(obj.current_strategy) + parseInt(obj.new_strategy)) + '</li>';
      html += '<li class="option" id="fleet">Fleet Supply - ' + (parseInt(obj.current_fleet) + parseInt(obj.new_fleet)) + '</li>';
      html += '</ul>';

      imperium_self.updateStatus(html);
      imperium_self.lockInterface();

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "strategy") {
          obj.new_strategy++;
          obj.new_tokens--;
        }

        if (id == "command") {
          obj.new_command++;
          obj.new_tokens--;
        }

        if (id == "fleet") {
          obj.new_fleet++;
          obj.new_tokens--;
        }

        if (obj.new_tokens == 0) {
          if (resolve_needed == 1) {
            if (imperium_self.game.confirms_needed > 0 && leadership_primary == 0) {
              imperium_self.addMove("resolve\ttokenallocation\t1\t" + imperium_self.app.wallet.returnPublicKey());
            } else {
              imperium_self.addMove("resolve\ttokenallocation");
            }
          }
          imperium_self.addMove("purchase\t" + player + "\tstrategy\t" + obj.new_strategy);
          imperium_self.addMove("purchase\t" + player + "\tcommand\t" + obj.new_command);
          imperium_self.addMove("purchase\t" + player + "\tfleetsupply\t" + obj.new_fleet);
          imperium_self.unlockInterface();
          imperium_self.endTurn();
        } else {
          imperium_self.unlockInterface();
          updateInterface(imperium_self, obj, updateInterface);
        }

      });
    };

    updateInterface(imperium_self, obj, updateInterface);

  }

  return 0;
}





playerSelectPlayerWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < this.game.players_info.length; i++) {
    if (filter_func(this.game.players_info[i]) == 1) {
      html += '<li class="textchoice" id="' + (i + 1) + '">' + this.returnFaction((i + 1)) + '</li>';
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  imperium_self.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();



    let action = $(this).attr("id");

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    mycallback(action);

  });
}



playerSelectSectorWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.board) {
    if (filter_func(this.game.board[i].tile) == 1) {
      html += '<li class="textchoice" id="' + i + '">' + this.game.sectors[this.game.board[i].tile].name + '</li>';
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);
  this.lockInterface();


  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.showSectorHighlight(s);
    }
  });
  $('.textchoice').on('mouseleave', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.hideSectorHighlight(s);
    }
  });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");

    if (action != "cancel") {
      imperium_self.hideSectorHighlight(action);
    }

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    imperium_self.updateStatus("");
    mycallback(imperium_self.game.board[action].tile);

  });
}





playerSelectChoice(msg, choices, elect = "other", mycallback = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < choices.length; i++) {
    if (elect == "player") {
      if (this.returnFaction(choices[i]) != "Unknown") {
        html += '<li class="textchoice" id="' + i + '">' + this.returnFaction(choices[i]) + '</li>';
      } else {
        html += '<li class="textchoice" id="' + i + '">' + choices[i] + '</li>';
      }
    }
    if (elect == "planet") {
      html += '<li class="textchoice" id="' + i + '">' + this.game.planets[choices[i]].name + '</li>';
    }
    if (elect == "sector") {
      html += '<li class="textchoice" id="' + i + '">' + this.game.sectors[this.game.board[choices[i]].tile].name + '</li>';
    }
    if (elect == "other") {
      html += '<li class="textchoice" id="' + i + '">' + choices[i] + '</li>';
    }
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();

    let action = $(this).attr("id");
    mycallback(action);

  });

}










playerSelectPlanetWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.planets) {
    if (this.game.planets[i].tile != "") {
      if (filter_func(i) == 1) {
        html += '<li class="textchoice" id="' + i + '">' + this.game.planets[i].name + '</li>';
      }
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx);
      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
    }
  });
  $('.textchoice').on('mouseleave', function () {
    let s = $(this).attr("id");
    if (s != "cancel") {
      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx);
      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
    }
  });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    if (action != "cancel") {
      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx);
      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);
    }

    if (action == "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }

    imperium_self.updateStatus("");
    imperium_self.hideSectorHighlight(action);
    mycallback(action);

  });
}




playerSelectUnitInSectorWithFilter(msg, sector, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let unit_array = [];
  let sector_array = [];
  let planet_array = [];
  let unit_idx = [];
  let exists_unit = 0;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  let sys = this.returnSectorAndPlanets(sector);

  for (let k = 0; k < sys.s.units[imperium_self.game.player - 1].length; k++) {
    if (filter_func(sys.s.units[imperium_self.game.player - 1][k])) {
      unit_array.push(sys.s.units[imperium_self.game.player - 1][k]);
      sector_array.push(sector);
      planet_array.push(-1);
      unit_idx.push(k);
      exists_unit = 1;
      html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.name + ' - ' + unit_array[unit_array.length - 1].name + '</li>';
    }
  }

// HACK
  for (let p = 0; p < sys.p.length; p++) {
    for (let k = 0; k < sys.p[p].units[imperium_self.game.player - 1].length; k++) {
      if (filter_func(sys.p[p].units[imperium_self.game.player - 1][k])) {
        unit_array.push(sys.p[p].units[imperium_self.game.player - 1][k]);
        sector_array.push(sector);
        planet_array.push(p);
        unit_idx.push(k);
        exists_unit = 1;
        html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.sector + ' / ' + sys.p[p].name + " - " + unit_array[unit_array.length - 1].name + '</li>';
      }
    }
  }

  if (exists_unit == 0) {
    html += '<li class="textchoice" id="none">no unit available</li>';
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  //    $('.textchoice').on('mouseenter', function() { 
  //      let s = $(this).attr("id"); 
  //      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  //    $('.textchoice').on('mouseleave', function() { 
  //      let s = $(this).attr("id");
  //      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
  //    });

  this.lockInterface();

  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    //      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx); 
    //      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);

    if (action === "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }
    if (action === "none") {
      let unit_to_return = { sector: "", planet_idx: "", unit_idx: -1, unit: null }
      mycallback(unit_to_return);
      return;
    }

    let unit_to_return = { sector: sector_array[action], planet_idx: planet_array[action], unit_idx: unit_idx[action], unit: unit_array[action] }
    //      imperium_self.hideSectorHighlight(action);

    imperium_self.updateStatus("");
    mycallback(unit_to_return);

  });
}






playerSelectUnitWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let unit_array = [];
  let sector_array = [];
  let planet_array = [];
  let unit_idx = [];
  let exists_unit = 0;

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i in this.game.sectors) {

    let sys = this.returnSectorAndPlanets(i);
    let sector = i;

    for (let k = 0; k < sys.s.units[imperium_self.game.player - 1].length; k++) {
      if (filter_func(sys.s.units[imperium_self.game.player - 1][k])) {
        unit_array.push(sys.s.units[imperium_self.game.player - 1][k]);
        sector_array.push(sector);
        planet_array.push(-1);
        unit_idx.push(k);
        exists_unit = 1;
        html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.name + ' - ' + unit_array[unit_array.length - 1].name + '</li>';
      }
    }

    for (let p = 0; p < sys.p.length; p++) {
      for (let k = 0; k < sys.p[p].units[imperium_self.game.player - 1].length; k++) {
        if (filter_func(sys.p[p].units[imperium_self.game.player - 1][k])) {
          unit_array.push(sys.p[p].units[imperium_self.game.player - 1][k]);
          sector_array.push(sector);
          planet_array.push(p);
          unit_idx.push(k);
          exists_unit = 1;
          html += '<li class="textchoice" id="' + (unit_array.length - 1) + '">' + sys.s.sector + ' / ' + sys.p[p].name + " - " + unit_array[unit_array.length - 1].name + '</li>';
        }
      }
    }

  }
  if (exists_unit == 0) {
    html += '<li class="textchoice" id="none">no unit available</li>';
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  this.lockInterface();

  $('.textchoice').off();
  //    $('.textchoice').on('mouseenter', function() { 
  //      let s = $(this).attr("id"); 
  //      imperium_self.showPlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.showSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  //    $('.textchoice').on('mouseleave', function() { 
  //      let s = $(this).attr("id");
  //      imperium_self.hidePlanetCard(imperium_self.game.planets[s].tile, imperium_self.game.planets[s].idx); 
  //      imperium_self.hideSectorHighlight(imperium_self.game.planets[s].tile);
  //    });
  $('.textchoice').on('click', function () {

    if (!imperium_self.mayUnlockInterface()) {
      salert("The game engine is currently processing moves related to another player's move. Please wait a few seconds and reload your browser.");
      return;
    }
    imperium_self.unlockInterface();


    let action = $(this).attr("id");
    //      imperium_self.hidePlanetCard(imperium_self.game.planets[action].tile, imperium_self.game.planets[action].idx); 
    //      imperium_self.hideSectorHighlight(imperium_self.game.planets[action].tile);

    if (action === "cancel") {
      cancel_func();
      imperium_self.hideSectorHighlight(action);
      return 0;
    }
    if (action === "none") {
      let unit_to_return = { sector: "", planet_idx: "", unit_idx: -1, unit: null }
      mycallback(unit_to_return);
      return;
    }

    let unit_to_return = { sector: sector_array[action], planet_idx: planet_array[action], unit_idx: unit_idx[action], unit: unit_array[action] }
    //      imperium_self.hideSectorHighlight(action);

    imperium_self.updateStatus("");
    mycallback(unit_to_return);

  });
}





playerSelectUnitInSectorFilter(msg, sector, filter_func, mycallback = null, cancel_func = null) {

  let imperium_self = this;
  let sys = this.returnSectorAndPlanets(sector);

  let html = '<div class="sf-readable">' + msg + '</div>';
  html += '<ul>';

  for (let i = 0; i < this.game.players_info.length; i++) {
    for (let ii = 0; ii < sys.s.units[i].length; ii++) {
      if (filter_func(sys.s.units[i][ii]) == 1) {
        html += '<li class="textchoice" id="' + sector + '_' + i + '_' + i + '">' + this.returnFaction((i + 1)) + " - " + sys.s.units[i][ii].name + '</li>';
      }
    }
  }
  if (cancel_func != null) {
    html += '<li class="textchoice" id="cancel">cancel</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('click', function () {

    let action = $(this).attr("id");

    if (action == "cancel") {
      cancel_func();
      return 0;
    }

    let tmpar = action.split("_");

    let s = tmpar[0];
    let p = tmpar[1];
    let unitidx = tmpar[2];

    mycallback({ sector: s, player: p, unitidx: unitidx });

  });
}



playerDiscardActionCards(num, mycallback=null) {

  let imperium_self = this;

  if (num < 0) { imperium_self.endTurn(); }

  let html = "<div class='sf-readable'>You must discard <div style='display:inline' class='totalnum' id='totalnum'>" + num + "</div> action card"; if (num > 1) { html += 's'; }; html += ':</div>';
  html += '<ul>';
  let ac_in_hand = this.returnPlayerActionCards(imperium_self.game.player);

  for (let i = 0; i < ac_in_hand.length; i++) {
    html += '<li class="textchoice" id="' + i + '">' + this.action_cards[ac_in_hand[i]].name + '</li>';
  }
  html += '</ul>';

  this.updateStatus(html);

  $('.textchoice').off();
  $('.textchoice').on('mouseenter', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.showActionCard(ac_in_hand[s]); } });
  $('.textchoice').on('mouseleave', function () { let s = $(this).attr("id"); if (s != "cancel") { imperium_self.hideActionCard(ac_in_hand[s]); } });
  $('.textchoice').on('click', function () {

    let action2 = $(this).attr("id");

    num--;

    $('.totalnum').html(num);
    $(this).remove();

    imperium_self.hideActionCard(action2);
    imperium_self.game.players_info[imperium_self.game.player - 1].action_cards_played.push(ac_in_hand[action2]);
    imperium_self.addMove("lose\t" + imperium_self.game.player + "\taction_cards\t1");

    if (num == 0) {

      if (mycallback == null) {
        imperium_self.updateStatus("discarding...");
        imperium_self.endTurn();
      } else {
	mycallback();
      }
    }

  });

}




